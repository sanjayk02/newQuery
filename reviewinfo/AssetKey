/ Keys from first query
type AssetKey struct {
    Root     string `json:"root"`
    Project  string `json:"project"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`
}

// Raw rows from second query (latest row per phase)
type PhaseRow struct {
    Root             string     `gorm:"column:root" json:"root"`
    Project          string     `gorm:"column:project" json:"project"`
    Group1           string     `gorm:"column:group_1" json:"group_1"`
    Relation         string     `gorm:"column:relation" json:"relation"`
    Phase            string     `gorm:"column:phase" json:"phase"`
    WorkStatus       *string    `gorm:"column:work_status" json:"work_status"`
    ApprovalStatus   *string    `gorm:"column:approval_status" json:"approval_status"`
    SubmittedAtUTC   *time.Time `gorm:"column:submitted_at_utc" json:"submitted_at_utc"`
    ModifiedAtUTC    *time.Time `gorm:"column:modified_at_utc" json:"modified_at_utc"`
    ExecutedComputer *string    `gorm:"column:executed_computer" json:"executed_computer"`
}

// Final pivoted row (one per asset) â€” field names match your sample
type AssetPhaseSummary struct {
    Root     string `json:"root"`
    Project  string `json:"project"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`

    MdlWorkStatus       *string `json:"mdl_work_status"`
    MdlApprovalStatus   *string `json:"mdl_approval_status"`
    MdlSubmittedAtUTC   *time.Time `json:"mdl_submitted_at_utc"`

    RigWorkStatus       *string `json:"rig_work_status"`
    RigApprovalStatus   *string `json:"rig_approval_status"`
    RigSubmittedAtUTC   *time.Time `json:"rig_submitted_at_utc"`

    BldWorkStatus       *string `json:"bld_work_status"`
    BldApprovalStatus   *string `json:"bld_approval_status"`
    BldSubmittedAtUTC   *time.Time `json:"bld_submitted_at_utc"`

    DsnWorkStatus       *string `json:"dsn_work_status"`
    DsnApprovalStatus   *string `json:"dsn_approval_status"`
    DsnSubmittedAtUTC   *time.Time `json:"dsn_submitted_at_utc"`

    LdvWorkStatus       *string `json:"ldv_work_status"`
    LdvApprovalStatus   *string `json:"ldv_approval_status"`
    LdvSubmittedAtUTC   *time.Time `json:"ldv_submitted_at_utc"`
}

// PivotPhaseRows collapses latest-per-phase rows into one summary per asset,
// preserving the order of the 'keys' slice.
func PivotPhaseRows(keys []AssetKey, rows []PhaseRow) []AssetPhaseSummary {
    // index rows by composite key
    byKey := make(map[string][]PhaseRow, len(keys))
    keyOf := func(root, project, g1, rel string) string {
        return root + "\x00" + project + "\x00" + g1 + "\x00" + rel
    }
    for _, r := range rows {
        k := keyOf(r.Root, r.Project, r.Group1, r.Relation)
        byKey[k] = append(byKey[k], r)
    }

    out := make([]AssetPhaseSummary, 0, len(keys))
    for _, k := range keys {
        sum := AssetPhaseSummary{
            Root: k.Root, Project: k.Project, Group1: k.Group1, Relation: k.Relation,
        }
        for _, r := range byKey[keyOf(k.Root, k.Project, k.Group1, k.Relation)] {
            switch strings.ToLower(r.Phase) {
            case "mdl":
                sum.MdlWorkStatus = r.WorkStatus
                sum.MdlApprovalStatus = r.ApprovalStatus
                sum.MdlSubmittedAtUTC = r.SubmittedAtUTC
            case "rig":
                sum.RigWorkStatus = r.WorkStatus
                sum.RigApprovalStatus = r.ApprovalStatus
                sum.RigSubmittedAtUTC = r.SubmittedAtUTC
            case "bld":
                sum.BldWorkStatus = r.WorkStatus
                sum.BldApprovalStatus = r.ApprovalStatus
                sum.BldSubmittedAtUTC = r.SubmittedAtUTC
            case "dsn":
                sum.DsnWorkStatus = r.WorkStatus
                sum.DsnApprovalStatus = r.ApprovalStatus
                sum.DsnSubmittedAtUTC = r.SubmittedAtUTC
            case "ldv":
                sum.LdvWorkStatus = r.WorkStatus
                sum.LdvApprovalStatus = r.ApprovalStatus
                sum.LdvSubmittedAtUTC = r.SubmittedAtUTC
            }
        }
        out = append(out, sum)
    }
    return out
}

func (r *Repository) GetPivotPage(
    ctx context.Context,
    db *gorm.DB,
    project, root, sort, dir string,
    page, per int,
) ([]AssetPhaseSummary, int64, error) {

    if per <= 0 { per = 15 }
    if page <= 0 { page = 1 }
    offset := (page - 1) * per

    // total assets
    var total int64
    if err := db.WithContext(ctx).Raw(`
SELECT COUNT(*) FROM (
  SELECT project, root, group_1, relation
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0
  GROUP BY project, root, group_1, relation
) x;`, project, root).Scan(&total).Error; err != nil {
        return nil, 0, err
    }

    // page of ordered assets (first query)
    keys, err := r.ListOrderedAssetKeys(ctx, db, project, root, sort, dir, per, offset)
    if err != nil {
        return nil, 0, err
    }
    if len(keys) == 0 {
        return []AssetPhaseSummary{}, total, nil
    }

    // hydrate latest per phase for those keys (second query)
    phaseRows, err := r.HydrateLatestPhasesForKeys(ctx, db, keys)
    if err != nil {
        return nil, 0, err
    }

    // pivot to the exact shape you want
    assets := PivotPhaseRows(keys, phaseRows)
    return assets, total, nil
}



// ListOrderedAssetKeys executes your "First query" to produce an ordered,
// paginated list of unique asset keys. Sorting is whitelisted to avoid SQLi.
func (r *Repository) ListOrderedAssetKeys(
        ctx context.Context,
        db *gorm.DB,
        project string,
        root string,
        sortField string, // e.g. "group_1" (default) or "relation"
        sortDir string,   // "asc" | "desc" (minus prefix on sortField also supported)
        limit, offset int,
) ([]AssetKey, error) {

        // --- Normalize sort ---
        // accept minus-prefix or separate dir
        field := strings.TrimSpace(sortField)
        if field == "" {
                field = "group_1"
        }
        if strings.HasPrefix(field, "-") {
                sortDir = "desc"
                field = strings.TrimPrefix(field, "-")
        }
        dir := "ASC"
        if strings.EqualFold(sortDir, "desc") {
                dir = "DESC"
        }

        // whitelist fields we allow in the ORDER BY of the first CTE
        switch strings.ToLower(field) {
        case "group_1":
                // ok
        case "relation":
                // ok
        default:
                field = "group_1"
        }

        // --- The SQL (verbatim to your first query, with dynamic ORDER BY) ---
        firstSQL := fmt.Sprintf(`
WITH ordered AS (
  SELECT *, ROW_NUMBER() OVER (
    ORDER BY %s %s
  ) AS _order
  FROM (
    SELECT b.*
    FROM (
      SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
      GROUP BY project, root, group_1, relation, phase
    ) AS a
    LEFT JOIN t_review_info AS b
      ON  a.project = b.project
      AND a.root    = b.root
      AND a.group_1 = b.group_1
      AND a.relation= b.relation
      AND a.phase   = b.phase
      AND a.modified_at_utc = b.modified_at_utc
    ORDER BY submitted_at_utc ASC
  ) AS k
),
offset_ordered AS (
  SELECT c.*, CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
)
SELECT root, project, group_1, relation
FROM ranked
WHERE _rank = 1
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, field, dir)

        // params in order: (project, root) for the inner GROUP BY, then LIMIT/OFFSET
        params := []interface{}{project, root, limit, offset}

        var keys []AssetKey
        if err := db.WithContext(ctx).Raw(firstSQL, params...).Scan(&keys).Error; err != nil {
                return nil, err
        }
        return keys, nil
}
