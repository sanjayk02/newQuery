// reviewinfo/repository.go

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// ... (AssetKey, PhaseRow, AssetPhaseSummary, etc. definitions remain the same) ...

// ============================================================================
// LIST ORDERED ASSETS - First Query (MODIFIED FOR GLOBAL PHASE SORT)
// ============================================================================
func (r *Repository) ListOrderedAssets(
	ctx context.Context,
	db *gorm.DB,
	project, root, sortField, sortDir string,
	limit, offset int,
) ([]AssetKey, int64, error) {
	// 1. Determine the canonical direction
	dir := "ASC"
	if strings.EqualFold(sortDir, "DESC") || strings.HasPrefix(sortField, "-") {
		dir = "DESC"
	}
	// 2. Normalize field (remove prefix/suffix)
	normalizedField := strings.TrimPrefix(strings.ToLower(sortField), "-")

	// 3. Check if sorting by a PIVOTED PHASE field
	var sortColumn string
	var joinClause string
	isPhaseSort := false

	switch normalizedField {
	case "group_1", "relation":
		// Simple asset-level sort (default/working logic)
		sortColumn = normalizedField
	case "mdl_work", "mdl_appr", "mdl_submitted",
		"rig_work", "rig_appr", "rig_submitted",
		"bld_work", "bld_appr", "bld_submitted",
		"dsn_work", "dsn_appr", "dsn_submitted",
		"ldv_work", "ldv_appr", "ldv_submitted":
		// Complex Phase Sort Logic
		isPhaseSort = true
		
		// Split field to get phase ("mdl", "rig") and column ("work", "appr", "submitted")
		parts := strings.Split(normalizedField, "_")
		phase := parts[0]
		field := strings.Join(parts[1:], "_")

		// Map API field name to SQL column name
		sqlCol := map[string]string{
			"work":      "work_status",
			"appr":      "approval_status",
			"submitted": "submitted_at_utc",
		}[field]

		if sqlCol == "" {
			// Fallback if the field name is invalid
			sortColumn = "group_1"
			isPhaseSort = false
			break
		}
		
		// Use a specific alias (phase_sort) for the joined column
		sortColumn = "phase_sort." + sqlCol

		// Construct the JOIN clause to find the specific latest phase value for ordering
		joinClause = fmt.Sprintf(`
			LEFT JOIN (
				SELECT 
					b.project, b.root, b.group_1, b.relation,
					b.%[4]s, -- The column we are sorting by (e.g., submitted_at_utc)
					ROW_NUMBER() OVER (
						PARTITION BY b.project, b.root, b.group_1, b.relation
						ORDER BY 
							CASE WHEN b.phase = '%[3]s' THEN 0 ELSE 1 END, -- Prioritize the specific phase
							b.modified_at_utc DESC
					) AS rn
				FROM t_review_info b
				WHERE b.project = ? AND b.root = ? AND b.deleted = 0
			) AS phase_sort
			ON keys.project = phase_sort.project 
			AND keys.root = phase_sort.root 
			AND keys.group_1 = phase_sort.group_1 
			AND keys.relation = phase_sort.relation 
			AND phase_sort.rn = 1 -- Only join the single row that dictates the sort
		`, phase, field, sqlCol) // The second and third placeholders are not used in the final query but are passed to satisfy syntax
	default:
		// Unknown sort field fallback
		sortColumn = "group_1"
	}
	
	// 4. Get Total Count (Unchanged)
	var total int64
	// ... (countSQL execution remains the same) ... 
	countSQL := `
SELECT COUNT(*) FROM (
  SELECT project, root, group_1, relation
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0
  GROUP BY project, root, group_1, relation
) x;
`
	if err := db.WithContext(ctx).Raw(countSQL, project, root).Scan(&total).Error; err != nil {
		return nil, 0, err
	}


	// 5. Construct the final ordered SQL query
	// The `keys` CTE remains to get unique asset identifiers (required for the LEFT JOIN ON)
	orderedSQL := fmt.Sprintf(`
WITH keys AS (
  SELECT
    t.project,
    t.root,
    t.group_1,
    t.relation
  FROM t_review_info t
  WHERE t.project = ? AND t.root = ? AND t.deleted = 0
  GROUP BY t.project, t.root, t.group_1, t.relation
),
-- Optional: Apply the JOIN for phase sorting here
ordered AS (
  SELECT
    k.project, k.root, k.group_1, k.relation,
    ROW_NUMBER() OVER (ORDER BY %[4]s %[1]s) AS seq -- Sort by the determined column
  FROM keys k
  %[3]s -- Add the JOIN clause here if needed (it is empty if isPhaseSort is false)
)
SELECT project, root, group_1, relation, seq
FROM ordered
ORDER BY seq
LIMIT ? OFFSET ?;
`, dir, normalizedField, joinClause, sortColumn)

	// Determine parameters for Raw query
	var rawParams []interface{}
	if isPhaseSort {
		// The two '?' placeholders inside the phase_sort CTE need to be filled
		// with project and root before the LIMIT/OFFSET ones.
		rawParams = append(rawParams, project, root, limit, offset) 
	} else {
		rawParams = append(rawParams, project, root, limit, offset)
	}

	var keys []AssetKey
	if err := db.WithContext(ctx).Raw(orderedSQL, rawParams...).Scan(&keys).Error; err != nil {
		return nil, 0, err
	}
	return keys, total, nil
}
