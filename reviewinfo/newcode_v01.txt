type AssetKey struct {
    Root     string `json:"root"`
    Project  string `json:"project"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`
}

type PhaseRow struct {
    Root             string     `gorm:"column:root" json:"root"`
    Project          string     `gorm:"column:project" json:"project"`
    Group1           string     `gorm:"column:group_1" json:"group_1"`
    Relation         string     `gorm:"column:relation" json:"relation"`
    Phase            string     `gorm:"column:phase" json:"phase"`
    WorkStatus       *string    `gorm:"column:work_status" json:"work_status"`
    ApprovalStatus   *string    `gorm:"column:approval_status" json:"approval_status"`
    SubmittedAtUTC   *time.Time `gorm:"column:submitted_at_utc" json:"submitted_at_utc"`
    ModifiedAtUTC    *time.Time `gorm:"column:modified_at_utc" json:"modified_at_utc"`
    ExecutedComputer *string    `gorm:"column:executed_computer" json:"executed_computer"`
}

func (r *Repository) ListOrderedAssetKeys(
    ctx context.Context,
    db *gorm.DB,
    project, root string,
    sortField string, // expect "group_1" (matches your sample)
    sortDir   string, // "asc" or "desc"
    limit, offset int,
) ([]AssetKey, error) {

    // whitelist sort
    orderExpr := "group_1"
    if strings.EqualFold(sortField, "group_1") {
        orderExpr = "group_1"
    }
    dir := "ASC"
    if strings.EqualFold(sortDir, "desc") || strings.HasPrefix(sortField, "-") {
        dir = "DESC"
    }

    // NOTE: keep your original CASE/phase='' logic intact
    firstSQL := fmt.Sprintf(`
WITH ordered AS (
  SELECT *, ROW_NUMBER() OVER (
    ORDER BY %s %s
  ) AS _order
  FROM (
    SELECT b.* 
    FROM (
      SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
      GROUP BY project, root, group_1, relation, phase
    ) AS a
    LEFT JOIN t_review_info AS b
      ON a.project=b.project AND a.root=b.root
     AND a.group_1=b.group_1 AND a.relation=b.relation
     AND a.phase=b.phase AND a.modified_at_utc=b.modified_at_utc
    ORDER BY submitted_at_utc ASC
  ) AS k
),
offset_ordered AS (
  SELECT c.*, CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
)
SELECT root, project, group_1, relation
FROM ranked
WHERE _rank = 1
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, orderExpr, dir)

    params := []interface{}{project, root, limit, offset}
    var keys []AssetKey
    if err := db.WithContext(ctx).Raw(firstSQL, params...).Scan(&keys).Error; err != nil {
        return nil, err
    }
    return keys, nil
}

func (r *Repository) HydrateLatestPhasesForKeys(
    ctx context.Context,
    db *gorm.DB,
    keys []AssetKey,
) ([]AssetPhaseSummary, error) {

    // Build value tuples
    var valTuples []string
    var args []interface{}

    for _, k := range keys {
        valTuples = append(valTuples, "(?,?,?,?)")
        args = append(args, k.Root, k.Project, k.Group1, k.Relation)
    }

    sql := fmt.Sprintf(`
WITH keyset AS (
    SELECT * FROM (VALUES %s) AS v(root, project, group_1, relation)
),
latest AS (
    SELECT b.*
    FROM t_review_info b
    JOIN (
        SELECT project, root, group_1, relation, phase,
            MAX(modified_at_utc) AS modified_at_utc
        FROM t_review_info
        WHERE deleted = 0
        GROUP BY project, root, group_1, relation, phase
    ) AS a ON a.project=b.project AND a.root=b.root
          AND a.group_1=b.group_1 AND a.relation=b.relation
          AND a.phase=b.phase AND a.modified_at_utc=b.modified_at_utc
    WHERE (b.root, b.project, b.group_1, b.relation) IN (SELECT root, project, group_1, relation FROM keyset)
)
SELECT ... -- pivot logic building mdl_*/rig_*/...
`, strings.Join(valTuples, ","))

    var rows []AssetPhaseSummary
    if err := db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
        return nil, err
    }
    return rows, nil
}


//


func (r *Repository) GetPivotPage(
    ctx context.Context,
    db *gorm.DB,
    project, root, sort, dir string,
    page, per int,
) ([]AssetPhaseSummary, int64, error) {

    // 1) First query: return keys/page order
    keys, total, err := r.ListOrderedAssets(ctx, db, project, root, sort, dir, per, (page-1)*per)
    if err != nil {
        return nil, 0, err
    }

    if len(keys) == 0 {
        return []AssetPhaseSummary{}, total, nil
    }

    // 2) Second query: hydrate pivot rows
    pivot, err := r.HydrateLatestPhasesForKeys(ctx, db, keys)
    if err != nil {
        return nil, 0, err
    }

    return pivot, total, nil
}


//

router.GET("/api/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
    ctx := c.Request.Context()
    project := c.Param("project")
    root := c.DefaultQuery("root", "assets")
    sort := c.DefaultQuery("sort", "group_1")
    dir  := c.DefaultQuery("dir", "asc")
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    per,  _ := strconv.Atoi(c.DefaultQuery("per_page", "15"))
    if per <= 0 { per = 15 }

    // ✅ Call two-step pivot builder
    rows, total, err := repo.GetPivotPage(ctx, gormDB, project, root, sort, dir, page, per)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }

    c.JSON(200, gin.H{
        "data":    rows,
        "page":    page,
        "perPage": per,
        "total":   total,
    })
})

router.GET("/api/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
    ctx := c.Request.Context()
    project := c.Param("project")
    root := c.DefaultQuery("root", "assets")
    sort := c.DefaultQuery("sort", "group_1")
    dir  := c.DefaultQuery("dir", "asc")
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    per,  _ := strconv.Atoi(c.DefaultQuery("per_page", "15"))
    if per <= 0 { per = 15 }

    // ✅ Call two-step pivot builder
    rows, total, err := repo.GetPivotPage(ctx, gormDB, project, root, sort, dir, page, per)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }

    c.JSON(200, gin.H{
        "data":    rows,
        "page":    page,
        "perPage": per,
        "total":   total,
    })
})



