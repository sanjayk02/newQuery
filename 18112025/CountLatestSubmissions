func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root string,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// Name & status filters (frontend-compatible)
	nameWhere, nameArgs := buildAssetNameWhere(assetNameKey, "")
	statusWhere, statusArgs := buildStatusFilterClause("", approvalStatuses, workStatuses)

	nameClause := ""
	if nameWhere != "" {
		nameClause = " AND " + nameWhere
	}
	statusClause := ""
	if statusWhere != "" {
		statusClause = " AND " + statusWhere
	}

	// latest_rows = latest row per (asset, phase)
	// filtered    = apply name + status filters at phase-row level
	// then count distinct assets from filtered
	q := fmt.Sprintf(`
WITH latest_rows AS (
	SELECT
		project,
		root,
		group_1,
		relation,
		phase,
		work_status,
		approval_status,
		submitted_at_utc,
		modified_at_utc,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation, phase
			ORDER BY modified_at_utc DESC
		) AS rn
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0
),
filtered AS (
	SELECT *
	FROM latest_rows
	WHERE rn = 1%s%s
)
SELECT COUNT(*)
FROM (
	SELECT DISTINCT project, root, group_1, relation
	FROM filtered
) AS a;`, nameClause, statusClause)

	args := []any{
		project, root, // latest_rows WHERE
	}
	args = append(args, nameArgs...)
	args = append(args, statusArgs...)

	var total int64
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}
	return total, nil
}
