func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root string,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) (int64, error) {

	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	nameWhere, nameArgs := buildAssetNameWhere(assetNameKey)
	statusWhere, statusArgs := buildPhaseAwareStatusWhere("", approvalStatuses, workStatuses)

	nameClause := ""
	if nameWhere != "" {
		nameClause = " AND " + nameWhere
	}

	statusClause := ""
	if statusWhere != "" {
		statusClause = " AND " + statusWhere
	}

	// FINAL SQL - matches UI exactly
	q := fmt.Sprintf(`
WITH latest_rows AS (
	SELECT
		project,
		root,
		group_1,
		relation,
		phase,
		work_status,
		approval_status,
		submitted_at_utc,
		modified_at_utc,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation, phase
			ORDER BY modified_at_utc DESC
		) AS rn
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0
),
filtered AS (
	SELECT *
	FROM latest_rows
	WHERE rn = 1
	%s
	%s
)
SELECT COUNT(*)
FROM (
	SELECT DISTINCT project, root, group_1, relation
	FROM filtered
) AS assets;
`, nameClause, statusClause)

	args := []any{project, root}
	args = append(args, nameArgs...)
	args = append(args, statusArgs...)

	var total int64
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}
	return total, nil
}
