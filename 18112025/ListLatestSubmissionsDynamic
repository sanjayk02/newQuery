func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// phaseGuard = 1 â†’ no phase bias
	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	// Same filters as CountLatestSubmissions
	nameWhere, nameArgs := buildAssetNameWhere(assetNameKey, "")
	statusWhere, statusArgs := buildStatusFilterClause("", approvalStatuses, workStatuses)

	nameClause := ""
	if nameWhere != "" {
		nameClause = " AND " + nameWhere
	}
	statusClause := ""
	if statusWhere != "" {
		statusClause = " AND " + statusWhere
	}

	// Sort the final collapsed rows using alias "x"
	orderClause := buildOrderClause("x", orderKey, direction)

	q := fmt.Sprintf(`
WITH latest_rows AS (
	SELECT
		project,
		root,
		group_1,
		relation,
		phase,
		work_status,
		approval_status,
		submitted_at_utc,
		modified_at_utc,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation, phase
			ORDER BY modified_at_utc DESC
		) AS rn
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0
),
filtered AS (
	SELECT *
	FROM latest_rows
	WHERE rn = 1%s%s
),
ranked AS (
	SELECT
		*,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation
			ORDER BY
				CASE
					WHEN ? = 1 THEN 0
					WHEN phase = ? THEN 0 ELSE 1
				END,
				modified_at_utc DESC
		) AS rk
	FROM filtered
)
SELECT
	x.root,
	x.project,
	x.group_1,
	x.relation,
	x.phase,
	x.submitted_at_utc
FROM ranked AS x
WHERE x.rk = 1
ORDER BY %s
LIMIT ? OFFSET ?;`, nameClause, statusClause, orderClause)

	args := []any{
		project, root, // latest_rows WHERE
	}
	args = append(args, nameArgs...)
	args = append(args, statusArgs...)
	args = append(args,
		phaseGuard,
		strings.ToLower(preferredPhase),
	)
	args = append(args, limit, offset)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}
