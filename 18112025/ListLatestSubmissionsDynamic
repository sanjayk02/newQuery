func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string, // e.g. "mdl" or "none"
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) ([]LatestSubmissionRow, error) {

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// Disable phase bias when preferredPhase is empty/none
	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	nameWhere, nameArgs := buildAssetNameWhere(assetNameKey)
	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	nameClause := ""
	if nameWhere != "" {
		nameClause = " AND " + nameWhere
	}
	statusClause := ""
	if statusWhere != "" {
		statusClause = " AND " + statusWhere
	}

	orderClause := buildOrderClause("x", orderKey, direction)

	// NOTE: no LIMIT/OFFSET here â€“ we sort the entire result set first.
	q := fmt.Sprintf(`
WITH latest_rows AS (
	SELECT
		project,
		root,
		group_1,
		relation,
		phase,
		work_status,
		approval_status,
		submitted_at_utc,
		modified_at_utc,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation, phase
			ORDER BY modified_at_utc DESC
		) AS rn
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0
),
filtered AS (
	SELECT *
	FROM latest_rows
	WHERE rn = 1
	%s
	%s
),
ranked AS (
	SELECT
		*,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation
			ORDER BY
				CASE
					WHEN ? = 1 THEN 0
					WHEN phase = ? THEN 0 ELSE 1
				END,
				modified_at_utc DESC
		) AS rk
	FROM filtered
)
SELECT
	x.root,
	x.project,
	x.group_1,
	x.relation,
	x.phase,
	x.submitted_at_utc
FROM ranked AS x
WHERE x.rk = 1
ORDER BY %s;
`, nameClause, statusClause, orderClause)

	args := []any{
		project, root,
	}
	args = append(args, nameArgs...)
	args = append(args, statusArgs...)
	args = append(args, phaseGuard, preferredPhase)

	// Fetch ALL sorted keys
	var allRows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&allRows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}

	// Apply pagination in Go so sorting is global
	if offset >= len(allRows) {
		return []LatestSubmissionRow{}, nil
	}
	end := offset + limit
	if end > len(allRows) {
		end = len(allRows)
	}
	return allRows[offset:end], nil
}
