// ---------- Dynamic Listing Function (name + status aware) ----------
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string, // e.g. "mdl" or "none"
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) ([]LatestSubmissionRow, error) {

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// phaseGuard controls whether phase preference is active
	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	// Filters
	nameWhere, nameArgs := buildAssetNameWhere(assetNameKey)
	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	nameConds := []string{}
	if nameWhere != "" {
		nameConds = append(nameConds, nameWhere)
	}
	whereExtra := ""
	if len(nameConds) > 0 {
		whereExtra = " AND " + strings.Join(nameConds, " AND ")
	}

	orderClause := buildOrderClause("x", orderKey, direction)

	statusFilterClause := ""
	if statusWhere != "" {
		statusFilterClause = fmt.Sprintf(`
AND EXISTS (
	SELECT 1 FROM t_review_info AS sub
	WHERE
		sub.project  = x.project
		AND sub.root = x.root
		AND sub.group_1 = x.group_1
		AND sub.relation = x.relation
		AND sub.deleted = 0
		AND %s
)`, statusWhere)
	}

	q := fmt.Sprintf(`
WITH ranked AS (
	SELECT
		project,
		root,
		group_1,
		relation,
		phase,
		work_status,
		approval_status,
		submitted_at_utc,
		modified_at_utc,
		ROW_NUMBER() OVER (
			PARTITION BY project, root, group_1, relation
			ORDER BY
				CASE
					WHEN ? = 1 THEN 0
					WHEN phase = ? THEN 0 ELSE 1
				END,
				modified_at_utc DESC
		) AS rn
	FROM t_review_info
	WHERE
		project = ? AND root = ? AND deleted = 0
		%s
)
SELECT
	x.root,
	x.project,
	x.group_1,
	x.relation,
	x.phase,
	x.submitted_at_utc
FROM ranked AS x
WHERE x.rn = 1
%s
ORDER BY %s
LIMIT ? OFFSET ?;
`, whereExtra, statusFilterClause, orderClause)

	args := []any{
		phaseGuard, preferredPhase, // CASE in window
		project, root,              // base WHERE
	}
	args = append(args, nameArgs...)   // name filter
	args = append(args, statusArgs...) // status filter
	args = append(args, limit, offset)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}
