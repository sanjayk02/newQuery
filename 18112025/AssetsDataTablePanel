import React, { FC, useEffect, useRef, useState, useMemo } from 'react';
import { RouteComponentProps } from 'react-router-dom';
import {
  Button,
  Container,
  Paper,
  styled,
} from '@material-ui/core';
import { ButtonProps } from '@material-ui/core/Button';
import { SelectProps } from '@material-ui/core/Select';
import { TablePaginationProps } from '@material-ui/core/TablePagination';
import { TextFieldProps } from '@material-ui/core/TextField';

import { useFetchAssetsPivot } from './hooks';
import { FilterProps as _FilterProps, PageProps, SortDir } from './types';
import AssetsDataTable from './AssetsDataTable';
import AssetTableFilter from './AssetDataTableFilter';
import AssetsDataTableFooter from './AssetsDataTableFooter';

import { useCurrentProject } from '../hooks';
import { useCurrentStudio } from '../../studio/hooks';
import { queryConfig } from '../../new-pipeline-setting/api';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Styling  (overflow fixes applied)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const StyledContainer = styled(Container)(({ theme }) => ({
  position: 'relative',
  display: 'flex',
  flexDirection: 'column',
  padding: 10,
  // allow horizontal scroll to appear from the inner wrapper
  overflowX: 'auto',
  '& > *': {
    display: 'flex',
    // IMPORTANT: do NOT clip overflow on children; let the inner div handle it
    overflow: 'visible',
    padding: theme.spacing(1),
    paddingBottom: 0,
  },
  '& > *:last-child': {
    paddingBottom: theme.spacing(1),
  },
}));

const StyledPaper = styled(Paper)({
  width: '100%',
  display: 'flex',
  flexDirection: 'column',
  // was 'hidden' â€” changed to 'visible' so the inner scroll container works
  overflow: 'visible',
});

const StyledContentDiv = styled('div')(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  display: 'flex',
  flexDirection: 'column',
  width: '100%',
  // ensure no clipping here either
  overflow: 'visible',
}));

const StyledTableDiv = styled('div')({
  paddingBottom: 8,
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Initial state
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const initPageProps: PageProps = { page: 0, rowsPerPage: 15 };
const initFilterProps: _FilterProps = {
  assetNameKey: '',
  applovalStatues: [],
  workStatues: [],
  selectPhasePriority: '',
  selectApprovalStatus: '',
  selectWorkStatus: '',
  onPhasePriorityChange: undefined,
  onApprovalStatusChange: undefined,
  onWorkStatusChange: undefined,
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Column metadata (ids must match table columns)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const COLUMN_META: { id: string; label: string }[] = [
  { id: 'thumbnail', label: 'Thumbnail' },
  { id: 'group_1_name', label: 'Name' },

  { id: 'mdl_work_status', label: 'MDL WORK' },
  { id: 'mdl_approval_status', label: 'MDL APPR' },
  { id: 'mdl_submitted_at', label: 'MDL Submitted At' },

  { id: 'rig_work_status', label: 'RIG WORK' },
  { id: 'rig_approval_status', label: 'RIG APPR' },
  { id: 'rig_submitted_at', label: 'RIG Submitted At' },

  { id: 'bld_work_status', label: 'BLD WORK' },
  { id: 'bld_approval_status', label: 'BLD APPR' },
  { id: 'bld_submitted_at', label: 'BLD Submitted At' },

  { id: 'dsn_work_status', label: 'DSN WORK' },
  { id: 'dsn_approval_status', label: 'DSN APPR' },
  { id: 'dsn_submitted_at', label: 'DSN Submitted At' },

  { id: 'ldv_work_status', label: 'LDV WORK' },
  { id: 'ldv_approval_status', label: 'LDV APPR' },
  { id: 'ldv_submitted_at', label: 'LDV Submitted At' },

  { id: 'relation', label: 'Relation' },
];

// Always-visible columns
const FIXED_VISIBLE = new Set<string>(['thumbnail', 'group_1_name']);

// Settings keys
const PIPE_KEY = '/ppiTracker/assets/hideColumns';
const lsKeyForProject = (projectKeyName?: string) => {
  return `ppi:assets:hideColumns:${projectKeyName || 'unknown'}`;
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Component
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const AssetsDataTablePanel: FC<RouteComponentProps> = () => {
  const [pageProps, setPageProps] = useState<PageProps>(initPageProps);
  const [filterProps, setFilterProps] = useState<_FilterProps>(initFilterProps);

  // Server-side sorting (drives fetch)
  const [sortKey, setSortKey] = useState<string>('group_1');
  const [sortDir, setSortDir] = useState<SortDir>('asc');
  const [phasePriority, setPhasePriority] = useState<string>('none'); // mdl|rig|bld|dsn|ldv|none

  // UI sort (instant arrow feedback; DEBOUNCE REMOVED)
  const [uiSortKey, setUiSortKey] = useState<string>('group_1');
  const [uiSortDir, setUiSortDir] = useState<SortDir>('asc');

  // Debounce ref is now unused but kept for history
  const commitTimerRef = useRef<number | null>(null);

  // Column visibility
  const [hiddenColumns, setHiddenColumns] = useState<Set<string>>(new Set());

  const { currentProject } = useCurrentProject();
  const { currentStudio } = useCurrentStudio();
  const [timeZone, setTimeZone] = useState<string | undefined>();

  /* Resolve UI key -> server sort + phase */
  const resolveServerSort = (key: string): { sort: string; phase: string } => {
    // Fixed keys: map directly
    if (key === 'group_1') return { sort: 'group_1', phase: 'none' };
    if (key === 'relation') return { sort: 'relation', phase: 'none' };

    // Phase-specific keys: map to the specific column ID for correct backend resolution
    const m = key.match(/^(mdl|rig|bld|dsn|ldv)_(work|appr|submitted)$/i);
    if (!m) return { sort: 'group_1', phase: 'none' };

    const phase = m[1].toLowerCase();
    const field = m[2].toLowerCase();

    if (field === 'submitted') return { sort: `${phase}_submitted`, phase };
    if (field === 'appr') return { sort: `${phase}_appr`, phase };
    return { sort: `${phase}_work`, phase };
  };

  /* Persist hidden columns (localStorage mirror) */
  const persistHiddenColumnsLocal = (next: Set<string>) => {
    const key = lsKeyForProject(
      currentProject && currentProject.key_name ? currentProject.key_name : undefined,
    );
    try {
      localStorage.setItem(key, JSON.stringify(Array.from(next)));
    } catch (e) {
      console.error('localStorage save failed', e);
    }
  };

  /** Save to PipelineSetting (explicit â€œSaveâ€ from drawer) */
  const saveHiddenColumnsToPipelineSetting = async (cols: Set<string>) => {
    try {
      if (!currentProject || !currentProject.key_name) return;
      await (queryConfig as any)(
        'project',
        currentProject.key_name,
        PIPE_KEY,
        JSON.stringify(Array.from(cols)),
      );
    } catch (e) {
      console.warn('PipelineSetting save failed; using local only', e);
    }
  };

  // Wrapper used by toggle/showAll/hideAll to keep local mirror up-to-date
  const persistHiddenColumns = (next: Set<string>) => {
    persistHiddenColumnsLocal(next);
  };

  // Pre-normalised filter arrays (to reuse in multiple places)
  const approvalArray =
    ((filterProps as any).approvalStatuses || filterProps.applovalStatues || []) as string[];
  const workArray =
    ((filterProps as any).workStatuses || filterProps.workStatues || []) as string[];

  // Decide which phase to send to backend:
  // If any filter is active, keep phase='none' (no bias). Otherwise allow phasePriority.
  const effectivePhase = useMemo(() => {
    const nameFilterActive = !!(filterProps.assetNameKey || '').trim();
    const approvalSelected = approvalArray.length > 0;
    const workSelected = workArray.length > 0;

    const isFilterActive = nameFilterActive || approvalSelected || workSelected;
    if (isFilterActive) return 'none';

    if (phasePriority && phasePriority !== 'none') return phasePriority;
    return 'none';
  }, [
    phasePriority,
    filterProps.assetNameKey,
    approvalArray,
    workArray,
  ]);

  // Detect if ANY filters are active (name / approval / work)
  const filtersActive = useMemo(() => {
    const nameActive = !!(filterProps.assetNameKey || '').trim();
    return nameActive || approvalArray.length > 0 || workArray.length > 0;
  }, [filterProps.assetNameKey, approvalArray, workArray]);

  // When filters are active, fetch a large page once and paginate on the client
  const backendPage = filtersActive ? 0 : pageProps.page;
  const backendRowsPerPage = filtersActive ? 5000 : pageProps.rowsPerPage;

  /* Fetch data */
  const { assets, total } = useFetchAssetsPivot(
    currentProject,
    backendPage,
    backendRowsPerPage,
    sortKey,
    sortDir,
    effectivePhase,
    filterProps.assetNameKey,
    approvalArray,
    workArray,
  );

  // ğŸ” Client-side row filter + sort so that changing filters or sort actually
  // affects what you see even when backend uses phase=none.
  const filteredAssets = useMemo(() => {
    if (!assets) return [];

    const nameFilter = (filterProps.assetNameKey || '').trim().toLowerCase();
    const approvalFilters = approvalArray.map((s) => s.toLowerCase());
    const workFilters = workArray.map((s) => s.toLowerCase());

    const phases = ['mdl', 'rig', 'bld', 'dsn', 'ldv'] as const;

    const compareDates = (a: any, b: any, dir: SortDir) => {
      const isAsc = dir === 'asc';

      const aNull = !a || a === '-';
      const bNull = !b || b === '-';

      // NULL / empty handling â€“ ALWAYS last
      if (aNull && bNull) return 0;
      if (aNull) return 1; // a goes after b (ASC or DESC)
      if (bNull) return -1; // b goes after a

      const ta = new Date(a as any).getTime();
      const tb = new Date(b as any).getTime();

      if (ta === tb) return 0;

      if (isAsc) {
        return ta < tb ? -1 : 1;
      } else {
        return ta > tb ? -1 : 1;
      }
    };

    const compareStrings = (a: any, b: any, dir: SortDir) => {
      const isAsc = dir === 'asc';

      const aa = (a || '').toString().trim();
      const bb = (b || '').toString().trim();

      const aEmpty = aa === '' || aa === '-';
      const bEmpty = bb === '' || bb === '-';

      // EMPTY handling â€“ ALWAYS last
      if (aEmpty && bEmpty) return 0;
      if (aEmpty) return 1; // a after b
      if (bEmpty) return -1; // b after a

      const la = aa.toLowerCase();
      const lb = bb.toLowerCase();

      if (la === lb) return 0;

      if (isAsc) {
        return la < lb ? -1 : 1;
      } else {
        return la > lb ? -1 : 1;
      }
    };

    const comparator = (a: any, b: any): number => {
      if (!uiSortKey || uiSortDir === 'none') return 0;

      if (uiSortKey === 'group_1') {
        return compareStrings(a.group_1, b.group_1, uiSortDir);
      }
      if (uiSortKey === 'relation') {
        return compareStrings(a.relation, b.relation, uiSortDir);
      }

      const m = uiSortKey.match(/^(mdl|rig|bld|dsn|ldv)_(work|appr|submitted)$/i);
      if (m) {
        const phase = m[1].toLowerCase();
        const field = m[2].toLowerCase();

        if (field === 'submitted') {
          const key = `${phase}_submitted_at_utc`; // or _submitted_at if thatâ€™s your field
          return compareDates(a[key], b[key], uiSortDir);
        }

        const key =
          field === 'appr'
            ? `${phase}_approval_status`
            : `${phase}_work_status`;

        return compareStrings(a[key], b[key], uiSortDir);
      }

      return 0;
    };

    // --- filter first ---
    const base = assets.filter((asset: any) => {
      // 1) Asset Name filter (group_1)
      if (nameFilter) {
        const name = (asset.group_1 || '').toString().toLowerCase();
        if (!name.includes(nameFilter)) return false;
      }

      // 2) Phase-locked matching (for client view)
      const phase =
        effectivePhase && effectivePhase !== 'none'
          ? effectivePhase.toLowerCase()
          : null;

      const matchesPhase = (p: string) => {
        if (approvalFilters.length > 0) {
          const rawAppr = (asset[`${p}_approval_status`] || '')
            .toString()
            .toLowerCase();
          if (!approvalFilters.includes(rawAppr)) return false;
        }
        if (workFilters.length > 0) {
          const rawWork = (asset[`${p}_work_status`] || '')
            .toString()
            .toLowerCase();
          if (!workFilters.includes(rawWork)) return false;
        }
        return true;
      };

      // No filters at all â†’ keep row
      if (!nameFilter && approvalFilters.length === 0 && workFilters.length === 0) {
        return true;
      }

      // If a specific phase is active (e.g. "rig"), only that phase decides.
      if (phase) {
        return matchesPhase(phase);
      }

      // Otherwise, keep the row if ANY phase matches.
      return phases.some((p) => matchesPhase(p));
    });

    // --- then sort according to current UI sort key/dir ---
    base.sort(comparator);
    return base;
  }, [
    assets,
    effectivePhase,
    uiSortKey,
    uiSortDir,
    filterProps.assetNameKey,
    approvalArray,
    workArray,
  ]);

  // Client-side pagination when filters are active
  const pagedAssets = useMemo(() => {
    if (!filtersActive) return filteredAssets;

    const start = pageProps.page * pageProps.rowsPerPage;
    const end = start + pageProps.rowsPerPage;
    return filteredAssets.slice(start, end);
  }, [filtersActive, filteredAssets, pageProps.page, pageProps.rowsPerPage]);

  // Total count for footer:
  // - With filters: all filtered rows (client-side pagination)
  // - Without filters: backend total (server-side pagination)
  const effectiveCount = filtersActive ? filteredAssets.length : total;

  /* Studio timezone */
  useEffect(() => {
    if (currentStudio == null) return;
    const controller = new AbortController();
    (async () => {
      try {
        const res: string | null = await queryConfig(
          'studio',
          currentStudio.key_name,
          'timezone',
        ).catch((e: any) => {
          if (e && e.name === 'AbortError') return null;
          throw e;
        });
        if (res != null) setTimeZone(res);
      } catch (e) {
        console.error(e);
        setTimeZone(undefined);
      }
    })();
    return () => controller.abort();
  }, [currentStudio]);

  /* Load hidden columns: PipelineSetting -> localStorage fallback */
  useEffect(() => {
    let aborted = false;
    (async () => {
      if (!currentProject) return;
      try {
        const val = await queryConfig('project', currentProject.key_name, PIPE_KEY);
        if (aborted) return;

        let arr: string[] | null = null;
        if (Array.isArray(val)) arr = val as string[];
        else if (typeof val === 'string' && val.trim() !== '') {
          try {
            arr = JSON.parse(val);
          } catch {
            arr = val.split(',').map((s) => s.trim());
          }
        }

        if (!arr) {
          try {
            const raw = localStorage.getItem(lsKeyForProject(currentProject.key_name));
            if (raw) arr = JSON.parse(raw);
          } catch {
            /* ignore */
          }
        }

        const sanitized = (arr || []).filter((id) => !FIXED_VISIBLE.has(id));
        setHiddenColumns(new Set(sanitized));
      } catch (e) {
        console.error('Load hideColumns failed; falling back to localStorage', e);
        try {
          const raw = localStorage.getItem(lsKeyForProject(currentProject.key_name));
          const arr: string[] = raw ? JSON.parse(raw) : [];
          const sanitized = arr.filter((id) => !FIXED_VISIBLE.has(id));
          setHiddenColumns(new Set(sanitized));
        } catch {
          setHiddenColumns(new Set());
        }
      }
    })();
    return () => {
      aborted = true;
    };
  }, [currentProject]);

  /* Cleanup pending debounce on unmount */
  useEffect(() => {
    return () => {
      if (commitTimerRef.current != null) {
        window.clearTimeout(commitTimerRef.current);
        commitTimerRef.current = null;
      }
    };
  }, []);

  /* Pagination */
  const handleRowsPerPageChange: TablePaginationProps['onChangeRowsPerPage'] = (event) => {
    setPageProps({ page: 0, rowsPerPage: parseInt(event.target.value, 10) });
  };
  const handlePageChange: TablePaginationProps['onChangePage'] = (_event, newPage) => {
    setPageProps((p) => ({ ...p, page: newPage }));
  };

  /* Immediate sort commit (Replaced 2s debounce) */
  const handleSortChange = (newUiKey: string) => {
    const { sort: newServerSortKey, phase } = resolveServerSort(newUiKey);

    // Determine the next direction: Flip only if clicking the currently active server key.
    const nextServerDir: SortDir =
      sortKey === newServerSortKey ? (sortDir === 'asc' ? 'desc' : 'asc') : 'asc';

    // 1. Update the server state immediately. This triggers useFetchAssetsPivot.
    setPhasePriority(phase);
    setSortKey(newServerSortKey);
    setSortDir(nextServerDir);

    // 2. Update the UI sort state immediately to reflect the arrow.
    setUiSortKey(newUiKey);
    setUiSortDir(nextServerDir);

    // Also reset page when sorting changes
    // setPageProps(p => ({ ...p, page: 0 }));
  };

  /* Filters */
  const handleFilterAssetNameChange: TextFieldProps['onChange'] = (event) => {
    setFilterProps((p) => ({ ...p, assetNameKey: event.target.value }));
    setPageProps((p) => ({ ...p, page: 0 }));
  };
  const handleApprovalStatusesChange: SelectProps['onChange'] = (
    event: React.ChangeEvent<{ value: unknown }>,
  ) => {
    setFilterProps((p) => ({ ...p, applovalStatues: event.target.value as string[] }));
    setPageProps((p) => ({ ...p, page: 0 }));
  };
  const handleWorkStatusesChange: SelectProps['onChange'] = (
    event: React.ChangeEvent<{ value: unknown }>,
  ) => {
    setFilterProps((p) => ({ ...p, workStatues: event.target.value as string[] }));
    setPageProps((p) => ({ ...p, page: 0 }));
  };
  const handleApprovalStatusesChipDelete = (name: string) => {
    setFilterProps((p) => ({
      ...p,
      applovalStatues: p.applovalStatues.filter((v) => v !== name),
    }));
    setPageProps((p) => ({ ...p, page: 0 }));
  };
  const handleWorkStatusesChipDelete = (name: string) => {
    setFilterProps((p) => ({
      ...p,
      workStatues: p.workStatues.filter((v) => v !== name),
    }));
    setPageProps((p) => ({ ...p, page: 0 }));
  };
  const handleFilterResetClick: ButtonProps['onClick'] = () => {
    setFilterProps(initFilterProps);
    setPageProps((p) => ({ ...p, page: 0 }));
  };

  /* Column actions for Drawer */
  const toggleColumn = (id: string) => {
    if (FIXED_VISIBLE.has(id)) return;
    setHiddenColumns((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      persistHiddenColumns(next);
      return next;
    });
  };

  const showAll = () => {
    const next = new Set<string>();
    setHiddenColumns(next);
    persistHiddenColumns(next);
  };

  const hideAllNonFixed = () => {
    const next = new Set<string>(
      COLUMN_META.map((c) => c.id).filter((id) => !FIXED_VISIBLE.has(id)),
    );
    setHiddenColumns(next);
    persistHiddenColumns(next);
  };

  // Explicit save (invoked from drawer)
  const handleSaveColumns = async () => {
    await saveHiddenColumnsToPipelineSetting(hiddenColumns);
  };

  /* Date/Time format */
  const dateTimeFormat = new Intl.DateTimeFormat(undefined, {
    timeZone,
    dateStyle: 'medium',
    timeStyle: 'medium',
  });

  /* Footer */
  const tableFooter = (
    <AssetsDataTableFooter
      count={effectiveCount}
      page={pageProps.page}
      rowsPerPage={pageProps.rowsPerPage}
      onChangePage={handlePageChange}
      onChangeRowsPerPage={handleRowsPerPageChange}
    />
  );

  /* Drawer badge count (visible columns among togglable ones) */
  const visibleCount = useMemo(() => {
    const togglable = COLUMN_META.map((c) => c.id).filter((id) => !FIXED_VISIBLE.has(id));
    let c = 0;
    togglable.forEach((id) => {
      if (!hiddenColumns.has(id)) c += 1;
    });
    return c;
  }, [hiddenColumns]);

  /* Render */
  return (
    <StyledContainer maxWidth="xl">
      {/* Filter bar with Reset + COLUMNS (COLUMNS opens Drawer inside AssetTableFilter) */}
      <AssetTableFilter
        filterAssetName={filterProps.assetNameKey}
        selectApprovalStatuses={
          (filterProps as any).approvalStatuses || filterProps.applovalStatues
        }
        selectWorkStatuses={
          (filterProps as any).workStatuses || filterProps.workStatues
        }
        onAssetNameChange={handleFilterAssetNameChange}
        onApprovalStatusesChange={handleApprovalStatusesChange}
        onWorkStatusesChange={handleWorkStatusesChange}
        onApprovalStatusChipDelete={handleApprovalStatusesChipDelete}
        onWorkStatusChipDelete={handleWorkStatusesChipDelete}
        onResetClick={handleFilterResetClick}
        /* Drawer-based column visibility */
        hiddenColumns={hiddenColumns}
        onHiddenColumnsChange={setHiddenColumns}
        onToggleColumn={toggleColumn}
        onShowAll={showAll}
        onHideAll={hideAllNonFixed}
        visibleCount={visibleCount}
        onSaveColumns={handleSaveColumns}
      />

      {/* Table inside horizontal scroll container */}
      <StyledTableDiv>
        <StyledPaper>
          <StyledContentDiv>
            <div
              style={{
                // The actual scroll container
                overflowX: 'auto',
                overflowY: 'hidden',
                width: '100%',
                paddingBottom: 4,
              }}
            >
              <AssetsDataTable
                project={currentProject}
                assets={pagedAssets}
                tableFooter={tableFooter}
                dateTimeFormat={dateTimeFormat}
                onSortChange={handleSortChange}
                currentSortKey={uiSortKey}
                currentSortDir={uiSortDir}
                hiddenColumns={hiddenColumns}
                // Pass filter props to table (optional)
                assetNameKey={filterProps.assetNameKey}
                approvalStatuses={filterProps.applovalStatues}
                workStatuses={filterProps.workStatues}
              />
            </div>
          </StyledContentDiv>
        </StyledPaper>
      </StyledTableDiv>
    </StyledContainer>
  );
};

export default AssetsDataTablePanel;
