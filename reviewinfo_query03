// AssetRow matches the final SELECT columns of your query
type AssetRow struct {
	Root     string `gorm:"column:root" json:"root"`
	Project  string `gorm:"column:project" json:"project"`
	Group1   string `gorm:"column:group_1" json:"group_1"`
	Relation string `gorm:"column:relation" json:"relation"`
}

// ListLatestAssetReviewInfoForAssets runs your original CTE query
// but adds dynamic sort (sortField:sortDir) + LIMIT/OFFSET.
func (r *ReviewInfo) ListLatestAssetReviewInfoForAssets(
	ctx context.Context,
	db *gorm.DB,
	project, root, relation string,
	limit, offset int,
	sortField, sortDir string,
) ([]AssetRow, error) {

	// ✅ Safe whitelist to prevent SQL injection
	allowedSorts := map[string]bool{
		"submitted_at_utc": true,
		"modified_at_utc":  true,
		"group_1":          true,
		"phase":            true,
	}
	if !allowedSorts[sortField] {
		sortField = "submitted_at_utc"
	}
	if strings.ToUpper(sortDir) != "DESC" {
		sortDir = "ASC"
	}

	// ✅ Build dynamic ORDER BY for the inner CTE
	sql := fmt.Sprintf(`
WITH ordered AS (
    SELECT *,
           ROW_NUMBER() OVER (
               ORDER BY %s %s
           ) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = ? AND root = ? AND relation = ? AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT root, project, group_1, phase, relation,
                   work_status, submitted_at_utc, modified_at_utc, executed_computer
            FROM t_review_info
            WHERE project = ? AND root = ? AND relation = ? AND deleted = 0
        ) AS b
          ON a.project = b.project
         AND a.root = b.root
         AND a.group_1 = b.group_1
         AND a.relation = b.relation
         AND a.phase = b.phase
         AND a.modified_at_utc = b.modified_at_utc
    ) AS k
),
offset_ordered AS (
    SELECT c.*,
           CASE WHEN c.phase = 'mdl' THEN c._order ELSE 100000 + c._order END AS __order
    FROM ordered c
),
ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
               PARTITION BY b.root, b.project, b.group_1, b.relation
               ORDER BY CASE WHEN b.phase = 'mdl' THEN 0 ELSE 1 END
           ) AS _rank
    FROM offset_ordered b
)
SELECT root, project, group_1, relation
FROM (
    SELECT *
    FROM ranked
    WHERE _rank = 1
) AS t
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, sortField, sortDir)

	// ✅ Arguments for placeholders
	args := []any{
		project, root, relation,
		project, root, relation,
		limit, offset,
	}

	var rows []AssetRow
	if err := db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestAssetReviewInfoForAssets: %w", err)
	}
	return rows, nil
}


// ----------------------------

// GET /api/latest/review-submissions/:project?sort=submitted_at_utc:asc&limit=15&offset=0&root=assets&relation=com
router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
	project := strings.TrimSpace(c.Param("project"))
	if project == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "project is required"})
		return
	}

	// pagination + filters
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "15"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
	root := c.DefaultQuery("root", "assets")
	relation := c.DefaultQuery("relation", "com")

	// --- sort parsing (supports "field:dir" and shorthand "-field") ---
	sortParam := c.DefaultQuery("sort", "submitted_at_utc:asc")
	sortField := sortParam
	sortDir := "ASC"

	if strings.Contains(sortParam, ":") {
		parts := strings.Split(sortParam, ":")
		sortField = parts[0]
		if len(parts) > 1 && strings.EqualFold(parts[1], "desc") {
			sortDir = "DESC"
		}
	}
	if strings.HasPrefix(sortField, "-") {
		sortField = strings.TrimPrefix(sortField, "-")
		sortDir = "DESC"
	}

	// whitelist allowed sort fields to prevent SQL injection
	switch sortField {
	case "submitted_at_utc", "modified_at_utc", "group_1", "phase":
		// ok
	default:
		sortField = "submitted_at_utc"
	}

	log.Printf("✅ latest review submissions: project=%s root=%s relation=%s sort=%s %s limit=%d offset=%d",
		project, root, relation, sortField, sortDir, limit, offset)

	// call repo (updated signature with sortField/sortDir)
	rows, err := reviewInfoRepository.ListLatestAssetReviewInfoForAssets(
		c.Request.Context(),
		gormDB,
		project,
		root,
		relation,
		limit,
		offset,
		sortField,
		sortDir,
	)
	if err != nil {
		log.Printf("❌ DB error: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.IndentedJSON(http.StatusOK, rows)
})

And make sure your repository function signature matches (i.e., it accepts sortField, sortDir and uses them in the ROW_NUMBER() OVER (ORDER BY ...) of your CTE), like we wrote earlier.

Quick tests:

/api/latest/review-submissions/potoodev?sort=submitted_at_utc:desc

/api/latest/review-submissions/potoodev?sort=-group_1

/api/latest/review-submissions/potoodev?sort=group_1:asc&limit=10&offset=0

If you want multi-column sorting next (e.g., sort=submitted_at_utc:desc,group_1:asc), say the word and I’ll extend both the handler and SQL safely.


