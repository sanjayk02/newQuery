// reviewinfo/reviewinfo.go

// ... keep your imports and ReviewInfo struct as-is ...

// SQL with 4 placeholders: WHERE(t1), WHERE(b), FINAL WHERE (outer), ORDER BY
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT project, root, group_1, relation, phase,
           MAX(modified_at_utc) AS modified_at_utc
    FROM t_review_info AS t1
    WHERE %s
    GROUP BY project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT b.root, b.project, b.group_1, b.phase, b.relation,
           b.work_status, b.submitted_at_utc, b.modified_at_utc, b.executed_computer
    FROM max_modified a
    JOIN t_review_info b
      ON a.project=b.project AND a.root=b.root AND a.group_1=b.group_1
     AND a.relation=b.relation AND a.phase=b.phase
     AND a.modified_at_utc=b.modified_at_utc
    WHERE %s
),
ordered AS (
    SELECT t1.*, ROW_NUMBER() OVER (ORDER BY t1.group_1 ASC, t1.relation ASC) AS _order
    FROM latest_reviews t1
),
offset_ordered AS (
    SELECT c.*, CASE WHEN c.phase='rel' THEN c._order ELSE 100000 + c._order END AS __order
    FROM ordered c
),
ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
             PARTITION BY b.root, b.project, b.group_1, b.relation
             ORDER BY CASE WHEN b.phase='rel' THEN 0 ELSE 1 END,
                      b.submitted_at_utc DESC,
                      b.modified_at_utc  DESC
           ) AS _rank
    FROM offset_ordered b
)
SELECT
    root              AS root,
    project           AS project,
    group_1           AS group_1,
    relation          AS relation,
    phase             AS phase,
    work_status       AS work_status,
    submitted_at_utc  AS submitted_at_utc,
    modified_at_utc   AS modified_at_utc,
    executed_computer AS executed_computer,
    __order
FROM ( SELECT * FROM ranked WHERE _rank = 1 ) AS t
%s
%s
LIMIT ? OFFSET ?;
`

func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	rootParam string,
	phaseParam string,
	preferPhase bool,   // <- NEW: prefer instead of filter
	limit, offset int,
	sortParam string,
) ([]ReviewInfo, error) {

	// Base filters inside the CTEs
	base := "project = ? AND deleted = 0"
	if rootParam != "" {
		base += " AND root = ?"
	}
	// Only add phase filter inside CTEs when we're in FILTER mode
	if phaseParam != "" && !preferPhase {
		base += " AND phase = ?"
	}

	// Alias filters
	filterT1 := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(
		base, "project", "t1.project"), "root", "t1.root"), "phase", "t1.phase")
	filterT1 = strings.ReplaceAll(filterT1, "deleted", "t1.deleted")

	filterB := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(
		base, "project", "b.project"), "root", "b.root"), "phase", "b.phase")
	filterB = strings.ReplaceAll(filterB, "deleted", "b.deleted")

	// Final WHERE (outer) â€” apply only in FILTER mode
	finalWhere := ""
	if phaseParam != "" && !preferPhase {
		finalWhere = "WHERE t.phase = ?"
	}

	// ORDER BY whitelist
	allowed := map[string]string{
		"group_1":           "t.group_1",
		"relation":          "t.relation",
		"phase":             "t.phase",
		"work":              "t.work_status",
		"work_status":       "t.work_status",
		"submitted":         "t.submitted_at_utc",
		"submitted_at_utc":  "t.submitted_at_utc",
		"modified":          "t.modified_at_utc",
		"modified_at_utc":   "t.modified_at_utc",
		"executed_computer": "t.executed_computer",
		"__order":           "t.__order",
	}

	// Default order (stable)
	orderBy := "ORDER BY t.__order ASC, t.group_1 ASC, t.relation ASC"

	// Prefer mode: put selected phase first, then continue with chosen sort
	phaseBooster := ""
	if phaseParam != "" && preferPhase {
		// MySQL allows parameters in CASE expressions
		phaseBooster = "CASE WHEN t.phase = ? THEN 0 ELSE 1 END, "
	}

	if sortParam != "" {
		dir := "ASC"
		field := sortParam
		if strings.HasPrefix(field, "-") {
			dir = "DESC"
			field = strings.TrimPrefix(field, "-")
		}
		if col, ok := allowed[field]; ok {
			orderBy = fmt.Sprintf("ORDER BY %s%s %s, t.group_1 ASC, t.relation ASC", phaseBooster, col, dir)
		} else if phaseBooster != "" {
			// Unknown sort field but still honor the phaseBooster
			orderBy = "ORDER BY " + phaseBooster + " t.group_1 ASC, t.relation ASC"
		}
	} else if phaseBooster != "" {
		orderBy = "ORDER BY " + phaseBooster + " t.group_1 ASC, t.relation ASC"
	}

	// Final SQL
	sql := fmt.Sprintf(complexReviewInfoQuery, filterT1, filterB, finalWhere, orderBy)

	// Params: appear twice for t1/b; maybe 1 for final WHERE; maybe 1 for phaseBooster; then LIMIT/OFFSET
	build := func() []interface{} {
		ps := []interface{}{project}
		if rootParam != "" {
			ps = append(ps, rootParam)
		}
		if phaseParam != "" && !preferPhase {
			ps = append(ps, phaseParam)
		}
		return ps
	}
	params := append([]interface{}{}, build()...) // t1
	params = append(params, build()...)           // b

	// Final WHERE param (filter mode)
	if phaseParam != "" && !preferPhase {
		params = append(params, phaseParam)
	}
	// Phase booster param (prefer mode)
	if phaseParam != "" && preferPhase {
		params = append(params, phaseParam)
	}

	params = append(params, limit, offset)

	var out []ReviewInfo
	if err := db.WithContext(ctx).Raw(sql, params...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}




// main.go (route)

// truthy helper
func isTruthy(s string) bool {
	switch strings.ToLower(strings.TrimSpace(s)) {
	case "1", "true", "yes", "y", "on":
		return true
	default:
		return false
	}
}

router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
	project := strings.TrimSpace(c.Param("project"))
	if project == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
		return
	}

	rootParam := c.Query("root")
	phaseParam := c.Query("phase")

	// prefer mode if any of these flags indicate it
	preferPhase := isTruthy(c.Query("phasePrefer")) ||
		isTruthy(c.Query("prefer")) ||
		strings.EqualFold(c.Query("mode"), "prefer")

	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	if limit <= 0 { limit = 50 }
	if limit > 500 { limit = 500 }
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
	if offset < 0 { offset = 0 }

	sortParam := canonicalizeSort(
		c.Query("sort"),
		c.DefaultQuery("dir", ""),
		c.DefaultQuery("desc", ""),
	)

	out, err := repo.ListLatestSubmissionsWithSort(
		c.Request.Context(),
		gormDB,
		project,
		rootParam,
		phaseParam,
		preferPhase, // <- pass prefer flag
		limit,
		offset,
		sortParam,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "internal database error", "detail": err.Error()})
		return
	}

	c.IndentedJSON(http.StatusOK, gin.H{
		"project":     project,
		"root":        rootParam,
		"phase":       phaseParam,
		"phasePrefer": preferPhase,
		"limit":       limit,
		"offset":      offset,
		"sort":        sortParam,
		"count":       len(out),
		"data":        out,
		"ts":          time.Now().UTC().Format(time.RFC3339),
	})
})


GET /api/latest/review-submissions/potoodev?root=assets&phase=mdl&phasePrefer=true&sort=submitted&dir=desc

