// ListLatestAssetReviewInfoForAssets returns one latest row per (project, root, group_1, relation)
// and (in one DB round-trip) also returns the total via COUNT(*) OVER().
//
// Sorting rules:
// - Default: phaseBias="group_1" â†’ plain name ordering (group_1, relation).
// - If phaseBias in {"mdl","rig","bld","dsn","ldv"}:
//     1) assets whose chosen phase row exists are pulled to the front (via __order).
//     2) within that, secondary sort by that row's work_status (ASC/DESC).
//     3) finally by group_1, relation (stable tie-breakers).
//
// sortOrder: "ASC" or "DESC" (anything else falls back to "ASC").
func (r *ReviewInfo) ListLatestAssetReviewInfoForAssets(
	db *gorm.DB,
	params *entity.AssetListParams, // Project + paging helpers
	phaseBias string,               // "", "group_1" (default) or one of: mdl, rig, bld, dsn, ldv
	sortOrder string,               // "ASC" or "DESC"
) ([]*entity.ReviewInfo, int, error) {

	// Normalize inputs
	validPhase := map[string]bool{"mdl": true, "rig": true, "bld": true, "dsn": true, "ldv": true}
	if !validPhase[phaseBias] {
		phaseBias = "group_1"
	}
	dir := "ASC"
	if s := strings.ToUpper(sortOrder); s == "DESC" {
		dir = "DESC"
	}

	perPage := params.GetPerPage()
	offset := perPage * (params.GetPage() - 1)

	// Build the ORDER BY with a safe, whitelisted direction.
	// When phaseBias="group_1", the work_status secondary sort is ignored (the CASE yields NULL).
	orderSQL := fmt.Sprintf(`
ORDER BY
  __order ASC,
  CASE WHEN ? = 'group_1' THEN NULL ELSE base.work_status END %s,
  base.group_1 ASC,
  base.relation ASC
LIMIT ? OFFSET ?`, dir)

	// Single-query rows+total using COUNT(*) OVER ()
	const pageAndTotalSQLPrefix = `
WITH ordered AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY group_1 ASC, relation ASC) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = ? AND root = 'assets' AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT *
            FROM t_review_info
            WHERE project = ? AND root = 'assets' AND deleted = 0
        ) AS b
          ON a.project = b.project
         AND a.root    = b.root
         AND a.group_1 = b.group_1
         AND a.relation= b.relation
         AND a.phase   = b.phase
         AND a.modified_at_utc = b.modified_at_utc
    ) AS k
),
offset_ordered AS (
    SELECT c.*,
           CASE
             WHEN ? = 'group_1' THEN c._order           -- no phase bias; keep name order
             WHEN c.phase = ?    THEN c._order           -- chosen phase first
             ELSE 100000 + c._order
           END AS __order
    FROM ordered c
),
ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
             PARTITION BY b.root, b.project, b.group_1, b.relation
             ORDER BY CASE
                       WHEN ? = 'group_1' THEN 0
                       WHEN b.phase = ?    THEN 0
                       ELSE 1
                     END
           ) AS _rank
    FROM offset_ordered b
),
base AS (
    SELECT *
    FROM ranked
    WHERE _rank = 1
)
SELECT base.*,
       COUNT(*) OVER () AS total_count
FROM base
`

	pageAndTotalSQL := pageAndTotalSQLPrefix + orderSQL

	// Scan rows and total in one go
	type rowWithTotal struct {
		model.ReviewInfo
		TotalCount int64 `gorm:"column:total_count"`
	}
	var rows []*rowWithTotal
	if err := db.Raw(
		pageAndTotalSQL,
		// filters (ordered CTE)
		params.Project, params.Project,
		// bias params (offset_ordered)
		phaseBias, phaseBias,
		// bias params (ranked)
		phaseBias, phaseBias,
		// secondary status sort CASE (orderSQL) + paging
		phaseBias, perPage, offset,
	).Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	// Derive total; if page empty, do a tiny fallback count to keep UI correct.
	total := 0
	if len(rows) > 0 {
		total = int(rows[0].TotalCount)
	} else {
		// Reuse the same CTE shape; count only the base set
		const fallbackCount = `
WITH ordered AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY group_1 ASC, relation ASC) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = ? AND root = 'assets' AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT *
            FROM t_review_info
            WHERE project = ? AND root = 'assets' AND deleted = 0
        ) AS b
          ON a.project = b.project
         AND a.root    = b.root
         AND a.group_1 = b.group_1
         AND a.relation= b.relation
         AND a.phase   = b.phase
         AND a.modified_at_utc = b.modified_at_utc
    ) AS k
),
offset_ordered AS (
    SELECT c.*,
           CASE
             WHEN ? = 'group_1' THEN c._order
             WHEN c.phase = ?    THEN c._order
             ELSE 100000 + c._order
           END AS __order
    FROM ordered c
),
ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
             PARTITION BY b.root, b.project, b.group_1, b.relation
             ORDER BY CASE
                       WHEN ? = 'group_1' THEN 0
                       WHEN b.phase = ?    THEN 0
                       ELSE 1
                     END
           ) AS _rank
    FROM offset_ordered b
)
SELECT COUNT(*) AS total_count
FROM (
  SELECT *
  FROM ranked
  WHERE _rank = 1
) AS base;`
		var t int64
		if err := db.Raw(
			fallbackCount,
			params.Project, params.Project,
			phaseBias, phaseBias,
			phaseBias, phaseBias,
		).Scan(&t).Error; err != nil {
			return nil, 0, err
		}
		total = int(t)
	}

	// Map to entities (your standard pattern)
	out := make([]*entity.ReviewInfo, len(rows))
	for i, r := range rows {
		out[i] = r.ReviewInfo.Entity(false)
	}
	return out, total, nil
}
