/* ──────────────────────────────────────────────────────────────────────────
    Module Name:
        reviewInfo/reviewInfo.go

    Module Description:
        Repository for managing review information in the database.
    Details:
    - Implements CRUD operations for review information.
    - Supports listing assets and their review information.
    - Provides functions for counting and listing latest submissions with dynamic filtering and sorting.

    Update and Modification History:
    * - 29-10-2025 - SanjayK PSI - Implemented dynamic filtering and sorting for latest submissions.
    * - 17-11-2025 - SanjayK PSI - Added phase-aware status filtering and sorting.
    * - 22-11-2025 - SanjayK PSI - Fixed bugs related to phase-specific filtering and sorting.
    * - 16-01-2026 - SanjayK PSI - Added asset pivot listing with grouped view  and sorting.
    * - 27-01-2026 - Optimized all query methods for better performance
    * - 27-01-2026 - Removed JSON_UNQUOTE(JSON_EXTRACT()) from JOIN conditions

    Functions:
    * - List: Lists review information based on provided parameters.
    * - Get: Retrieves a specific review information record.
    * - Create: Creates a new review information record.
    * - Update: Updates an existing review information record.
    * - Delete: Marks a review information record as deleted.
    * - ListAssets: Lists unique assets based on review information.
    * - ListShotReviewInfos: Lists review information for a specific shot.
    * - ListAssetReviewInfos: Lists review information for a specific asset.
    * - buildPhaseAwareStatusWhere: Constructs a WHERE clause for phase-aware status filtering.
    * - buildOrderClause: Constructs an ORDER BY clause based on sorting parameters.
    * - ListAssetsPivot: Lists pivoted assets with filtering and sorting options (OPTIMIZED VERSION).
    * - CountLatestSubmissions: Counts latest submissions with dynamic filtering (OPTIMIZED VERSION).
    * - ListLatestSubmissions: Lists latest submissions with dynamic filtering and sorting (OPTIMIZED VERSION).

    ────────────────────────────────────────────────────────────────────────── */

package repository

import (
    "context"
    "database/sql"
    "encoding/json"
    "errors"
    "fmt"
    "sort"
    "strings"
    "time"

    "github.com/PolygonPictures/central30-web/front/entity"
    "github.com/PolygonPictures/central30-web/front/repository/model"
    "gorm.io/gorm"
)

type ReviewInfo struct {
    db *gorm.DB
}

func NewReviewInfo(db *gorm.DB) (*ReviewInfo, error) {
    info := model.ReviewInfo{}

    //Specification change: https:jira.ppi.co.jp/browse/POTOO-2406
    migrator := db.Migrator()
    if migrator.HasTable(&info) && !migrator.HasColumn(&info, "take_path") {
        if err := migrator.RenameColumn(&info, "path", "take_path"); err != nil {
            return nil, err
        }
    }

    if err := db.AutoMigrate(&info); err != nil {
        return nil, err
    }

    return &ReviewInfo{
        db: db,
    }, nil
}

func (r *ReviewInfo) WithContext(ctx context.Context) *gorm.DB {
    return r.db.WithContext(ctx)
}

func (r *ReviewInfo) TransactionWithContext(
    ctx context.Context,
    fc func(tx *gorm.DB) error,
    opts ...*sql.TxOptions,
) error {
    db := r.WithContext(ctx)
    return db.Transaction(fc, opts...)
}

func (r *ReviewInfo) List(
    db *gorm.DB,
    params *entity.ListReviewInfoParams,
) ([]*entity.ReviewInfo, int, error) {
    stmt := db
    for i, g := range params.Group {
        stmt = stmt.Where(fmt.Sprintf("group_%d = ?", i+1), g)
    }
    stmt = stmt.Where("`project` = ?", params.Project)
    if params.Studio != nil {
        stmt = stmt.Where("`studio` = ?", *params.Studio)
    }
    if params.TaskID != nil {
        stmt = stmt.Where("`task_id` = ?", *params.TaskID)
    }
    if params.SubtaskID != nil {
        stmt = stmt.Where("`subtask_id` = ?", *params.SubtaskID)
    }
    if params.Root != nil {
        stmt = stmt.Where("`root` = ?", *params.Root)
    }
    for i, g := range params.Group {
        stmt = stmt.Where(fmt.Sprintf("`groups`->\"$[%d]\" = ?", i), g)
    }
    if params.Relation != nil {
        stmt = stmt.Where("relation IN (?)", params.Relation)
    }
    if params.Phase != nil {
        stmt = stmt.Where("phase IN (?)", params.Phase)
    }
    if params.Component != nil {
        stmt = stmt.Where("`component` = ?", *params.Component)
    }
    if params.Take != nil {
        stmt = stmt.Where("`take` = ?", *params.Take)
    }

    order := "`id` desc"
    if params.OrderBy != nil {
        order = *params.OrderBy
    }
    showDeleted := false
    if params.ModifiedSince != nil {
        stmt = stmt.Where("`modified_at_utc` >= ?", *params.ModifiedSince)
        order = "`modified_at_utc` asc"
        showDeleted = true
    } else {
        stmt.Where("`deleted` = ?", 0)
    }

    var total int64
    var m model.ReviewInfo
    if err := stmt.Model(&m).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    var models []*model.ReviewInfo
    perPage := params.GetPerPage()
    offset := perPage * (params.GetPage() - 1)
    if err := stmt.Order(
        order,
    ).Limit(perPage).Offset(offset).Find(&models).Error; err != nil {
        return nil, 0, err
    }

    var entities []*entity.ReviewInfo
    for _, m := range models {
        entities = append(entities, m.Entity(showDeleted))
    }
    return entities, int(total), nil
}

func (r *ReviewInfo) Get(
    db *gorm.DB,
    params *entity.GetReviewParams,
) (*entity.ReviewInfo, error) {
    var m model.ReviewInfo
    if err := db.Where(
        "`deleted` = ?", 0,
    ).Where(
        "`project` = ?", params.Project,
    ).Where(
        "`id` = ?", params.ID,
    ).Take(&m).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, entity.ErrRecordNotFound
        }
        return nil, err
    }
    return m.Entity(false), nil
}

func (r *ReviewInfo) Create(
    tx *gorm.DB,
    params *entity.CreateReviewInfoParams,
) (*entity.ReviewInfo, error) {
    m := model.NewReviewInfo(params)
    if err := tx.Create(m).Error; err != nil {
        return nil, err
    }
    return m.Entity(false), nil
}

func (r *ReviewInfo) Update(
    tx *gorm.DB,
    params *entity.UpdateReviewInfoParams,
) (*entity.ReviewInfo, error) {
    now := time.Now().UTC()
    modifiedBy := ""
    if params.ModifiedBy != nil {
        modifiedBy = *params.ModifiedBy
    }
    var m model.ReviewInfo
    if err := tx.Where(
        "`deleted` = ?", 0,
    ).Where(
        "`project` = ?", params.Project,
    ).Where(
        "`id` = ?", params.ID,
    ).Take(&m).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, entity.ErrRecordNotFound
        }
        return nil, err
    }
    var modified = false
    if params.ApprovalStatus != nil {
        m.ApprovalStatus = *params.ApprovalStatus
        m.ApprovalStatusUpdatedAtUtc = now
        modified = true
    }
    if params.ApprovalStatusUpdatedUser != nil {
        m.ApprovalStatusUpdatedUser = *params.ApprovalStatusUpdatedUser
        m.ApprovalStatusUpdatedAtUtc = now
        modified = true
    }
    if params.WorkStatus != nil {
        m.WorkStatus = *params.WorkStatus
        m.WorkStatusUpdatedAtUtc = now
        modified = true
    }
    if params.WorkStatusUpdatedUser != nil {
        m.WorkStatusUpdatedUser = *params.WorkStatusUpdatedUser
        m.WorkStatusUpdatedAtUtc = now
        modified = true
    }
    if !modified {
        return nil, errors.New("no value is given to change")
    }
    m.ModifiedAtUTC = now
    m.ModifiedBy = modifiedBy
    return m.Entity(false), tx.Save(m).Error
}

func (r *ReviewInfo) Delete(
    tx *gorm.DB,
    params *entity.DeleteReviewInfoParams,
) error {
    now := time.Now().UTC()
    var modifiedBy string
    if params.ModifiedBy != nil {
        modifiedBy = *params.ModifiedBy
    }
    var m model.ReviewInfo
    if err := tx.Where(
        "`deleted` = ?", 0,
    ).Where(
        "`project` = ?", params.Project,
    ).Where(
        "`id` = ?", params.ID,
    ).Take(&m).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return entity.ErrRecordNotFound
        }
        return err
    }
    m.Deleted = m.ID
    m.ModifiedAtUTC = now
    m.ModifiedBy = modifiedBy
    return tx.Save(m).Error
}

func (r *ReviewInfo) ListAssets(
    db *gorm.DB,
    params *entity.AssetListParams,
) ([]*entity.Asset, int, error) {
    stmt := db.Model(
        &ReviewInfo{},
    ).Where(
        "deleted = ?", 0,
    ).Where(
        "project = ?", params.Project,
    ).Where(
        "root = ?", "assets",
    ).Group(
        "project",
    ).Group(
        "root",
    ).Group(
        "group_1",
    ).Group(
        "relation",
    )

    var total int64
    if err := stmt.Count(&total).Error; err != nil {
        return nil, 0, err
    }

    stmt = stmt.Order(
        "group_1",
    ).Order(
        "relation",
    )

    var reviews []*model.ReviewInfo
    perPage := params.GetPerPage()
    offset := perPage * (params.GetPage() - 1)
    if err := stmt.Select(
        "project", "root", "group_1", "relation",
    ).Limit(perPage).Offset(offset).Find(&reviews).Error; err != nil {
        return nil, 0, err
    }

    assets := make([]*entity.Asset, len(reviews))
    for i, review := range reviews {
        assets[i] = &entity.Asset{
            Name:     review.Group1,
            Relation: review.Relation,
        }
    }
    return assets, int(total), nil
}

func (r *ReviewInfo) ListAssetReviewInfos(
    db *gorm.DB,
    params *entity.AssetReviewInfoListParams,
) ([]*entity.ReviewInfo, error) {
    stmtA := db.Select(
        "project",
        "root",
        "group_1",
        "relation",
        "phase",
        "MAX(modified_at_utc) AS modified_at_utc",
    ).Model(
        &model.ReviewInfo{},
    ).Where(
        "project = ?", params.Project,
    ).Where(
        "root = ?", "assets",
    ).Where(
        "group_1 = ?", params.Asset,
    ).Where(
        "relation = ?", params.Relation,
    ).Where(
        "deleted = ?", 0,
    ).Group(
        "project",
    ).Group(
        "root",
    ).Group(
        "group_1",
    ).Group(
        "relation",
    ).Group(
        "phase",
    )

    stmtB := db.Select(
        "*",
    ).Model(
        &model.ReviewInfo{},
    ).Where(
        "project = ?", params.Project,
    ).Where(
        "root = ?", "assets",
    ).Where(
        "group_1 = ?", params.Asset,
    ).Where(
        "relation = ?", params.Relation,
    ).Where(
        "deleted = ?", 0,
    )

    stmt := db.Select(
        "b.*",
    ).Table(
        "(?) AS a", stmtA,
    ).Joins(
        "LEFT OUTER JOIN (?) AS b ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1 AND a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc", stmtB,
    )

    var reviews []*model.ReviewInfo
    if err := stmt.Scan(&reviews).Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, err
    }

    reviewInfos := make([]*entity.ReviewInfo, len(reviews))
    for i, review := range reviews {
        reviewInfos[i] = review.Entity(false)
    }
    return reviewInfos, nil
}

func (r *ReviewInfo) ListShotReviewInfos(
    db *gorm.DB,
    params *entity.ShotReviewInfoListParams,
) ([]*entity.ReviewInfo, error) {
    stmtA := db.Select(
        "project",
        "root",
        "group_1",
        "group_2",
        "group_3",
        "relation",
        "phase",
        "MAX(modified_at_utc) AS modified_at_utc",
    ).Model(
        &model.ReviewInfo{},
    ).Where(
        "project = ?", params.Project,
    ).Where(
        "root = ?", "shots",
    ).Where(
        "group_1 = ?", params.Groups[0],
    ).Where(
        "group_2 = ?", params.Groups[1],
    ).Where(
        "group_3 = ?", params.Groups[2],
    ).Where(
        "relation = ?", params.Relation,
    ).Where(
        "deleted = ?", 0,
    ).Group(
        "project",
    ).Group(
        "root",
    ).Group(
        "group_1",
    ).Group(
        "group_2",
    ).Group(
        "group_3",
    ).Group(
        "relation",
    ).Group(
        "phase",
    )

    stmtB := db.Select(
        "*",
    ).Model(
        &model.ReviewInfo{},
    ).Where(
        "project = ?", params.Project,
    ).Where(
        "root = ?", "shots",
    ).Where(
        "group_1 = ?", params.Groups[0],
    ).Where(
        "group_2 = ?", params.Groups[1],
    ).Where(
        "group_3 = ?", params.Groups[2],
    ).Where(
        "relation = ?", params.Relation,
    ).Where(
        "deleted = ?", 0,
    )

    stmt := db.Select(
        "b.*",
    ).Table(
        "(?) AS a", stmtA,
    ).Joins(
        "LEFT OUTER JOIN (?) AS b ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1 AND a.group_2 = b.group_2 AND a.group_3 = b.group_3 AND a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc", stmtB,
    )

    var reviews []*model.ReviewInfo
    if err := stmt.Scan(&reviews).Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, err
    }

    reviewInfos := make([]*entity.ReviewInfo, len(reviews))
    for i, review := range reviews {
        reviewInfos[i] = review.Entity(false)
    }
    return reviewInfos, nil
}

/* ──────────────────────────────────────────────────────────────────────────
    Assets and Latest Submission Rows
───────────────────────────────────────────────────────────────────────────
*/
// ---- Latest Submission row ----
type LatestSubmissionRow struct {
    Root           string     `json:"root"              gorm:"column:root"`
    Project        string     `json:"project"           gorm:"column:project"`
    Group1         string     `json:"group_1"           gorm:"column:group_1"`
    Relation       string     `json:"relation"          gorm:"column:relation"`
    Phase          string     `json:"phase"             gorm:"column:phase"`
    SubmittedAtUTC *time.Time `json:"submitted_at_utc"  gorm:"column:submitted_at_utc"`
}

// ---- Asset Pivot row ----
type AssetPivot struct {
    Root     string `json:"root"`
    Project  string `json:"project"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`

    // Grouping info
    LeafGroupName     string `json:"leaf_group_name"`
    GroupCategoryPath string `json:"group_category_path"`
    TopGroupNode      string `json:"top_group_node"`

    MDLWorkStatus     *string    `json:"mdl_work_status"`
    MDLApprovalStatus *string    `json:"mdl_approval_status"`
    MDLSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

    RIGWorkStatus     *string    `json:"rig_work_status"`
    RIGApprovalStatus *string    `json:"rig_approval_status"`
    RIGSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

    BLDWorkStatus     *string    `json:"bld_work_status"`
    BLDApprovalStatus *string    `json:"bld_approval_status"`
    BLDSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

    DSNWorkStatus     *string    `json:"dsn_work_status"`
    DSNApprovalStatus *string    `json:"dsn_approval_status"`
    DSNSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

    LDVWorkStatus     *string    `json:"ldv_work_status"`
    LDVApprovalStatus *string    `json:"ldv_approval_status"`
    LDVSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`
}

// ---- phaseRow for intermediate query ----
type phaseRow struct {
    Project        string     `gorm:"column:project"`
    Root           string     `gorm:"column:root"`
    Group1         string     `gorm:"column:group_1"`
    Relation       string     `gorm:"column:relation"`
    Phase          string     `gorm:"column:phase"`
    WorkStatus     *string    `gorm:"column:work_status"`
    ApprovalStatus *string    `gorm:"column:approval_status"`
    SubmittedAtUTC *time.Time `gorm:"column:submitted_at_utc"`

    LeafGroupName     string `gorm:"column:leaf_group_name"`
    GroupCategoryPath string `gorm:"column:group_category_path"`
    TopGroupNode      string `gorm:"column:top_group_node"`
}

// ---- Sort Direction ----
type SortDirection string

// SortDirection constants
const (
    SortASC  SortDirection = "ASC"
    SortDESC SortDirection = "DESC"
)

// ---- Grouped Asset Bucket ----
type GroupedAssetBucket struct {
    TopGroupNode string       `json:"top_group_node"` // camera / character / prop / ...
    ItemCount    int          `json:"item_count"`
    Items        []AssetPivot `json:"items"`
    TotalCount   *int         `json:"total_count"` // optional total count across pages

}

/*
──────────────────────────────────────────────────────────────────────────

    GroupAndSortByTopNode groups a slice of AssetPivot items by their TopGroupNode field,
    sorts the group headers alphabetically (A→Z, case-insensitive), and always places the
    "Unassigned" group last. Within each group, the items are sorted by their Group1 field
    in either ascending or descending order, as specified by the dir parameter.
    Returns a slice of GroupedAssetBucket, each containing a group header and its sorted items.

    Parameters:
    - rows: Slice of AssetPivot items to be grouped and sorted.
    - dir: SortDirection specifying ascending or descending order for items within each group.

    Returns:
    - []GroupedAssetBucket: Slice of grouped and sorted asset buckets.

───────────────────────────────────────────────────────────────────────────
*/
func GroupAndSortByTopNode(rows []AssetPivot, dir SortDirection) []GroupedAssetBucket {
    grouped := make(map[string][]AssetPivot)
    order := make([]string, 0)

    // group and collect TopGroupNode keys
    for _, row := range rows {
        key := strings.TrimSpace(row.TopGroupNode)
        if key == "" {
            key = "Unassigned" // represents NULL / no group
        }
        if _, exists := grouped[key]; !exists {
            grouped[key] = []AssetPivot{}
            order = append(order, key)
        }
        grouped[key] = append(grouped[key], row)
    }

    // Group header order:
    // - ALWAYS alphabetical A→Z
    // - "Unassigned" ALWAYS last (no more "unassignedFirst")
    isUnassigned := func(s string) bool {
        return strings.EqualFold(strings.TrimSpace(s), "unassigned")
    }

    sort.Slice(order, func(i, j int) bool {
        ai := strings.TrimSpace(order[i])
        aj := strings.TrimSpace(order[j])

        aui := isUnassigned(ai)
        auj := isUnassigned(aj)

        // Unassigned always last
        if aui && !auj {
            return false
        }
        if !aui && auj {
            return true
        }

        // Always A→Z (case-insensitive)
        return strings.ToLower(ai) < strings.ToLower(aj)
    })

    // sort children inside each group by Group1 using requested dir
    for _, key := range order {
        children := grouped[key]
        sort.SliceStable(children, func(i, j int) bool {
            gi := strings.ToLower(children[i].Group1)
            gj := strings.ToLower(children[j].Group1)

            if dir == SortDESC {
                return gi > gj
            }
            return gi < gj
        })
        grouped[key] = children
    }

    result := make([]GroupedAssetBucket, 0, len(order))
    for _, key := range order {
        result = append(result, GroupedAssetBucket{
            TopGroupNode: key,
            Items:        grouped[key],
        })
    }
    return result
}

/*
──────────────────────────────────────────────────────────────────────────

    buildPhaseAwareStatusWhere constructs a SQL WHERE clause segment that filters rows based on the provided
    approvalStatuses and workStatuses. It generates case-insensitive "IN" conditions for the columns
    "approval_status" and "work_status" if their respective status slices are non-empty.
    The function returns the WHERE clause string (prefixed with " AND ") and a slice of arguments
    corresponding to the status values, all converted to lowercase and trimmed of whitespace.
    If both status slices are empty, it returns an empty string and nil arguments.

───────────────────────────────────────────────────────────────────────────
*/
func buildPhaseAwareStatusWhere(_ string, approvalStatuses, workStatuses []string) (string, []any) {
    buildIn := func(col string, vals []string) (string, []any) {
        if len(vals) == 0 {
            return "", nil
        }
        ph := strings.Repeat("?,", len(vals))
        ph = ph[:len(ph)-1]

        args := make([]any, len(vals))
        for i, v := range vals {
            args[i] = strings.ToLower(strings.TrimSpace(v))
        }

        return fmt.Sprintf("LOWER(%s) IN (%s)", col, ph), args
    }

    clauses := []string{}
    args := []any{}

    if c, a := buildIn("approval_status", approvalStatuses); c != "" {
        clauses = append(clauses, "("+c+")")
        args = append(args, a...)
    }
    if c, a := buildIn("work_status", workStatuses); c != "" {
        clauses = append(clauses, "("+c+")")
        args = append(args, a...)
    }

    if len(clauses) == 0 {
        return "", nil
    }
    return " AND " + strings.Join(clauses, " AND "), args
}

/*
──────────────────────────────────────────────────────────────────────────

    buildOrderClause constructs an SQL ORDER BY clause string based on the provided
    alias, key, and direction. It supports various keys for sorting, including generic
    columns (e.g., submitted_at_utc, modified_at_utc, phase), name/relation combinations,
    phase-specific submitted dates, work status, and approval status. The direction
    (dir) is normalized to "ASC" or "DESC", defaulting to "ASC" if invalid. The alias
    is prepended to column names if provided. For unrecognized keys, a default ordering
    by group_1, relation, and submitted_at_utc is used. The function ensures proper
    handling of NULL values and alphabetical sorting where applicable.

    Parameters:

        alias string - Optional table alias to prefix column names.
        key   string - The column or logical key to sort by.
        dir   string - Sort direction ("ASC" or "DESC").

    Returns:

        string - The constructed SQL ORDER BY clause.

──────────────────────────────────────────────────────────────────────────
*/
func buildOrderClause(alias, key, dir string) string {
    dir = strings.ToUpper(strings.TrimSpace(dir))
    if dir != "ASC" && dir != "DESC" {
        dir = "ASC"
    }

    col := func(c string) string {
        if alias == "" {
            return c
        }
        return alias + "." + c
    }

    switch key {
    // Basic columns
    case "id", "root", "project", "group_1", "relation", "phase", "work_status", "approval_status":
        return col(key) + " " + dir
    
    // Date columns with NULL handling
    case "submitted_at_utc", "modified_at_utc", "created_at_utc":
        return fmt.Sprintf("(%s IS NULL) ASC, %s %s", col(key), col(key), dir)
    
    // Group columns with combined sorting
    case "group1_only":
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) ASC",
            col("group_1"), dir,
            col("relation"),
        )
    
    case "relation_only":
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) ASC",
            col("relation"), dir,
            col("group_1"),
        )
    
    case "group_rel_submitted":
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) %s, (%s IS NULL) ASC, %s %s",
            col("group_1"), dir,
            col("relation"), dir,
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )
    
    // Phase-specific columns with grouping
    case "mdl_submitted", "rig_submitted", "bld_submitted", "dsn_submitted", "ldv_submitted":
        phase := strings.Split(key, "_")[0]
        return fmt.Sprintf(
            "(%s_work_status IS NULL) ASC, LOWER(%s_work_status) %s, (%s_submitted_at_utc IS NULL) ASC, %s_submitted_at_utc %s",
            phase, phase, dir,
            phase, phase, dir,
        )
    
    // Work status columns
    case "mdl_work", "rig_work", "bld_work", "dsn_work", "ldv_work":
        phase := strings.Split(key, "_")[0]
        return fmt.Sprintf(
            "(%s_work_status IS NULL) ASC, LOWER(%s_work_status) %s, LOWER(%s) ASC",
            phase, phase, dir,
            col("group_1"),
        )
    
    // Approval status columns
    case "mdl_appr", "rig_appr", "bld_appr", "dsn_appr", "ldv_appr":
        phase := strings.Split(key, "_")[0]
        return fmt.Sprintf(
            "(%s_approval_status IS NULL) ASC, LOWER(%s_approval_status) %s, LOWER(%s) ASC",
            phase, phase, dir,
            col("group_1"),
        )
    
    // Grouping columns for group view
    case "top_group_node":
        return fmt.Sprintf(
            "(%s = '' OR %s IS NULL) ASC, LOWER(%s) %s, LOWER(%s) ASC",
            col("top_group_node"), col("top_group_node"),
            col("top_group_node"), dir,
            col("group_1"),
        )
    
    case "group_category_path":
        return fmt.Sprintf(
            "(%s = '' OR %s IS NULL) ASC, LOWER(%s) %s, LOWER(%s) ASC",
            col("group_category_path"), col("group_category_path"),
            col("group_category_path"), dir,
            col("group_1"),
        )
    
    // Default: comprehensive ordering
    default:
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) %s, (%s IS NULL) ASC, %s %s",
            col("group_1"), dir,
            col("relation"), dir,
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )
    }
}

/*
    ──────────────────────────────────────────────────────────────────────────
    CountLatestSubmissions returns the count of latest review submissions for a given project and asset root,
    optionally filtered by asset name prefix, approval statuses, and work statuses.
    The function ignores the preferredPhase parameter for filtering but keeps it for API compatibility.
    It queries the database for the latest (by modified_at_utc) review info per asset and relation,
    applying the specified filters, and returns the total count.
    Returns an error if the project is not specified or if the database query fails.

    Parameters:
    ctx              - Context for database operations.
    project          - Project identifier (required).
    root             - Asset root; defaults to "assets" if empty.
    assetNameKey     - Optional asset name prefix filter (case-insensitive).
    preferredPhase   - Phase parameter (ignored in filtering; kept for compatibility).
    approvalStatuses - List of approval statuses to filter by.
    workStatuses     - List of work statuses to filter by.

    Returns:
    int64 - Count of latest submissions matching the filters.
    error - Error if project is missing or database query fails.

──────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) CountLatestSubmissions(
    ctx context.Context,
    project, root, assetNameKey string,
    preferredPhase string,
    approvalStatuses []string,
    workStatuses []string,
) (int64, error) {
    if project == "" {
        return 0, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }

    db := r.db.WithContext(ctx)

    // Build WHERE conditions (NO JSON operations)
    whereConditions := []string{"project = ?", "root = ?", "deleted = 0"}
    args := []any{project, root}

    // Asset name filter
    if strings.TrimSpace(assetNameKey) != "" {
        whereConditions = append(whereConditions, "LOWER(group_1) LIKE ?")
        args = append(args, strings.ToLower(strings.TrimSpace(assetNameKey))+"%")
    }

    // Status filters
    if len(approvalStatuses) > 0 {
        placeholders := strings.Repeat("?,", len(approvalStatuses))
        placeholders = placeholders[:len(placeholders)-1]
        whereConditions = append(whereConditions, "LOWER(approval_status) IN ("+placeholders+")")
        for _, status := range approvalStatuses {
            args = append(args, strings.ToLower(strings.TrimSpace(status)))
        }
    }

    if len(workStatuses) > 0 {
        placeholders := strings.Repeat("?,", len(workStatuses))
        placeholders = placeholders[:len(placeholders)-1]
        whereConditions = append(whereConditions, "LOWER(work_status) IN ("+placeholders+")")
        for _, status := range workStatuses {
            args = append(args, strings.ToLower(strings.TrimSpace(status)))
        }
    }

    // Optimized query - NO JSON operations
    sql := `
SELECT COUNT(DISTINCT CONCAT(group_1, '|', relation))
FROM (
  SELECT 
    group_1,
    relation,
    ROW_NUMBER() OVER (
      PARTITION BY project, root, group_1, relation
      ORDER BY modified_at_utc DESC
    ) AS rn
  FROM t_review_info
  WHERE ` + strings.Join(whereConditions, " AND ") + `
) AS latest
WHERE rn = 1`

    var total int64
    if err := db.Raw(sql, args...).Scan(&total).Error; err != nil {
        return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
    }

    return total, nil
}

/*
    ──────────────────────────────────────────────────────────────────────────
    ListLatestSubmissions retrieves a list of the latest review submissions
    for a specified project and asset root, with dynamic filtering and sorting options.
    Parameters:
    - ctx: Context for database operations.
    - project: Project identifier (required).
    - root: Asset root; defaults to "assets" if empty.
    - preferredPhase: Phase to prioritize in sorting; if empty or "none", no bias is applied.
    - orderKey: Column or logical key to sort by (e.g., "submitted_at_utc", "group1_only").
    - direction: Sort direction ("ASC" or "DESC").
    - limit: Maximum number of results to return; defaults to 60 if <= 0.
    - offset: Number of results to skip; defaults to 0 if < 0.
    - assetNameKey: Optional asset name prefix filter (case-insensitive).
    - approvalStatuses: List of approval statuses to filter by.
    - workStatuses: List of work statuses to filter by.
    Returns:
    - []LatestSubmissionRow: Slice of latest submission rows matching the filters.
    - error: Error if project is missing or database query fails.

───────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) ListLatestSubmissions(
    ctx context.Context,
    project string,
    root string,
    preferredPhase string,
    orderKey string,
    direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
) ([]LatestSubmissionRow, error) {
    if project == "" {
        return nil, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }
    if limit <= 0 {
        limit = 60
    }
    if offset < 0 {
        offset = 0
    }

    db := r.db.WithContext(ctx)

    // Build WHERE conditions (NO JSON operations)
    whereConditions := []string{"project = ?", "root = ?", "deleted = 0"}
    args := []any{project, root}

    // Asset name filter
    if strings.TrimSpace(assetNameKey) != "" {
        whereConditions = append(whereConditions, "LOWER(group_1) LIKE ?")
        args = append(args, strings.ToLower(strings.TrimSpace(assetNameKey))+"%")
    }

    // Status filters
    if len(approvalStatuses) > 0 {
        placeholders := strings.Repeat("?,", len(approvalStatuses))
        placeholders = placeholders[:len(placeholders)-1]
        whereConditions = append(whereConditions, "LOWER(approval_status) IN ("+placeholders+")")
        for _, status := range approvalStatuses {
            args = append(args, strings.ToLower(strings.TrimSpace(status)))
        }
    }

    if len(workStatuses) > 0 {
        placeholders := strings.Repeat("?,", len(workStatuses))
        placeholders = placeholders[:len(placeholders)-1]
        whereConditions = append(whereConditions, "LOWER(work_status) IN ("+placeholders+")")
        for _, status := range workStatuses {
            args = append(args, strings.ToLower(strings.TrimSpace(status)))
        }
    }

    // Phase preference handling
    phaseOrder := "0" // default: no phase preference
    if preferredPhase != "" && !strings.EqualFold(preferredPhase, "none") {
        phaseOrder = fmt.Sprintf("CASE WHEN phase = '%s' THEN 0 ELSE 1 END", preferredPhase)
    }

    // Optimized query - NO JSON operations
    sql := `
WITH latest_submissions AS (
  SELECT 
    project,
    root,
    group_1,
    relation,
    phase,
    submitted_at_utc,
    modified_at_utc,
    ROW_NUMBER() OVER (
      PARTITION BY project, root, group_1, relation
      ORDER BY ` + phaseOrder + `, modified_at_utc DESC
    ) AS rn
  FROM t_review_info
  WHERE ` + strings.Join(whereConditions, " AND ") + `
)
SELECT
  root,
  project,
  group_1,
  relation,
  phase,
  submitted_at_utc
FROM latest_submissions
WHERE rn = 1
ORDER BY ` + buildOrderClause("", orderKey, direction) + `
LIMIT ? OFFSET ?`

    args = append(args, limit, offset)

    var rows []LatestSubmissionRow
    if err := db.Raw(sql, args...).Scan(&rows).Error; err != nil {
        return nil, fmt.Errorf("ListLatestSubmissions: %w", err)
    }

    return rows, nil
}

/*
──────────────────────────────────────────────────────────────────────────

    ListAssetsPivot retrieves a paginated list of AssetPivot rows for a specified project and asset root,
    optionally filtered by asset name prefix, preferred phase, approval statuses, and work statuses.
    This method avoids JSON_UNQUOTE(JSON_EXTRACT()) in JOIN conditions for better performance.

    Parameters:
    - ctx: Context for database operations.
    - project: Project identifier (required).
    - root: Asset root; defaults to "assets" if empty.
    - preferredPhase: Phase to prioritize in sorting.
    - orderKey: Column or logical key to sort by.
    - direction: Sort direction ("ASC" or "DESC").
    - limit: Maximum number of results to return.
    - offset: Number of results to skip.
    - assetNameKey: Optional asset name prefix filter.
    - approvalStatuses: List of approval statuses to filter by.
    - workStatuses: List of work statuses to filter by.
    - groupView: If true, returns grouped results by TopGroupNode.

    Returns:
    - interface{}: Either []AssetPivot or []GroupedAssetBucket based on groupView.
    - int64: Total count of assets matching the filters.
    - error: Error if project is missing or database query fails.

───────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) ListAssetsPivot(
    ctx context.Context,
    project, root, preferredPhase, orderKey, direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
    groupView bool,
) (interface{}, int64, error) {
    if project == "" {
        return nil, 0, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }

    // 1) Get total count for pagination
    total, err := r.CountLatestSubmissions(
        ctx,
        project,
        root,
        assetNameKey,
        preferredPhase,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return nil, 0, err
    }

    if total == 0 {
        if groupView {
            return []GroupedAssetBucket{}, 0, nil
        }
        return []AssetPivot{}, 0, nil
    }

    // 2) Get page keys using optimized method
    keys, err := r.ListLatestSubmissions(
        ctx,
        project,
        root,
        preferredPhase,
        orderKey,
        direction,
        limit,
        offset,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return nil, 0, err
    }

    if len(keys) == 0 {
        if groupView {
            return []GroupedAssetBucket{}, total, nil
        }
        return []AssetPivot{}, total, nil
    }

    // 3) OPTIMIZED: Fetch all data in two efficient queries (no JSON_UNQUOTE in JOINs)

    // Query 1: Get review data
    reviewQuery := `
WITH latest_phases AS (
  SELECT 
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.groups AS raw_groups,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS phase_rn
  FROM t_review_info ri
  WHERE ri.project = ? 
    AND ri.root = ? 
    AND ri.deleted = 0
    AND (ri.group_1, ri.relation) IN (`
    
    // Build IN clause for the keys
    var reviewParams []interface{}
    reviewParams = append(reviewParams, project, root)
    
    placeholders := make([]string, len(keys))
    keyToIndex := make(map[string]int)
    for i, k := range keys {
        placeholders[i] = "(?, ?)"
        reviewParams = append(reviewParams, k.Group1, k.Relation)
        keyToIndex[k.Group1+"|"+k.Relation] = i
    }
    
    reviewQuery += strings.Join(placeholders, ", ") + `)
)
SELECT 
  project,
  root,
  group_1,
  relation,
  phase,
  work_status,
  approval_status,
  submitted_at_utc,
  raw_groups
FROM latest_phases
WHERE phase_rn = 1;`

    type reviewRow struct {
        Project        string     `gorm:"column:project"`
        Root           string     `gorm:"column:root"`
        Group1         string     `gorm:"column:group_1"`
        Relation       string     `gorm:"column:relation"`
        Phase          string     `gorm:"column:phase"`
        WorkStatus     *string    `gorm:"column:work_status"`
        ApprovalStatus *string    `gorm:"column:approval_status"`
        SubmittedAtUTC *time.Time `gorm:"column:submitted_at_utc"`
        RawGroups      string     `gorm:"column:raw_groups"`
    }

    var reviewRows []reviewRow
    if err := r.db.WithContext(ctx).Raw(reviewQuery, reviewParams...).Scan(&reviewRows).Error; err != nil {
        return nil, 0, fmt.Errorf("ListAssetsPivot.reviewFetch: %w", err)
    }

    // Extract unique group paths for batch lookup
    uniqueGroupPaths := make(map[string]bool)
    groupPathMap := make(map[string]string) // raw_groups -> first group path
    
    for _, row := range reviewRows {
        // Parse JSON to get first group path (client-side, not in database query)
        firstGroup := extractFirstGroupFromJSON(row.RawGroups)
        if firstGroup != "" {
            uniqueGroupPaths[firstGroup] = true
            groupPathMap[row.RawGroups] = firstGroup
        }
    }

    // Query 2: Batch fetch group category data
    var groupCategoryRows []struct {
        Path     string `gorm:"column:path"`
        FullPath string `gorm:"column:full_path"`
        TopNode  string `gorm:"column:top_node"`
    }
    
    if len(uniqueGroupPaths) > 0 {
        // Build batch query for group categories
        groupPaths := make([]string, 0, len(uniqueGroupPaths))
        for path := range uniqueGroupPaths {
            groupPaths = append(groupPaths, path)
        }
        
        groupQuery := `
SELECT 
    gcg.path,
    CONCAT(gc.path, '/', gcg.path) as full_path,
    SUBSTRING_INDEX(gc.path, '/', 1) as top_node
FROM t_group_category gc
INNER JOIN t_group_category_group gcg ON gc.id = gcg.group_category_id
WHERE gcg.project = ?
    AND gcg.deleted = 0
    AND gc.deleted = 0
    AND gc.root = ?
    AND gcg.path IN (?`
        
        groupParams := []interface{}{project, root}
        queryPlaceholders := make([]string, len(groupPaths))
        for i := range groupPaths {
            queryPlaceholders[i] = "?"
        }
        
        groupQuery += strings.Join(queryPlaceholders, ", ") + ")"
        
        for _, path := range groupPaths {
            groupParams = append(groupParams, path)
        }
        
        if err := r.db.WithContext(ctx).Raw(groupQuery, groupParams...).Scan(&groupCategoryRows).Error; err != nil {
            return nil, 0, fmt.Errorf("ListAssetsPivot.groupFetch: %w", err)
        }
    }

    // Create lookup map for group categories
    groupCategoryMap := make(map[string]struct {
        Path     string
        FullPath string
        TopNode  string
    })
    for _, row := range groupCategoryRows {
        groupCategoryMap[row.Path] = struct {
            Path     string
            FullPath string
            TopNode  string
        }{
            Path:     row.Path,
            FullPath: row.FullPath,
            TopNode:  row.TopNode,
        }
    }

    // 4) Build pivot rows efficiently
    pivotMap := make(map[string]*AssetPivot, len(keys))
    orderedPivots := make([]*AssetPivot, len(keys))
    
    // Pre-create all pivot entries
    for i, k := range keys {
        key := k.Group1 + "|" + k.Relation
        pivot := &AssetPivot{
            Root:     k.Root,
            Project:  k.Project,
            Group1:   k.Group1,
            Relation: k.Relation,
        }
        pivotMap[key] = pivot
        orderedPivots[i] = pivot
    }

    // Process review rows and add group info
    for _, row := range reviewRows {
        key := row.Group1 + "|" + row.Relation
        if pivot, ok := pivotMap[key]; ok {
            // Set grouping info (only once per pivot)
            if pivot.LeafGroupName == "" {
                // Get first group from JSON (client-side)
                firstGroup := groupPathMap[row.RawGroups]
                if firstGroup != "" {
                    pivot.LeafGroupName = firstGroup
                    
                    // Look up group category info
                    if category, ok := groupCategoryMap[firstGroup]; ok {
                        pivot.GroupCategoryPath = category.FullPath
                        pivot.TopGroupNode = category.TopNode
                    }
                }
            }

            // Set phase-specific fields
            phase := strings.ToLower(row.Phase)
            switch phase {
            case "mdl":
                pivot.MDLWorkStatus = row.WorkStatus
                pivot.MDLApprovalStatus = row.ApprovalStatus
                pivot.MDLSubmittedAtUTC = row.SubmittedAtUTC
            case "rig":
                pivot.RIGWorkStatus = row.WorkStatus
                pivot.RIGApprovalStatus = row.ApprovalStatus
                pivot.RIGSubmittedAtUTC = row.SubmittedAtUTC
            case "bld":
                pivot.BLDWorkStatus = row.WorkStatus
                pivot.BLDApprovalStatus = row.ApprovalStatus
                pivot.BLDSubmittedAtUTC = row.SubmittedAtUTC
            case "dsn":
                pivot.DSNWorkStatus = row.WorkStatus
                pivot.DSNApprovalStatus = row.ApprovalStatus
                pivot.DSNSubmittedAtUTC = row.SubmittedAtUTC
            case "ldv":
                pivot.LDVWorkStatus = row.WorkStatus
                pivot.LDVApprovalStatus = row.ApprovalStatus
                pivot.LDVSubmittedAtUTC = row.SubmittedAtUTC
            }
        }
    }

    // Convert to slice maintaining order
    flatResult := make([]AssetPivot, len(orderedPivots))
    for i, pivot := range orderedPivots {
        flatResult[i] = *pivot
    }

    if groupView {
        // Apply group sorting
        sortDir := SortASC
        if strings.ToUpper(direction) == "DESC" {
            sortDir = SortDESC
        }
        
        groupedResult := GroupAndSortByTopNode(flatResult, sortDir)
        
        // Update counts in each group
        for i := range groupedResult {
            groupedResult[i].ItemCount = len(groupedResult[i].Items)
        }
        
        return groupedResult, total, nil
    }

    return flatResult, total, nil
}

/*
    ──────────────────────────────────────────────────────────────────────────
    CreateOptimizedIndexes creates recommended indexes for performance optimization.
    Call this method during application startup or migration.
───────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) CreateOptimizedIndexes(ctx context.Context) error {
    indexes := []string{
        // Critical indexes for review info queries
        `CREATE INDEX IF NOT EXISTS idx_review_info_project_root_deleted_modified 
         ON t_review_info(project, root, deleted, modified_at_utc)`,

        `CREATE INDEX IF NOT EXISTS idx_review_info_asset_lookup 
         ON t_review_info(project, root, group_1, relation, phase, modified_at_utc)`,

        `CREATE INDEX IF NOT EXISTS idx_review_info_status_filter 
         ON t_review_info(project, root, work_status, approval_status)`,

        // For group category joins
        `CREATE INDEX IF NOT EXISTS idx_group_category_root_deleted 
         ON t_group_category(root, deleted, id)`,

        `CREATE INDEX IF NOT EXISTS idx_group_category_group_lookup 
         ON t_group_category_group(project, deleted, path)`,

        // Optional: Generated column for JSON extraction (if needed)
        // `ALTER TABLE t_review_info 
        //  ADD COLUMN IF NOT EXISTS first_group VARCHAR(255) 
        //  GENERATED ALWAYS AS (JSON_UNQUOTE(JSON_EXTRACT(groups, '$[0]'))) STORED`,
        //  
        // `CREATE INDEX IF NOT EXISTS idx_first_group ON t_review_info(first_group)`,
    }

    for _, idx := range indexes {
        if err := r.db.WithContext(ctx).Exec(idx).Error; err != nil {
            // Log warning but continue with other indexes
            fmt.Printf("Warning: Failed to create index: %v\n", err)
        }
    }

    return nil
}

/*
    ──────────────────────────────────────────────────────────────────────────
    Helper: Extract first group from JSON (client-side)
───────────────────────────────────────────────────────────────────────────
*/
func extractFirstGroupFromJSON(groupsJSON string) string {
    if groupsJSON == "" || groupsJSON == "[]" {
        return ""
    }
    
    var groups []string
    if err := json.Unmarshal([]byte(groupsJSON), &groups); err != nil {
        return ""
    }
    
    if len(groups) > 0 {
        return groups[0]
    }
    
    return ""
}

/*
    ──────────────────────────────────────────────────────────────────────────
    GetQueryPerformanceStats returns performance statistics for the optimized queries.
    Useful for monitoring and debugging.
───────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) GetQueryPerformanceStats(ctx context.Context) (map[string]interface{}, error) {
    stats := make(map[string]interface{})
    
    // Get table sizes
    var reviewInfoCount, groupCategoryCount, groupCategoryGroupCount int64
    
    if err := r.db.WithContext(ctx).Model(&model.ReviewInfo{}).Where("deleted = 0").Count(&reviewInfoCount).Error; err != nil {
        return nil, err
    }
    
    if err := r.db.WithContext(ctx).Model(&model.GroupCategory{}).Where("deleted = 0").Count(&groupCategoryCount).Error; err != nil {
        return nil, err
    }
    
    if err := r.db.WithContext(ctx).Model(&model.GroupCategoryGroup{}).Where("deleted = 0").Count(&groupCategoryGroupCount).Error; err != nil {
        return nil, err
    }
    
    stats["review_info_count"] = reviewInfoCount
    stats["group_category_count"] = groupCategoryCount
    stats["group_category_group_count"] = groupCategoryGroupCount
    
    return stats, nil
}

// ---- Sorter Interface and Helper Functions ----

// SortOption represents a sorting configuration
type SortOption struct {
    Key       string `json:"key"`
    Direction string `json:"direction"` // "ASC" or "DESC"
}

// SortOptions represents multiple sorting criteria
type SortOptions []SortOption

// ParseSortOptions parses sort options from query parameters
func ParseSortOptions(sortParam string) SortOptions {
    if sortParam == "" {
        return nil
    }
    
    var options SortOptions
    sortPairs := strings.Split(sortParam, ",")
    
    for _, pair := range sortPairs {
        parts := strings.Split(strings.TrimSpace(pair), ":")
        if len(parts) == 2 {
            key := strings.TrimSpace(parts[0])
            dir := strings.TrimSpace(strings.ToUpper(parts[1]))
            
            if dir != "ASC" && dir != "DESC" {
                dir = "ASC"
            }
            
            options = append(options, SortOption{
                Key:       key,
                Direction: dir,
            })
        }
    }
    
    return options
}

// BuildMultiOrderClause builds a comprehensive ORDER BY clause from multiple sort options
func BuildMultiOrderClause(alias string, options SortOptions) string {
    if len(options) == 0 {
        // Default ordering
        return buildOrderClause(alias, "group_rel_submitted", "ASC")
    }
    
    var clauses []string
    for _, opt := range options {
        clause := buildOrderClause(alias, opt.Key, opt.Direction)
        clauses = append(clauses, clause)
    }
    
    return strings.Join(clauses, ", ")
}

// SortAssetsPivot sorts AssetPivot slices based on sort options
func SortAssetsPivot(assets []AssetPivot, options SortOptions, groupView bool) []AssetPivot {
    if len(options) == 0 || len(assets) == 0 {
        return assets
    }
    
    sort.Slice(assets, func(i, j int) bool {
        for _, opt := range options {
            result := compareAssetPivot(assets[i], assets[j], opt.Key, opt.Direction)
            if result != 0 {
                return result < 0
            }
        }
        return false
    })
    
    return assets
}

// compareAssetPivot compares two AssetPivot items based on a key and direction
func compareAssetPivot(a, b AssetPivot, key, direction string) int {
    var aVal, bVal string
    var aTime, bTime *time.Time
    
    // Helper function for string comparison
    compareStrings := func(s1, s2 string) int {
        s1Lower := strings.ToLower(s1)
        s2Lower := strings.ToLower(s2)
        
        if s1Lower < s2Lower {
            return -1
        } else if s1Lower > s2Lower {
            return 1
        }
        return 0
    }
    
    // Helper function for time comparison (handles nil)
    compareTimes := func(t1, t2 *time.Time) int {
        if t1 == nil && t2 == nil {
            return 0
        }
        if t1 == nil {
            return 1 // NULLs last
        }
        if t2 == nil {
            return -1
        }
        if t1.Before(*t2) {
            return -1
        } else if t1.After(*t2) {
            return 1
        }
        return 0
    }
    
    // Helper function for optional string comparison
    compareOptionalStrings := func(s1, s2 *string) int {
        if s1 == nil && s2 == nil {
            return 0
        }
        if s1 == nil {
            return 1 // NULLs last
        }
        if s2 == nil {
            return -1
        }
        return compareStrings(*s1, *s2)
    }
    
    // Get values based on key
    switch key {
    case "group_1":
        aVal, bVal = a.Group1, b.Group1
        result := compareStrings(aVal, bVal)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "relation":
        aVal, bVal = a.Relation, b.Relation
        result := compareStrings(aVal, bVal)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "top_group_node":
        aVal, bVal = a.TopGroupNode, b.TopGroupNode
        result := compareStrings(aVal, bVal)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "group_category_path":
        aVal, bVal = a.GroupCategoryPath, b.GroupCategoryPath
        result := compareStrings(aVal, bVal)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "mdl_submitted":
        aTime, bTime = a.MDLSubmittedAtUTC, b.MDLSubmittedAtUTC
        result := compareTimes(aTime, bTime)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "mdl_work":
        result := compareOptionalStrings(a.MDLWorkStatus, b.MDLWorkStatus)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "mdl_appr":
        result := compareOptionalStrings(a.MDLApprovalStatus, b.MDLApprovalStatus)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    // Add other phase-specific comparisons similarly...
    case "rig_submitted":
        aTime, bTime = a.RIGSubmittedAtUTC, b.RIGSubmittedAtUTC
        result := compareTimes(aTime, bTime)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "bld_submitted":
        aTime, bTime = a.BLDSubmittedAtUTC, b.BLDSubmittedAtUTC
        result := compareTimes(aTime, bTime)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "dsn_submitted":
        aTime, bTime = a.DSNSubmittedAtUTC, b.DSNSubmittedAtUTC
        result := compareTimes(aTime, bTime)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    case "ldv_submitted":
        aTime, bTime = a.LDVSubmittedAtUTC, b.LDVSubmittedAtUTC
        result := compareTimes(aTime, bTime)
        if direction == "DESC" {
            result = -result
        }
        return result
        
    default:
        // Default to group_1, relation
        result := compareStrings(a.Group1, b.Group1)
        if result == 0 {
            result = compareStrings(a.Relation, b.Relation)
        }
        if direction == "DESC" {
            result = -result
        }
        return result
    }
}
