// ====================================================================
// NEW SQL CONSTANTS FOR ListLatestAssetReviewInfoForAssets
// ====================================================================

const orderedCTE = `
WITH ordered AS (
    SELECT *, ROW_NUMBER() OVER (
        ORDER BY group_1 ASC, relation ASC
    ) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = @Project AND root = 'assets' AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT *
            FROM t_review_info
            WHERE project = @Project AND root = 'assets' AND deleted = 0
        ) AS b
        ON a.project = b.project
        AND a.root = b.root
        AND a.group_1 = b.group_1
        AND a.relation = b.relation
        AND a.phase = b.phase
        AND a.modified_at_utc = b.modified_at_utc
    ) AS k
)`

const offsetOrderedCTE = `
, offset_ordered AS (
    SELECT c.*,
    CASE
        WHEN c.phase = 'mdl' THEN c._order
        ELSE 100000 + c._order
    END AS __order
    FROM ordered c
)`

const rankedCTE = `
, ranked AS (
    SELECT b.*,
    ROW_NUMBER() OVER (
        PARTITION BY b.root, b.project, b.group_1, b.relation
        ORDER BY
        CASE WHEN b.phase = 'mdl' THEN 0 ELSE 1 END
    ) AS _rank
    FROM offset_ordered b
)`

const finalSelect = `
SELECT *
FROM (
    SELECT *
    FROM ranked
    WHERE _rank = 1
) AS t
`
// ========================================================================================
// One string with a single leading WITH and commas between CTEs
const baseSQL = orderedCTE + offsetOrderedCTE + rankedCTE + finalSelect

// allowedSort maps query "sort" values to safe SQL fragments.
func allowedSort(sort string) (string, bool) {
    // Add what you actually support
    whitelist := map[string]string{
        "group_1":            "group_1 ASC",
        "-group_1":           "group_1 DESC",
        "relation":           "relation ASC",
        "-relation":          "relation DESC",
        "phase":              "phase ASC",
        "-phase":             "phase DESC",
        "modified":           "modified_at_utc DESC",
        "-modified":          "modified_at_utc ASC",
        "submitted":          "submitted_at_utc DESC",
        "-submitted":         "submitted_at_utc ASC",
        "__order":            "__order ASC",   // internal default
        "-__order":           "__order DESC",
    }
    v, ok := whitelist[sort]
    return v, ok
}
// ========================================================================================

func (r *ReviewInfo) ListLatestAssetReviewInfoForAssets(
    db *gorm.DB,
    params *entity.AssetListParams,
) ([]*entity.ReviewInfo, int, error) {

    // Default ordering uses the phase-priority (__order) computed in the CTE.
    orderByClause := "ORDER BY __order ASC"

    if params.OrderBy != nil && *params.OrderBy != "" {
        if safe, ok := allowedSort(*params.OrderBy); ok {
            orderByClause = "ORDER BY " + safe
        } // else ignore unknown sort to keep things safe
    }

    // Final raw SQL
    rawSQL := fmt.Sprintf("%s %s LIMIT @Limit OFFSET @Offset", baseSQL, orderByClause)

    // ---- Total distinct assets (project, root, group_1, relation)
    // Use COUNT DISTINCT to avoid GROUP BY multi-row Count pitfalls.
    var total int64
    if err := db.
        Model(&model.ReviewInfo{}).
        Where("deleted = ?", 0).
        Where("project = ?", params.Project).
        Where("root = ?", "assets").
        Select("COUNT(DISTINCT CONCAT_WS('|', project, root, group_1, relation))").
        Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // ---- Pagination
    limit := params.GetPerPage()
    if limit <= 0 {
        limit = 25
    }
    page := params.GetPage()
    if page <= 0 {
        page = 1
    }
    offset := limit * (page - 1)

    // ---- Execute
    var models []*model.ReviewInfo
    if err := db.Raw(
        rawSQL,
        sql.Named("Project", params.Project),
        sql.Named("Limit", limit),
        sql.Named("Offset", offset),
    ).Scan(&models).Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, 0, err
    }

    // ---- Map
    entities := make([]*entity.ReviewInfo, 0, len(models))
    for _, m := range models {
        entities = append(entities, m.Entity(false))
    }
    return entities, int(total), nil
}

// ========================================================================================
// ListLatestSubmissionsWithSort returns the latest row per (project, root, group_1, relation, phase)
// by MAX(submitted_at_utc), then applies a safe dynamic ORDER BY.
func (r *ReviewInfo) ListLatestSubmissionsWithSort(
    ctx context.Context,
    db *gorm.DB,
    project string,
    limit int,
    offset int,
    sort string, // safe tokens like: submitted, -submitted, group_1, -group_1, etc.
    // If you want to lock to assets only, add a bool param e.g. onlyAssets bool
) ([]*entity.ReviewInfo, error) {

    if limit <= 0 {
        limit = 50
    }
    if offset < 0 {
        offset = 0
    }

    // (a) latest submitted_at_utc per group
    stmtA := db.WithContext(ctx).
        Select("project", "root", "group_1", "relation", "phase", "MAX(submitted_at_utc) AS submitted_at_utc").
        Model(&model.ReviewInfo{}).
        Where("project = ?", project).
        Where("deleted = ?", 0).
        // .Where("root = ?", "assets") // uncomment if this endpoint must be assets-only
        Group("project, root, group_1, relation, phase")

    // (b) full rows
    stmtB := db.WithContext(ctx).
        Select("*").
        Model(&model.ReviewInfo{}).
        Where("project = ?", project).
        Where("deleted = ?", 0)
        // .Where("root = ?", "assets") // match the filter you use in stmtA

    stmt := db.WithContext(ctx).
        Select("b.*").
        Table("(?) AS a", stmtA).
        Joins(`
            INNER JOIN (?) AS b
              ON a.project = b.project
             AND a.root = b.root
             AND a.group_1 = b.group_1
             AND a.relation = b.relation
             AND a.phase = b.phase
             AND a.submitted_at_utc = b.submitted_at_utc
        `, stmtB)

    order := "submitted_at_utc DESC"
    if sort != "" {
        if safe, ok := allowedSort(sort); ok {
            order = safe
        }
    }

    var models []*model.ReviewInfo
    if err := stmt.Order(order).Limit(limit).Offset(offset).Find(&models).Error; err != nil {
        return nil, err
    }

    entities := make([]*entity.ReviewInfo, 0, len(models))
    for _, m := range models {
        entities = append(entities, m.Entity(false))
    }
    return entities, nil
}
//========================================================================================

// In main.go (after you have gormDB and reviewInfoRepository ready)
apiRouter.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
    project := c.Param("project")

    // parse query params
    sort := c.Query("sort") // e.g., "submitted", "-group_1", etc.
    limitStr := c.DefaultQuery("limit", "50")
    offsetStr := c.DefaultQuery("offset", "0")

    limit, _ := strconv.Atoi(limitStr)
    offset, _ := strconv.Atoi(offsetStr)

    ctx := c.Request.Context()
    rows, err := reviewInfoRepository.ListLatestSubmissionsWithSort(ctx, gormDB, project, limit, offset, sort)
    if err != nil {
        c.String(http.StatusInternalServerError, "DB error: %v", err)
        return
    }

    // If you want a total count for pagination, add another count query similar to #3.

    c.JSON(http.StatusOK, rows)
})

GET /api/latest/review-submissions/:project
