package repository

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// AssetKey is the minimal row your current SELECT returns.
type AssetKey struct {
	Project  string `json:"project"  gorm:"column:project"`
	Root     string `json:"root"     gorm:"column:root"`
	Group1   string `json:"group_1"  gorm:"column:group_1"`
	Relation string `json:"relation" gorm:"column:relation"`
}

// ReviewInfoRepo provides queries over t_review_info.
type ReviewInfoRepo struct{}

// NewReviewInfo creates a new repo (kept as a value type so it's easy to pass around).
func NewReviewInfo() *ReviewInfoRepo { return &ReviewInfoRepo{} }

// Base SQL with dynamic ORDER BY driven by params (no pivot).
// Params binding order (critical!):
//   1:  project (for CTE a)
//   2:  project (for CTE b)
//   3:  sortPhase           -> phase_latest WHERE o.phase = ?
//   4:  sortField (ASC)     -> 'work' | 'appr' | 'submitted_at' | 'modified_at'
//   5:  sortField (ASC)
//   6:  sortField (ASC)
//   7:  sortField (ASC)
//   8:  sortDir   ('desc'?) -> controls DESC block on/off
//   9:  sortField (DESC)
//   10: sortField (DESC)
//   11: sortField (DESC)
//   12: sortField (DESC)
//   13: limit
//   14: offset
const listLatestAssetKeysDynamicSQL = `
WITH ordered AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (ORDER BY b.group_1 ASC) AS _order
  FROM (
    SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
    GROUP BY project, root, group_1, relation, phase
  ) a
  LEFT JOIN (
    SELECT root, project, group_1, phase, relation,
           work_status, approval_status, submitted_at_utc, modified_at_utc, executed_computer
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
  ) b
    ON a.project=b.project AND a.root=b.root AND a.group_1=b.group_1
   AND a.relation=b.relation AND a.phase=b.phase AND a.modified_at_utc=b.modified_at_utc
),
offset_ordered AS (
  SELECT c.*,
         CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
),
phase_latest AS (
  SELECT o.project, o.root, o.group_1, o.relation,
         o.work_status, o.approval_status, o.submitted_at_utc, o.modified_at_utc
  FROM ordered o
  WHERE o.phase = ?
),
winner AS (
  SELECT r.root, r.project, r.group_1, r.relation, r.__order
  FROM ranked r
  WHERE r._rank = 1
)
SELECT w.root, w.project, w.group_1, w.relation
FROM winner w
LEFT JOIN phase_latest pl
  ON pl.project=w.project AND pl.root=w.root
 AND pl.group_1=w.group_1 AND pl.relation=w.relation
ORDER BY
  w.__order ASC,
  -- ASC block
  CASE
    WHEN ?='work'         THEN pl.work_status
    WHEN ?='appr'         THEN pl.approval_status
    WHEN ?='submitted_at' THEN pl.submitted_at_utc
    WHEN ?='modified_at'  THEN pl.modified_at_utc
  END ASC,
  -- DESC block (enabled only when sort_dir='desc')
  CASE WHEN ?='desc' THEN
    CASE
      WHEN ?='work'         THEN pl.work_status
      WHEN ?='appr'         THEN pl.approval_status
      WHEN ?='submitted_at' THEN pl.submitted_at_utc
      WHEN ?='modified_at'  THEN pl.modified_at_utc
    END
  END DESC,
  w.group_1 ASC
LIMIT ? OFFSET ?;
`

// ListLatestAssetKeysDynamic returns the four-key rows with dynamic end-sort by phase/field/direction.
func (r *ReviewInfoRepo) ListLatestAssetKeysDynamic(
	ctx context.Context,
	db *gorm.DB,
	project string,
	sortPhase string, // mdl | rig | bld | dsn | ldv
	sortField string, // work | appr | submitted_at | modified_at
	sortDir string,   // asc | desc
	limit, offset int,
) ([]*AssetKey, error) {

	// --- Whitelists & defaults (safety) ---
	phaseOK := map[string]bool{"mdl": true, "rig": true, "bld": true, "dsn": true, "ldv": true}
	fieldOK := map[string]bool{"work": true, "appr": true, "submitted_at": true, "modified_at": true}

	sortPhase = strings.ToLower(sortPhase)
	if !phaseOK[sortPhase] {
		sortPhase = "mdl"
	}
	sortField = strings.ToLower(sortField)
	if !fieldOK[sortField] {
		sortField = "submitted_at"
	}
	sortDir = strings.ToLower(sortDir)
	if sortDir != "desc" {
		sortDir = "asc"
	}
	if limit <= 0 || limit > 500 {
		limit = 15
	}
	if offset < 0 {
		offset = 0
	}

	// Bind in the exact order required by the SQL above.
	args := []any{
		project, // a: project
		project, // b: project
		sortPhase,
		// ASC block 4×
		sortField, sortField, sortField, sortField,
		// DESC guard + 4×
		sortDir,
		sortField, sortField, sortField, sortField,
		limit, offset,
	}

	var out []*AssetKey
	if err := db.WithContext(ctx).Raw(listLatestAssetKeysDynamicSQL, args...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}
