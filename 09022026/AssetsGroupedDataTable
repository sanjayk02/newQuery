/* _________________________________________________________________________________
  
  Module Name:
  AssetsDataTable.tsx
  
  Module Description:
  React component that renders a data table displaying asset information for a project.
  
  Details:
  - Fetches and displays asset thumbnails.
  - Supports sorting by various asset attributes.
  - Allows hiding/showing of specific columns.
  - Compact mode for minimal column display.

  * Update and Modification History:
    * - 29-10-2025 - SanjayK PSI - Initial creation sorting pagination implementation.
    * - 07-11-2025 - SanjayK PSI - Column visibility toggling implementation.
    * - 20-11-2025 - SanjayK PSI - Fixed typo in filter property names handling.
    * - 24-11-2025 - SanjayK PSI - Added detailed doc comments for functions and types.
    * - [Current Date] - Added proper empty value handling in sorting
    * - 02-02-2026 - SanjayK PSI - Added component field to Asset type for better component tracking.
    * - 06-02-2026 - SanjayK PSI - Added take field to ReviewInfo type for enhanced review tracking.
    * - [Current Date] - Implemented vertical phase header structure
    
  Function:
    * - AssetsDataTable: Main component rendering the assets data table.
    * - RecordTableHead: Renders the table header with sortable columns.
    * - AssetRow: Renders individual rows for each asset.
    * - Styled components for consistent theming.
    * - MultIineTooltipTableCell: Table cell with multi-line tooltip support.
    * - Constants for asset phases, approval statuses, and work statuses.
    * - Column definitions for the data table.
    * - NON_FIXED_IDS: Array of column IDs excluding fixed columns.
    * - isOnlyFixedVisible: Utility to check if only fixed columns are visible.
    * - TooltipTableCellProps: Props for the MultiLineTooltipTableCell component.
    * - Status: Type defining display name and color for statuses.
    * - Columns: Configuration for the data table columns.
    * - ASSET_PHASES, APPROVAL_STATUS, WORK_STATUS: Mappings for phases and statuses.
    * - getPhaseData: Utility to extract phase-related data from an asset.
    * - isHidden: Utility to check if a column is hidden.
  * 
  ___________________________________________________________________________________ */
import React from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Tooltip,
  TableSortLabel,
  Box,
} from "@material-ui/core";
import {
  AssetRowProps,
  AssetsDataTableProps,
  Colors,
  Column,
  SortDir,
  Asset,
} from "./types";
import { useFetchAssetThumbnails } from "./hooks";

const ASSET_PHASES: { [key: string]: Colors } = {
  mdl: {
    lineColor: '#3295fd',
    backgroundColor: '#354d68',
  },
  rig: {
    lineColor: '#c061fd',
    backgroundColor: '#5e3568',
  },
  bld: {
    lineColor: '#fc2f8c',
    backgroundColor: '#5a0028',
  },
  dsn: {
    lineColor: '#98f2fb',
    backgroundColor: '#045660',
  },
  ldv: {
    lineColor: '#fe5cff',
    backgroundColor: '#683566',
  },
};

type Status = Readonly<{
  displayName: string,
  color: string,
}>;

const APPROVAL_STATUS: { [key: string]: Status } = {
  check: {
    displayName: 'Check',
    color: '#ca25ed',
  },
  clientReview: {
    displayName: 'Client Review',
    color: '#005fbd',
  },
  dirReview: {
    displayName: 'Dir Review',
    color: '#007fff',
  },
  epdReview: {
    displayName: 'EPD Review',
    color: '#4fa7ff',
  },
  clientOnHold: {
    displayName: 'Client On Hold',
    color: '#d69b00',
  },
  dirOnHold: {
    displayName: 'Dir On Hold',
    color: '#ffcc00',
  },
  epdOnHold: {
    displayName: 'EPD On Hold',
    color: '#ffdd55',
  },
  execRetake: {
    displayName: 'Exec Retake',
    color: '#a60000',
  },
  clientRetake: {
    displayName: 'Client Retake',
    color: '#c60000',
  },
  dirRetake: {
    displayName: 'Dir Retake',
    color: '#ff0000',
  },
  epdRetake: {
    displayName: 'EPD Retake',
    color: '#ff4f4f',
  },
  clientApproved: {
    displayName: 'Client Approved',
    color: '#1d7c39',
  },
  dirApproved: {
    displayName: 'Dir Approved',
    color: '#27ab4f',
  },
  epdApproved: {
    displayName: 'EPD Approved',
    color: '#5cda82',
  },
  other: {
    displayName: 'Other',
    color: '#9a9a9a',
  },
  omit: {
    displayName: 'Omit',
    color: '#646464',
  },
  approved: {
    displayName: 'Approved',
    color: '#32cd32',
  },
  review: {
    displayName: 'Review',
    color: '#ffa500',
  },
};

const WORK_STATUS: { [key: string]: Status } = {
  check: { displayName: "Check", color: "#e287f5" },
  cgsvOnHold: { displayName: "CGSV On Hold", color: "#ffdd55" },
  svOnHold: { displayName: "SV On Hold", color: "#ffe373" },
  leadOnHold: { displayName: "Lead On Hold", color: "#fff04f" },
  cgsvRetake: { displayName: "CGSV Retake", color: "#ff4f4f" },
  svRetake: { displayName: "SV Retake", color: "#ff8080" },
  leadRetake: { displayName: "Lead Retake", color: "#ffbbbb" },
  cgsvApproved: { displayName: "CGSV Approved", color: "#5cda82" },
  svApproved: { displayName: "SV Approved", color: "#83e29f" },
  leadApproved: { displayName: "Lead Approved", color: "#b9eec9" },
  svOther: { displayName: "SV Other", color: "#9a9a9a" },
  leadOther: { displayName: "Lead Other", color: "#dbdbdb" },
  review: { displayName: "Review", color: "#ffa500" },
  inProgress: { displayName: "In Progress", color: "#00bfff" },
  notStarted: { displayName: "Not Started", color: "#d3d3d3" },
  approved: { displayName: "Approved", color: "#32cd32" },
};

// Define the order of columns within each phase as per your image
const PHASE_COLUMN_ORDER = {
  mdl: ['mdl_submitted_at', 'mdl_work_status', 'mdl_approval_status', 'mdl_take'],
  rig: ['rig_submitted_at', 'rig_work_status', 'rig_approval_status', 'rig_take'],
  bld: ['bld_work_status', 'bld_approval_status', 'bld_submitted_at', 'bld_take'],
  dsn: ['dsn_work_status', 'dsn_approval_status', 'dsn_submitted_at', 'dsn_take'],
  ldv: ['ldv_work_status', 'ldv_approval_status', 'ldv_submitted_at', 'ldv_take'],
};

// Column definitions with proper labels
const columns: Column[] = [
  { id: "thumbnail", label: "Thumbnail" },
  { id: "group_1_name", label: "Name", sortable: true, sortKey: "group_1" },

  // MDL columns - ORDER MATTERS: SUBMITTED, WORK, APPR, TAKE
  { id: "mdl_submitted_at", label: "SUBMITTED", colors: ASSET_PHASES.mdl, sortable: true, sortKey: "mdl_submitted" },
  { id: "mdl_work_status", label: "WORK", colors: ASSET_PHASES.mdl, sortable: true, sortKey: "mdl_work" },
  { id: "mdl_approval_status", label: "APPR", colors: ASSET_PHASES.mdl, sortable: true, sortKey: "mdl_appr" },
  { id: "mdl_take", label: "TAKE", colors: ASSET_PHASES.mdl, sortable: true, sortKey: "mdl_take" },

  // RIG columns - ORDER MATTERS: SUBMITTED, WORK, APPR, TAKE
  { id: "rig_submitted_at", label: "SUBMITTED", colors: ASSET_PHASES.rig, sortable: true, sortKey: "rig_submitted" },
  { id: "rig_work_status", label: "WORK", colors: ASSET_PHASES.rig, sortable: true, sortKey: "rig_work" },
  { id: "rig_approval_status", label: "APPR", colors: ASSET_PHASES.rig, sortable: true, sortKey: "rig_appr" },
  { id: "rig_take", label: "TAKE", colors: ASSET_PHASES.rig, sortable: true, sortKey: "rig_take" },

  // BLD columns - ORDER MATTERS: WORK, APPR, SUBMITTED, TAKE (as per your image)
  { id: "bld_work_status", label: "WORK", colors: ASSET_PHASES.bld, sortable: true, sortKey: "bld_work" },
  { id: "bld_approval_status", label: "APPR", colors: ASSET_PHASES.bld, sortable: true, sortKey: "bld_appr" },
  { id: "bld_submitted_at", label: "SUBMITTED", colors: ASSET_PHASES.bld, sortable: true, sortKey: "bld_submitted" },
  { id: "bld_take", label: "TAKE", colors: ASSET_PHASES.bld, sortable: true, sortKey: "bld_take" },

  // DSN columns - ORDER MATTERS: WORK, APPR, SUBMITTED, TAKE
  { id: "dsn_work_status", label: "WORK", colors: ASSET_PHASES.dsn, sortable: true, sortKey: "dsn_work" },
  { id: "dsn_approval_status", label: "APPR", colors: ASSET_PHASES.dsn, sortable: true, sortKey: "dsn_appr" },
  { id: "dsn_submitted_at", label: "SUBMITTED", colors: ASSET_PHASES.dsn, sortable: true, sortKey: "dsn_submitted" },
  { id: "dsn_take", label: "TAKE", colors: ASSET_PHASES.dsn, sortable: true, sortKey: "dsn_take" },

  // LDV columns - ORDER MATTERS: WORK, APPR, SUBMITTED, TAKE
  { id: "ldv_work_status", label: "WORK", colors: ASSET_PHASES.ldv, sortable: true, sortKey: "ldv_work" },
  { id: "ldv_approval_status", label: "APPR", colors: ASSET_PHASES.ldv, sortable: true, sortKey: "ldv_appr" },
  { id: "ldv_submitted_at", label: "SUBMITTED", colors: ASSET_PHASES.ldv, sortable: true, sortKey: "ldv_submitted" },
  { id: "ldv_take", label: "TAKE", colors: ASSET_PHASES.ldv, sortable: true, sortKey: "ldv_take" },

  { id: "relation", label: "Relation", sortable: true, sortKey: "relation" },
  { id: "component", label: "Component", sortable: true, sortKey: "component" },
];

const NON_FIXED_IDS = columns.map(c => c.id).filter(id => id !== "thumbnail" && id !== "group_1_name");
const isOnlyFixedVisible = (hidden: Set<string>) => NON_FIXED_IDS.every(id => hidden.has(id));

type TooltipTableCellProps = {
  tooltipText: string;
  status: Status | undefined;
  leftBorderStyle: string;
  rightBorderStyle: string;
  bottomBorderStyle: string;
};

/**
 * Utility functions for consistent empty value handling
 */
const isEmptyValue = (value: any): boolean => {
  if (value === null || value === undefined) return true;
  const str = String(value).trim();
  return str === '' || str === '-' || str === '—' || str === 'null' || str === 'undefined';
};

const formatForDisplay = (value: any): string => {
  if (isEmptyValue(value)) return '—';
  return String(value).trim();
};

const MultiLineTooltipTableCell: React.FC<TooltipTableCellProps> = ({
  tooltipText, status, leftBorderStyle, rightBorderStyle, bottomBorderStyle = "none",
}) => {
  const [open, setOpen] = React.useState(false);
  const hasTooltipText = tooltipText && tooltipText.trim().length > 0;
  const statusText = status ? status.displayName : '—';

  return (
    <TableCell
      style={{
        color: status ? status.color : "",
        fontStyle: tooltipText === "" ? "normal" : "oblique",
        borderLeft: leftBorderStyle,
        borderRight: rightBorderStyle,
        borderBottom: bottomBorderStyle,
      }}
      onClick={hasTooltipText ? () => setOpen(true) : undefined}
    >
      {hasTooltipText ? (
        <Tooltip
          title={<div style={{ fontSize: "0.8rem", whiteSpace: "pre-wrap" }}>{tooltipText}</div>}
          onClose={() => setOpen(false)}
          open={open}
          arrow
        >
          <span>{statusText}</span>
        </Tooltip>
      ) : (
        <span>{statusText}</span>
      )}
    </TableCell>
  );
};

/**
 * Header Component with Vertical Phase Labels
 */
const VerticalPhaseHeader: React.FC<{
  hiddenColumns: Set<string>;
  onSortChange: (sortKey: string) => void;
  currentSortKey: string;
  currentSortDir: SortDir;
}> = ({ hiddenColumns, onSortChange, currentSortKey, currentSortDir }) => {
  const phases = ['mdl', 'rig', 'bld', 'dsn', 'ldv'] as const;

  // Column widths
  const getColumnWidth = (columnId: string): string => {
    if (columnId === 'thumbnail') return '140px';
    if (columnId === 'group_1_name') return '220px';
    if (columnId === 'relation') return '120px';
    if (columnId === 'component') return '150px';
    if (columnId.includes('submitted_at')) return '160px';
    if (columnId.includes('take')) return '90px';
    return '100px'; // WORK and APPR columns
  };

  // Get visible columns for a phase in correct order
  const getVisiblePhaseColumns = (phase: string) => {
    const phaseOrder = PHASE_COLUMN_ORDER[phase as keyof typeof PHASE_COLUMN_ORDER] || [];
    return phaseOrder
      .map(colId => columns.find(c => c.id === colId))
      .filter(col => col && !hiddenColumns.has(col.id)) as Column[];
  };

  return (
    <div style={{ 
      display: 'flex', 
      width: '100%',
      backgroundColor: '#f5f5f5',
      borderBottom: '2px solid #ddd',
      height: '120px', // Fixed height for header
    }}>
      {/* Left Fixed Columns */}
      <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        {/* THUMBNAIL - spans both rows */}
        {!hiddenColumns.has('thumbnail') && (
          <div style={{
            width: getColumnWidth('thumbnail'),
            backgroundColor: '#2a2a2a',
            color: '#fff',
            fontWeight: 'bold',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            borderRight: '1px solid #444',
            fontSize: '0.9rem',
            textAlign: 'center',
            padding: '0 8px',
            writingMode: 'vertical-lr',
            transform: 'rotate(180deg)',
          }}>
            THUMBNAIL
          </div>
        )}
        
        {/* NAME - spans both rows */}
        {!hiddenColumns.has('group_1_name') && (
          <div style={{
            width: getColumnWidth('group_1_name'),
            backgroundColor: '#2a2a2a',
            color: '#fff',
            fontWeight: 'bold',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            borderRight: '1px solid #444',
            fontSize: '0.9rem',
            textAlign: 'center',
            padding: '0 8px',
          }}>
            NAME
          </div>
        )}
      </div>

      {/* Phase Columns */}
      <div style={{ display: 'flex', flex: 1, height: '100%' }}>
        {phases.map(phase => {
          const phaseColumns = getVisiblePhaseColumns(phase);
          if (phaseColumns.length === 0) return null;

          const phaseColor = ASSET_PHASES[phase];
          
          return (
            <div 
              key={phase} 
              style={{ 
                display: 'flex', 
                flexDirection: 'column',
                height: '100%',
                borderLeft: `solid 3px ${phaseColor.lineColor}`,
                borderRight: `solid 3px ${phaseColor.lineColor}`,
              }}
            >
              {/* Phase Header Row (takes 1/3 height) */}
              <div style={{
                backgroundColor: phaseColor.backgroundColor,
                height: '40px', // 1/3 of 120px
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderBottom: `solid 3px ${phaseColor.lineColor}`,
              }}>
                <div style={{
                  color: '#fff',
                  fontWeight: 'bold',
                  fontSize: '1rem',
                  textTransform: 'uppercase',
                  transform: 'rotate(-90deg)',
                  whiteSpace: 'nowrap',
                }}>
                  {phase.toUpperCase()}
                </div>
              </div>

              {/* Column Headers Row (takes 2/3 height) */}
              <div style={{ 
                display: 'flex', 
                height: '80px', // 2/3 of 120px
                backgroundColor: phaseColor.backgroundColor,
              }}>
                {phaseColumns.map((column, index) => {
                  const isFirst = index === 0;
                  const isLast = index === phaseColumns.length - 1;
                  const isSubmitted = column.id.includes('submitted_at');
                  const sortKey = column.sortKey || column.id;
                  const sortDir = currentSortKey === sortKey ? currentSortDir : 'none';

                  return (
                    <div 
                      key={column.id} 
                      style={{ 
                        display: 'flex', 
                        flexDirection: 'column',
                        width: getColumnWidth(column.id),
                        height: '100%',
                        borderLeft: isFirst ? 'none' : '1px solid rgba(255,255,255,0.3)',
                        borderRight: isLast ? 'none' : '1px solid rgba(255,255,255,0.3)',
                      }}
                    >
                      {/* Main Column Label */}
                      <div
                        style={{
                          flex: 1,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          textAlign: 'center',
                          color: '#fff',
                          fontWeight: 600,
                          fontSize: '0.85rem',
                          cursor: column.sortable ? 'pointer' : 'default',
                          padding: '4px 2px',
                          '&:hover': column.sortable ? {
                            backgroundColor: 'rgba(255,255,255,0.1)',
                          } : {},
                        }}
                        onClick={column.sortable ? () => onSortChange(sortKey) : undefined}
                      >
                        <div style={{ 
                          display: 'flex', 
                          flexDirection: 'column',
                          alignItems: 'center',
                          gap: '2px'
                        }}>
                          <span>{column.label}</span>
                          {sortDir !== 'none' && (
                            <span style={{ fontSize: '0.7rem' }}>
                              {sortDir === 'desc' ? '▼' : '▲'}
                            </span>
                          )}
                        </div>
                      </div>

                      {/* "AT" Label for Submitted Columns Only */}
                      {isSubmitted && (
                        <div style={{
                          height: '24px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          color: '#ddd',
                          fontSize: '0.75rem',
                          fontWeight: 500,
                          borderTop: '1px solid rgba(255,255,255,0.2)',
                        }}>
                          AT
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>

      {/* Right Fixed Columns */}
      <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        {/* RELATION - spans both rows */}
        {!hiddenColumns.has('relation') && (
          <div style={{
            width: getColumnWidth('relation'),
            backgroundColor: '#2a2a2a',
            color: '#fff',
            fontWeight: 'bold',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            borderLeft: '1px solid #444',
            fontSize: '0.9rem',
            textAlign: 'center',
            padding: '0 8px',
          }}>
            RELATION
          </div>
        )}
        
        {/* COMPONENT - spans both rows */}
        {!hiddenColumns.has('component') && (
          <div style={{
            width: getColumnWidth('component'),
            backgroundColor: '#2a2a2a',
            color: '#fff',
            fontWeight: 'bold',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            borderLeft: '1px solid #444',
            fontSize: '0.9rem',
            textAlign: 'center',
            padding: '0 8px',
          }}>
            COMPONENT
          </div>
        )}
      </div>
    </div>
  );
};

/**
 * Alternative: Table-based implementation (simpler)
 */
const TableBasedHeader: React.FC<{
  hiddenColumns: Set<string>;
  onSortChange: (sortKey: string) => void;
  currentSortKey: string;
  currentSortDir: SortDir;
}> = ({ hiddenColumns, onSortChange, currentSortKey, currentSortDir }) => {
  const phases = ['mdl', 'rig', 'bld', 'dsn', 'ldv'] as const;

  return (
    <Table stickyHeader style={{ tableLayout: 'fixed', width: '100%' }}>
      <TableHead>
        {/* Row 1: Main headers */}
        <TableRow>
          {/* THUMBNAIL - rowSpan 2 */}
          {!hiddenColumns.has('thumbnail') && (
            <TableCell 
              rowSpan={2}
              style={{
                width: 140,
                backgroundColor: '#2a2a2a',
                color: '#fff',
                fontWeight: 'bold',
                textAlign: 'center',
                verticalAlign: 'middle',
                border: '1px solid #444',
              }}
            >
              THUMBNAIL
            </TableCell>
          )}
          
          {/* NAME - rowSpan 2 */}
          {!hiddenColumns.has('group_1_name') && (
            <TableCell 
              rowSpan={2}
              style={{
                minWidth: 220,
                backgroundColor: '#2a2a2a',
                color: '#fff',
                fontWeight: 'bold',
                textAlign: 'center',
                verticalAlign: 'middle',
                border: '1px solid #444',
              }}
            >
              NAME
            </TableCell>
          )}
          
          {/* Phase headers with individual columns */}
          {phases.flatMap(phase => {
            const phaseColumns = columns
              .filter(col => col.id.startsWith(phase) && !hiddenColumns.has(col.id))
              .sort((a, b) => {
                const order = PHASE_COLUMN_ORDER[phase as keyof typeof PHASE_COLUMN_ORDER];
                return order.indexOf(a.id) - order.indexOf(b.id);
              });
            
            if (phaseColumns.length === 0) return [];
            
            return phaseColumns.map((col, colIndex) => {
              const isFirstInPhase = colIndex === 0;
              const isLastInPhase = colIndex === phaseColumns.length - 1;
              const isSubmitted = col.id.includes('submitted_at');
              const phaseColor = ASSET_PHASES[phase];
              
              return (
                <TableCell
                  key={col.id}
                  style={{
                    backgroundColor: phaseColor.backgroundColor,
                    borderTop: `solid 3px ${phaseColor.lineColor}`,
                    borderLeft: isFirstInPhase ? `solid 3px ${phaseColor.lineColor}` : '1px solid rgba(255,255,255,0.3)',
                    borderRight: isLastInPhase ? `solid 3px ${phaseColor.lineColor}` : '1px solid rgba(255,255,255,0.3)',
                    borderBottom: isSubmitted ? 'none' : `solid 3px ${phaseColor.lineColor}`,
                    padding: '4px 2px',
                    height: '60px',
                  }}
                >
                  {/* Column label */}
                  <div style={{
                    color: '#fff',
                    fontWeight: 600,
                    fontSize: '0.85rem',
                    textAlign: 'center',
                    marginBottom: isSubmitted ? '4px' : '0',
                  }}>
                    {col.sortable ? (
                      <TableSortLabel
                        active={currentSortKey === (col.sortKey || col.id)}
                        direction={currentSortDir === 'desc' ? 'desc' : 'asc'}
                        onClick={() => onSortChange(col.sortKey || col.id)}
                        style={{ color: '#fff' }}
                      >
                        {col.label}
                      </TableSortLabel>
                    ) : col.label}
                  </div>
                  
                  {/* AT label for submitted columns */}
                  {isSubmitted && (
                    <div style={{
                      color: '#ddd',
                      fontSize: '0.75rem',
                      fontWeight: 500,
                      textAlign: 'center',
                      borderTop: '1px solid rgba(255,255,255,0.2)',
                      paddingTop: '2px',
                    }}>
                      AT
                    </div>
                  )}
                </TableCell>
              );
            });
          })}
          
          {/* RELATION - rowSpan 2 */}
          {!hiddenColumns.has('relation') && (
            <TableCell 
              rowSpan={2}
              style={{
                minWidth: 120,
                backgroundColor: '#2a2a2a',
                color: '#fff',
                fontWeight: 'bold',
                textAlign: 'center',
                verticalAlign: 'middle',
                border: '1px solid #444',
              }}
            >
              RELATION
            </TableCell>
          )}
          
          {/* COMPONENT - rowSpan 2 */}
          {!hiddenColumns.has('component') && (
            <TableCell 
              rowSpan={2}
              style={{
                minWidth: 150,
                backgroundColor: '#2a2a2a',
                color: '#fff',
                fontWeight: 'bold',
                textAlign: 'center',
                verticalAlign: 'middle',
                border: '1px solid #444',
              }}
            >
              COMPONENT
            </TableCell>
          )}
        </TableRow>
        
        {/* Row 2: Phase labels (vertical) - This row is actually hidden, phase labels are in row 1 cells */}
        <TableRow>
          {phases.flatMap(phase => {
            const phaseColumns = columns.filter(col => col.id.startsWith(phase) && !hiddenColumns.has(col.id));
            if (phaseColumns.length === 0) return [];
            
            const phaseColor = ASSET_PHASES[phase];
            
            // Create a single cell that spans all columns for this phase
            return [
              <TableCell
                key={`phase-label-${phase}`}
                colSpan={phaseColumns.length}
                style={{
                  backgroundColor: phaseColor.backgroundColor,
                  borderLeft: `solid 3px ${phaseColor.lineColor}`,
                  borderRight: `solid 3px ${phaseColor.lineColor}`,
                  borderBottom: `solid 3px ${phaseColor.lineColor}`,
                  padding: 0,
                  height: '40px',
                }}
              >
                <div style={{
                  color: '#fff',
                  fontWeight: 'bold',
                  fontSize: '1rem',
                  textTransform: 'uppercase',
                  transform: 'rotate(-90deg)',
                  whiteSpace: 'nowrap',
                  height: '100%',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  width: phaseColumns.length * 100, // Approximate width
                }}>
                  {phase.toUpperCase()}
                </div>
              </TableCell>
            ];
          })}
        </TableRow>
      </TableHead>
    </Table>
  );
};

// Keep the existing AssetRow component as is, but update column order processing
const AssetRow: React.FC<AssetRowProps & { hiddenColumns: Set<string>; compact: boolean }> = ({
  asset, thumbnails, dateTimeFormat, isLastRow, hiddenColumns, compact, phaseComponents, latestComponents,
}) => {
  const isHidden = (id: string) => hiddenColumns.has(id);

  const getPhaseData = (phase: string) => {
    const workStatusKey     = `${phase}_work_status` as keyof Asset;
    const approvalStatusKey = `${phase}_approval_status` as keyof Asset;
    const submittedAtKey    = `${phase}_submitted_at_utc` as keyof Asset;
    const takeKey          = `${phase}_take` as keyof Asset;

    const workStatusValue     = asset[workStatusKey];
    const approvalStatusValue = asset[approvalStatusKey];
    const submittedAtValue    = asset[submittedAtKey];
    const takeValue           = asset[takeKey];

    // Status lookup with fallback for empty values
    let workStatus: Status | undefined = undefined;
    if (!isEmptyValue(workStatusValue)) {
        const raw = String(workStatusValue);
        workStatus = WORK_STATUS[raw] || 
        WORK_STATUS[raw.toLowerCase()] || 
        WORK_STATUS[raw.charAt(0).toLowerCase() + raw.slice(1)];

        // Use a generic status if the key is not found
        if (!workStatus) {
            workStatus = WORK_STATUS.svOther;
        }
    }
    
    let approvalStatus: Status | undefined = undefined;
    if (!isEmptyValue(approvalStatusValue)) {
        const raw = String(approvalStatusValue);
        approvalStatus = APPROVAL_STATUS[raw] || 
        APPROVAL_STATUS[raw.toLowerCase()] || 
        APPROVAL_STATUS[raw.charAt(0).toLowerCase() + raw.slice(1)];

        // Use a generic status if the key is not found
        if (!approvalStatus) {
            approvalStatus = APPROVAL_STATUS.other;
        }
    }

    const submittedAt = !isEmptyValue(submittedAtValue) ? new Date(submittedAtValue as string) : null;
    const localTimeText = submittedAt ? dateTimeFormat.format(submittedAt) : '—';
    let takeText = '—';
    if (!isEmptyValue(takeValue)) {
      const rawTake = String(takeValue).trim();
      takeText = rawTake.slice(-4); // Last 4 characters as fallback
    }

    return { 
      workStatus, 
      approvalStatus, 
      localTimeText, 
      takeText,
      tooltipText: '',
    };
  };

  // function to get component display value
  const getComponentData = () => {
    // Check if component exists directly on the asset (from the API response)
    if (asset.component && !isEmptyValue(asset.component)) {
      const componentStr = String(asset.component).trim();
      // Clean underscores first, then format
      const cleanComponent = componentStr.replace(/^_+|_+$/g, '');
      return formatForDisplay(cleanComponent);
    }
    
    // Fallback to latestComponents if needed (for backward compatibility)
    const assetKey = `${asset.root}-${asset.relation}`;
    const component = latestComponents[assetKey];

    if (!component || component.length === 0) {
      return '—';
    }

    const componentNames = component.map(comp => {
      const compStr = String(comp.component).trim();
      const cleanComp = compStr.replace(/^_+|_+$/g, '');
      return formatForDisplay(cleanComp);
    }).filter(name => name !== '—'); // Remove empty display values
    
    return componentNames.join(', ') || '—';
  };
  
  const componentData = getComponentData();

  // Process phase columns in correct order
  const renderPhaseColumns = () => {
    const phases = ['mdl', 'rig', 'bld', 'dsn', 'ldv'] as const;
    
    return phases.flatMap(phase => {
      // Get columns in correct order for this phase
      const phaseOrder = PHASE_COLUMN_ORDER[phase as keyof typeof PHASE_COLUMN_ORDER] || [];
      const visiblePhaseColumns = phaseOrder.filter(colId => !isHidden(colId));
      
      if (visiblePhaseColumns.length === 0) return [];
      
      const phaseColor = ASSET_PHASES[phase];
      const { workStatus, approvalStatus, localTimeText, takeText } = getPhaseData(phase);
      
      return visiblePhaseColumns.map((colId, index) => {
        const isFirst = index === 0;
        const isLast = index === visiblePhaseColumns.length - 1;
        
        let cellContent = '—';
        let cellColor = '';
        
        if (colId.includes('work_status')) {
          cellContent = workStatus ? workStatus.displayName : '—';
          cellColor = workStatus ? workStatus.color : '';
        } else if (colId.includes('approval_status')) {
          cellContent = approvalStatus ? approvalStatus.displayName : '—';
          cellColor = approvalStatus ? approvalStatus.color : '';
        } else if (colId.includes('submitted_at')) {
          cellContent = localTimeText;
        } else if (colId.includes('take')) {
          cellContent = takeText;
        }
        
        return (
          <TableCell
            key={colId}
            style={{
              color: cellColor,
              borderLeft: isFirst ? `solid 3px ${phaseColor.lineColor}` : '1px solid #ddd',
              borderRight: isLast ? `solid 3px ${phaseColor.lineColor}` : '1px solid #ddd',
              borderBottom: isLastRow ? `solid 3px ${phaseColor.lineColor}` : '1px solid #ddd',
              padding: '8px 4px',
              textAlign: 'center',
              backgroundColor: isLastRow ? '#f9f9f9' : 'transparent',
            }}
          >
            {cellContent}
          </TableCell>
        );
      });
    });
  };

  return (
    <TableRow>
      {/* Thumbnail */}
      {!isHidden("thumbnail") && (
        <TableCell style={compact ? { width: 140, minWidth: 140, maxWidth: 140 } : undefined}>
          {thumbnails[`${asset.group_1}-${asset.relation}`] ? (
            <img
              src={thumbnails[`${asset.group_1}-${asset.relation}`]}
              alt={`${asset.group_1} thumbnail`}
              style={{ width: "100px", height: "auto" }}
            />
          ) : (
            <span>No Thumbnail</span>
          )}
        </TableCell>
      )}

      {/* Name */}
      {!isHidden("group_1_name") && (
        <TableCell style={compact ? { minWidth: 220 } : undefined}>
          {formatForDisplay(asset.group_1)}
        </TableCell>
      )}

      {/* Phase Columns (in correct order) */}
      {renderPhaseColumns()}

      {/* Relation */}
      {!isHidden("relation") && !compact && (
        <TableCell>{formatForDisplay(asset.relation)}</TableCell>
      )}
      
      {/* Component */}
      {!isHidden("component") && !compact && (
        <TableCell>
          {componentData ? (
            <div
              style={{
                display: 'flex',
                flexWrap: 'wrap',
                gap: '4px',
              }}
            >
              {componentData.split(', ').map((comp: string, index: number) => (
                <span
                  key={index}
                  style={{
                    padding: '2px 6px',
                    backgroundColor: '#e0e0e0',
                    borderRadius: '12px',
                    fontSize: '0.8rem',
                  }}
                >
                  {comp}
                </span>
              ))}
            </div>
          ) : '—'}
        </TableCell>
      )}
    </TableRow>
  );
};

const AssetsGroupedDataTable: React.FC<AssetsDataTableProps> = ({
  project,
  assets,
  tableFooter,
  dateTimeFormat,
  onSortChange,
  currentSortKey,
  currentSortDir,
  hiddenColumns = new Set(),
  latestComponents,
  phaseComponents,
}) => {
  if (!project) return null;

  const { thumbnails } = useFetchAssetThumbnails(project, assets);
  const compact = isOnlyFixedVisible(hiddenColumns);

  return (
    <div style={{ width: '100%', overflowX: 'auto' }}>
      {/* Use TableBasedHeader for simpler implementation */}
      <TableBasedHeader
        hiddenColumns={hiddenColumns}
        onSortChange={onSortChange}
        currentSortKey={currentSortKey}
        currentSortDir={currentSortDir}
      />
      
      {/* Body */}
      <Table style={{ tableLayout: 'fixed', width: '100%' }}>
        <TableBody>
          {assets.map((asset, index) => (
            <AssetRow
              key={`${asset.group_1}-${asset.relation}`}
              asset={asset}
              thumbnails={thumbnails}
              dateTimeFormat={dateTimeFormat}
              isLastRow={index === assets.length - 1}
              hiddenColumns={hiddenColumns}
              compact={compact}
              phaseComponents={phaseComponents}
              latestComponents={latestComponents}
            />
          ))}
        </TableBody>
      </Table>
      
      {/* Footer */}
      {tableFooter}
    </div>
  );
};

export default AssetsGroupedDataTable;
