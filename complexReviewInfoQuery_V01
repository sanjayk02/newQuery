package reviewinfo

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// ReviewInfo represents the final output of the query. (No change needed here)
type ReviewInfo struct {
	Root                 string `json:"root"`
	Project              string `json:"project"`
	Group1               string `json:"group_1"`
	Relation             string `json:"relation"`
	Phase                string `json:"phase"`
	WorkStatus           string `json:"work_status"`
	SubmittedAtUtc       string `json:"submitted_at_utc"`
	ModifiedAtUtc        string `json:"modified_at_utc"`
	ExecutedComputer     string `json:"executed_computer"`
}

// ReviewInfoRepository ... (No change needed here)
type ReviewInfoRepository struct {}


// --- CORRECTED SQL CONSTANT ---

// The constant uses three placeholders: %s for WHERE clause 1 (t1 alias), 
// %s for WHERE clause 2 (b alias), and %s for the final ORDER BY.
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM
        t_review_info AS t1 -- <-- ALIAS ADDED HERE
    WHERE
        %s -- Injected with t1.project = ? AND t1.root = ? AND t1.deleted = 0
    GROUP BY
        project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root,
        b.project,
        b.group_1,
        b.phase,
        b.relation,
        b.work_status,
        b.submitted_at_utc,
        b.modified_at_utc,
        b.executed_computer
    FROM
        max_modified AS a
    INNER JOIN
        t_review_info AS b
    ON
        a.project = b.project AND
        a.root = b.root AND
        a.group_1 = b.group_1 AND
        a.relation = b.relation AND
        a.phase = b.phase AND
        a.modified_at_utc = b.modified_at_utc
    WHERE
        %s -- Injected with b.project = ? AND b.root = ? AND b.deleted = 0
    ORDER BY
        b.submitted_at_utc ASC 
),
ordered AS (
    SELECT
        t1.*,
        ROW_NUMBER() OVER (
            ORDER BY t1.group_1 ASC 
        ) AS _order
    FROM
        latest_reviews t1
),
offset_ordered AS (
    SELECT
        c.*,
        CASE WHEN c.phase = 'rel' THEN c._order ELSE 100000 + c._order END AS __order
    FROM
        ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY CASE WHEN b.phase = 'rel' THEN 0 ELSE 1 END
        ) AS _rank
    FROM
        offset_ordered b
)
SELECT
    root,
    project,
    group_1,
    relation,
    phase,
    work_status,
    submitted_at_utc,
    modified_at_utc,
    executed_computer,
    __order
FROM
(
    SELECT
        *
    FROM
        ranked
    WHERE
        _rank = 1
) AS t
%s -- Final ORDER BY placeholder
LIMIT ? OFFSET ?
`

// ListLatestSubmissionsWithSort executes the complex SQL query.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	rootParam string,
	limit, offset int,
	sortParam string,
) ([]ReviewInfo, error) {

	// 1. Build the Dynamic WHERE Clauses with Aliases
    // This is the core fix for the "Column 'project' is ambiguous" error.
    
    // Base filter for project and deleted status
    baseFilter := "project = ? AND deleted = 0"
    if rootParam != "" {
        baseFilter += " AND root = ?"
    }

	// Clauses for max_modified (aliased as t1)
	filterClauseT1 := strings.ReplaceAll(baseFilter, "project", "t1.project")
	filterClauseT1 = strings.ReplaceAll(filterClauseT1, "root", "t1.root")
    filterClauseT1 = strings.ReplaceAll(filterClauseT1, "deleted", "t1.deleted")

	// Clauses for latest_reviews (aliased as b)
	filterClauseB := strings.ReplaceAll(baseFilter, "project", "b.project")
	filterClauseB = strings.ReplaceAll(filterClauseB, "root", "b.root")
    filterClauseB = strings.ReplaceAll(filterClauseB, "deleted", "b.deleted")


	// 2. Determine the dynamic ORDER BY clause
	orderByClause := "ORDER BY __order ASC" 
	if sortParam != "" {
		sortField := strings.TrimPrefix(sortParam, "-")
		direction := "ASC"
		if strings.HasPrefix(sortParam, "-") {
			direction = "DESC"
		}

		switch sortField {
		case "submitted":
			orderByClause = fmt.Sprintf("ORDER BY t.submitted_at_utc %s", direction)
		case "group_1":
			orderByClause = fmt.Sprintf("ORDER BY t.group_1 %s", direction)
		}
	}

	// 3. Construct the final query string and parameter list
	// We inject the three dynamic strings: filterClauseT1, filterClauseB, and orderByClause
	finalQuery := fmt.Sprintf(complexReviewInfoQuery, filterClauseT1, filterClauseB, orderByClause)

	// Build the combined parameter list for GORM execution
	var queryParams []interface{}
	queryParams = append(queryParams, project)
	if rootParam != "" {
		queryParams = append(queryParams, rootParam)
	}

	var finalParams []interface{}
	finalParams = append(finalParams, queryParams...) // Params for filterClauseT1
	finalParams = append(finalParams, queryParams...) // Params for filterClauseB
	finalParams = append(finalParams, limit, offset)  // Params for LIMIT and OFFSET

	// 4. Execute the query using GORM's Raw method
	var out []ReviewInfo

	result := db.WithContext(ctx).Raw(
		finalQuery,
		finalParams..., 
	).Scan(&out)

	if result.Error != nil {
		return nil, result.Error
	}

	return out, nil
}
