func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	_ string, // preferredPhase ignored for performance
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// order clause (reuse existing logic)
	orderClause := buildOrderClause("", orderKey, direction)

	// name filter
	nameCond := ""
	var args []any
	args = append(args, project, root)

	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = "AND LOWER(group_1) LIKE ?"
		args = append(args, strings.ToLower(strings.TrimSpace(assetNameKey))+"%")
	}

	// status filter
	statusWhere, statusArgs := buildPhaseAwareStatusWhere("", approvalStatuses, workStatuses)

	sql := `
SELECT
  project,
  root,
  group_1,
  relation,
  phase,
  submitted_at_utc
FROM t_review_info
WHERE (project, root, group_1, relation, modified_at_utc) IN (
  SELECT
    project,
    root,
    group_1,
    relation,
    MAX(modified_at_utc)
  FROM t_review_info
  WHERE project = ?
    AND root = ?
    AND deleted = 0
    ` + nameCond + `
    ` + statusWhere + `
  GROUP BY project, root, group_1, relation
)
ORDER BY ` + orderClause + `
LIMIT ? OFFSET ?;
`

	args = append(args, statusArgs...)
	args = append(args, limit, offset)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}

	return rows, nil
}
