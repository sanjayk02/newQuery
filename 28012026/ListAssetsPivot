func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// Safety timeout
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// 1) Count for pagination
	total, err := r.CountLatestSubmissions(
		ctx,
		project,
		root,
		assetNameKey,
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}

	// 2) Fetch ordered page keys (one per asset)
	keys, err := r.ListLatestSubmissionsDynamic(
		ctx,
		project,
		root,
		preferredPhase,
		orderKey,
		direction,
		limit,
		offset,
		assetNameKey,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// 3) Phase fetch (fully optimized, JSON safe)
	var sb strings.Builder
	var params []any

	sb.WriteString(`
WITH asset_keys AS (
`)

	for i, k := range keys {
		if i > 0 {
			sb.WriteString("  UNION ALL\n")
		}
		sb.WriteString("  SELECT ? AS project, ? AS root, ? AS group_1, ? AS relation\n")
		params = append(params, k.Project, k.Root, k.Group1, k.Relation)
	}

	sb.WriteString(`
),
ranked AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.modified_at_utc,
    ri.` + "`groups`" + `,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS rn
  FROM t_review_info ri
  INNER JOIN asset_keys ak
          ON ak.project  = ri.project
         AND ak.root     = ri.root
         AND ak.group_1  = ri.group_1
         AND ak.relation = ri.relation
  WHERE ri.deleted = 0
    AND ri.project = ?
    AND ri.root = ?
),
latest AS (
  SELECT
    r.project,
    r.root,
    r.group_1,
    r.relation,
    r.phase,
    r.work_status,
    r.approval_status,
    r.submitted_at_utc,
    JSON_UNQUOTE(JSON_EXTRACT(r.` + "`groups`" + `, '$[0]')) AS leaf_group_name
  FROM ranked r
  WHERE r.rn = 1
)
SELECT
  l.project,
  l.root,
  l.group_1,
  l.relation,
  l.phase,
  l.work_status,
  l.approval_status,
  l.submitted_at_utc,
  l.leaf_group_name,
  gc.path AS group_category_path,
  SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
FROM latest l
LEFT JOIN t_group_category_group gcg
       ON gcg.project = l.project
      AND gcg.deleted = 0
      AND gcg.path = l.leaf_group_name
LEFT JOIN t_group_category gc
       ON gc.id = gcg.group_category_id
      AND gc.deleted = 0
      AND gc.root = 'assets';
`)

	// defensive params
	params = append(params, project, root)

	var phases []phaseRow
	if err := r.db.WithContext(ctx).Raw(sb.String(), params...).Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// 4) Stitch phase rows into pivot rows (preserve order)
	type keyStruct struct {
		p, r, g, rel string
	}

	m := make(map[keyStruct]*AssetPivot, len(keys))
	orderedPtrs := make([]*AssetPivot, 0, len(keys))

	for _, k := range keys {
		id := keyStruct{k.Project, k.Root, k.Group1, k.Relation}
		ap := &AssetPivot{
			Root:     k.Root,
			Project:  k.Project,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
		m[id] = ap
		orderedPtrs = append(orderedPtrs, ap)
	}

	for _, pr := range phases {
		id := keyStruct{pr.Project, pr.Root, pr.Group1, pr.Relation}
		if ap, ok := m[id]; ok {

			if ap.LeafGroupName == "" {
				ap.LeafGroupName = pr.LeafGroupName
				ap.GroupCategoryPath = pr.GroupCategoryPath
				ap.TopGroupNode = pr.TopGroupNode
			}

			switch strings.ToLower(pr.Phase) {
			case "mdl":
				ap.MDLWorkStatus = pr.WorkStatus
				ap.MDLApprovalStatus = pr.ApprovalStatus
				ap.MDLSubmittedAtUTC = pr.SubmittedAtUTC
			case "rig":
				ap.RIGWorkStatus = pr.WorkStatus
				ap.RIGApprovalStatus = pr.ApprovalStatus
				ap.RIGSubmittedAtUTC = pr.SubmittedAtUTC
			case "bld":
				ap.BLDWorkStatus = pr.WorkStatus
				ap.BLDApprovalStatus = pr.ApprovalStatus
				ap.BLDSubmittedAtUTC = pr.SubmittedAtUTC
			case "dsn":
				ap.DSNWorkStatus = pr.WorkStatus
				ap.DSNApprovalStatus = pr.ApprovalStatus
				ap.DSNSubmittedAtUTC = pr.SubmittedAtUTC
			case "ldv":
				ap.LDVWorkStatus = pr.WorkStatus
				ap.LDVApprovalStatus = pr.ApprovalStatus
				ap.LDVSubmittedAtUTC = pr.SubmittedAtUTC
			}
		}
	}

	// 5) Flatten result
	ordered := make([]AssetPivot, len(orderedPtrs))
	for i, ap := range orderedPtrs {
		ordered[i] = *ap
	}

	return ordered, total, nil
}
