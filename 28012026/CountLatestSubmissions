func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	preferredPhase string,
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	db := r.db.WithContext(ctx)
	
	// Build the base query
	stmt := db.Model(&model.ReviewInfo{}).
		Select("DISTINCT group_1, relation").
		Where("project = ?", project).
		Where("root = ?", root).
		Where("deleted = ?", 0)
	
	// Name prefix filter
	if strings.TrimSpace(assetNameKey) != "" {
		stmt = stmt.Where("LOWER(group_1) LIKE ?", 
			strings.ToLower(strings.TrimSpace(assetNameKey)) + "%")
	}
	
	// If no status filters, count distinct assets directly
	if len(approvalStatuses) == 0 && len(workStatuses) == 0 {
		var count int64
		// Use a subquery to count distinct assets
		err := db.Raw("SELECT COUNT(*) FROM (?) AS t", 
			stmt).Scan(&count).Error
		return count, err
	}
	
	// With status filters, we need the latest per phase
	// Use a simpler approach - count from pre-aggregated data
	latestSubmissions, err := r.ListLatestSubmissionsDynamic(
		ctx,
		project, root, preferredPhase,
		"group1_only", "ASC", // default sorting
		10000, 0, // large limit to get all
		assetNameKey,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return 0, err
	}
	
	return int64(len(latestSubmissions)), nil
}
