// ---------- Dynamic Sorting Function ----------
func buildOrderClause(alias, key, dir string) string {
	// normalise direction
	dir = strings.ToUpper(strings.TrimSpace(dir))
	if dir != "ASC" && dir != "DESC" {
		dir = "ASC"
	}

	// alias helper
	col := func(c string) string {
		if alias != "" {
			return alias + "." + c
		}
		return c
	}

	lkey := strings.ToLower(strings.TrimSpace(key))

	// -----------------------------------------------------------------
	// 1) Explicit generic sorts
	// -----------------------------------------------------------------
	switch lkey {
	case "submitted_at_utc", "modified_at_utc", "phase":
		return col(lkey) + " " + dir

	case "group1_only":
		return fmt.Sprintf(
			"LOWER(%s) %s, LOWER(%s) ASC, "+
				"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
			col("group_1"), dir,
			col("relation"),
			col("submitted_at_utc"),
			col("submitted_at_utc"), dir,
		)

	case "relation_only":
		return fmt.Sprintf(
			"LOWER(%s) %s, LOWER(%s) ASC, "+
				"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
			col("relation"), dir,
			col("group_1"),
			col("submitted_at_utc"),
			col("submitted_at_utc"), dir,
		)

	case "group_rel_submitted":
		return fmt.Sprintf(
			"LOWER(%s) ASC, LOWER(%s) ASC, "+
				"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
			col("group_1"),
			col("relation"),
			col("submitted_at_utc"),
			col("submitted_at_utc"), dir,
		)
	}

	// -----------------------------------------------------------------
	// 2) Dynamic phase-aware patterns
	// -----------------------------------------------------------------
	// Anything *Submitted*  → submitted_at_utc
	if strings.HasSuffix(lkey, "_submitted") ||
		strings.HasSuffix(lkey, "_submitted_at") {
		return fmt.Sprintf(
			"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, "+
				"%s %s, LOWER(%s) ASC, LOWER(%s) ASC",
			col("submitted_at_utc"),
			col("submitted_at_utc"), dir,
			col("group_1"), col("relation"),
		)
	}

	// Anything *Work*       → work_status
	if strings.HasSuffix(lkey, "_work_status") ||
		strings.HasSuffix(lkey, "_work") ||
		lkey == "work_status" {
		return fmt.Sprintf(
			// 1) non-empty / non-dash first
			"CASE WHEN %s IS NULL OR TRIM(%s) = '' OR %s = '-' THEN 1 ELSE 0 END ASC, "+
				// 2) status text A↔Z
				"LOWER(%s) %s, "+
				// 3) tie-break by name
				"LOWER(%s) ASC, LOWER(%s) ASC, "+
				// 4) then submitted_at_utc (empties last)
				"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
			col("work_status"), col("work_status"), col("work_status"),
			col("work_status"), dir,
			col("group_1"), col("relation"),
			col("submitted_at_utc"), col("submitted_at_utc"), dir,
		)
	}

	// Anything *Approval*   → approval_status
	if strings.HasSuffix(lkey, "_approval_status") ||
		strings.HasSuffix(lkey, "_appr") {
		return fmt.Sprintf(
			"CASE WHEN %s IS NULL OR TRIM(%s) = '' OR %s = '-' THEN 1 ELSE 0 END ASC, "+
				"LOWER(%s) %s, "+
				"LOWER(%s) ASC, LOWER(%s) ASC, "+
				"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
			col("approval_status"), col("approval_status"), col("approval_status"),
			col("approval_status"), dir,
			col("group_1"), col("relation"),
			col("submitted_at_utc"), col("submitted_at_utc"), dir,
		)
	}

	// -----------------------------------------------------------------
	// 3) Fallback – default name + submitted sort
	// -----------------------------------------------------------------
	return fmt.Sprintf(
		"LOWER(%s) %s, LOWER(%s) ASC, "+
			"CASE WHEN %s IS NULL THEN 1 ELSE 0 END ASC, %s %s",
		col("group_1"), dir,
		col("relation"),
		col("submitted_at_utc"),
		col("submitted_at_utc"), dir,
	)
}
