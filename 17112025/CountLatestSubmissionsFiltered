// ---------- Count (for pagination total, WITH filters) ----------
func (r *ReviewInfo) CountLatestSubmissionsFiltered(
	ctx context.Context,
	project, root string,
	assetNameKey string,
	approvalStatuses, workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// base WHERE
	whereParts := []string{
		"project = ?",
		"root = ?",
		"deleted = 0",
	}
	args := []any{project, root}

	// ---- name filter (group_1 or relation contains text) ----
	assetNameKey = strings.TrimSpace(strings.ToLower(assetNameKey))
	if assetNameKey != "" {
		whereParts = append(whereParts,
			"(LOWER(group_1) LIKE ? OR LOWER(relation) LIKE ?)",
		)
		like := "%" + assetNameKey + "%"
		args = append(args, like, like)
	}

	// helper for IN (...) with LOWER()
	buildIn := func(col string, vals []string) (string, []any) {
		if len(vals) == 0 {
			return "", nil
		}
		ph := strings.Repeat("?,", len(vals))
		ph = ph[:len(ph)-1]
		a := make([]any, len(vals))
		for i, v := range vals {
			a[i] = strings.ToLower(strings.TrimSpace(v))
		}
		return fmt.Sprintf("LOWER(%s) IN (%s)", col, ph), a
	}

	// ---- approval filter (any phase) ----
	if c, a := buildIn("approval_status", approvalStatuses); c != "" {
		whereParts = append(whereParts, c)
		args = append(args, a...)
	}

	// ---- work filter (any phase) ----
	if c, a := buildIn("work_status", workStatuses); c != "" {
		whereParts = append(whereParts, c)
		args = append(args, a...)
	}

	whereSQL := strings.Join(whereParts, " AND ")

	const tmpl = `
SELECT COUNT(*) FROM (
	SELECT project, root, group_1, relation
	FROM t_review_info
	WHERE %s
	GROUP BY project, root, group_1, relation
) AS x;`

	q := fmt.Sprintf(tmpl, whereSQL)

	var total int64
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissionsFiltered: %w", err)
	}
	return total, nil
}
