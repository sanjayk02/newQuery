// ---------- Dynamic Listing Function ----------
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string, // e.g. "mdl" or "none"
	orderKey string,       // "group1_only" | "group_rel_submitted" | "submitted_at_utc" | ...
	direction string,      // "ASC" | "DESC"
	limit, offset int,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// Disable phase priority when caller passes phase=none
	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	// Separate order clauses for inner (alias b) vs window (unqualified)
	orderClauseWindow := buildOrderClause("", orderKey, direction)
	orderClauseInner := buildOrderClause("b", orderKey, direction)

	q := fmt.Sprintf(`
WITH ordered AS (
	SELECT
		*,
		ROW_NUMBER() OVER (ORDER BY %s) AS _order
	FROM (
		SELECT b.* FROM (
			SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
			FROM t_review_info
			WHERE project = ? AND root = ? AND deleted = 0
			GROUP BY project, root, group_1, relation, phase
		) AS a
		LEFT JOIN (
			SELECT root, project, group_1, phase, relation, work_status, submitted_at_utc, modified_at_utc, executed_computer
			FROM t_review_info
			WHERE project = ? AND root = ? AND deleted = 0
		) AS b
		  ON a.project = b.project
		 AND a.root    = b.root
		 AND a.group_1 = b.group_1
		 AND a.relation = b.relation
		 AND a.phase    = b.phase
		 AND a.modified_at_utc = b.modified_at_utc
		ORDER BY %s
	) AS k
),
offset_ordered AS (
	SELECT
		c.*,
		CASE
		  WHEN ? = 1 THEN c._order                      -- no phase preference
		  WHEN c.phase = ? THEN c._order                -- prefer requested phase
		  ELSE 100000 + c._order
		END AS __order
	FROM ordered c
),
ranked AS (
	SELECT
		b.*,
		ROW_NUMBER() OVER (
			PARTITION BY b.root, b.project, b.group_1, b.relation
			ORDER BY
			  CASE
			    WHEN ? = 1 THEN 0                         -- no phase preference
			    WHEN b.phase = ? THEN 0 ELSE 1           -- prefer requested phase
			  END,
			  LOWER(b.group_1) ASC,
			  LOWER(b.relation) ASC,
			  b.modified_at_utc DESC
		) AS _rank
	FROM offset_ordered b
)
SELECT root, project, group_1, relation, phase, submitted_at_utc
FROM ( SELECT * FROM ranked WHERE _rank = 1 ) AS t
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, orderClauseWindow, orderClauseInner)

	args := []any{
		project, root, // inner latest-per-phase
		project, root, // inner join rows
		phaseGuard, preferredPhase, // offset_ordered CASE
		phaseGuard, preferredPhase, // ranked CASE
		limit, offset,
	}

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}
