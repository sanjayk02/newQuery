func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// =========================================================
	// 1) TOTAL COUNT (ONE ROW PER ASSET)
	// =========================================================
	countSQL := `
		SELECT COUNT(*) FROM (
			SELECT
				ri.project,
				ri.root,
				ri.group_1,
				ri.relation
			FROM central30.t_review_info ri
			WHERE ri.project = ?
			  AND ri.root = ?
			  AND ri.deleted = 0
			  AND (? = '' OR ri.group_1 LIKE CONCAT(?, '%'))
			GROUP BY
				ri.project,
				ri.root,
				ri.group_1,
				ri.relation
		) t;
	`

	var total int64
	if err := r.db.WithContext(ctx).
		Raw(countSQL, project, root, assetNameKey, assetNameKey).
		Scan(&total).Error; err != nil {
		return nil, 0, err
	}

	// =========================================================
	// 2) PAGE KEYS (LATEST SUBMISSION PER ASSET)
	// =========================================================
	type keyRow struct {
		Project  string
		Root     string
		Group1   string
		Relation string
	}

	keysSQL := `
		WITH asset_keys AS (
			SELECT
				ri.project,
				ri.root,
				ri.group_1,
				ri.relation,
				MAX(ri.submitted_at_utc) AS latest_submitted_at
			FROM central30.t_review_info ri
			WHERE ri.project = ?
			  AND ri.root = ?
			  AND ri.deleted = 0
			  AND (? = '' OR ri.group_1 LIKE CONCAT(?, '%'))
			GROUP BY
				ri.project,
				ri.root,
				ri.group_1,
				ri.relation
		)
		SELECT
			project,
			root,
			group_1,
			relation
		FROM asset_keys
		ORDER BY latest_submitted_at DESC
		LIMIT ? OFFSET ?;
	`

	var keys []keyRow
	if err := r.db.WithContext(ctx).
		Raw(
			keysSQL,
			project,
			root,
			assetNameKey,
			assetNameKey,
			limit,
			offset,
		).
		Scan(&keys).Error; err != nil {
		return nil, 0, err
	}

	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// =========================================================
	// 3) PHASE FETCH (FIXED: submitted_at_utc CONSISTENT)
	// =========================================================
	var sb strings.Builder
	var params []any

	sb.WriteString(`
WITH ranked AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.` + "`groups`" + `,
    ROW_NUMBER() OVER (
      PARTITION BY
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase
      ORDER BY ri.submitted_at_utc DESC
    ) AS rn
  FROM central30.t_review_info ri
  WHERE ri.project = ?
    AND ri.root = ?
    AND ri.deleted = 0
    AND (
`)

	params = append(params, project, root)

	for i, k := range keys {
		if i > 0 {
			sb.WriteString("      OR ")
		}
		sb.WriteString("(ri.group_1 = ? AND ri.relation = ?)\n")
		params = append(params, k.Group1, k.Relation)
	}

	sb.WriteString(`    )
),
latest_only AS (
  SELECT * FROM ranked WHERE rn = 1
)
SELECT
  lo.project,
  lo.root,
  lo.group_1,
  lo.relation,
  lo.phase,
  lo.work_status,
  lo.approval_status,
  lo.submitted_at_utc,
  JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]')) AS leaf_group_name,
  gc.path AS group_category_path,
  SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
FROM latest_only lo
LEFT JOIN t_group_category_group gcg
       ON gcg.project = lo.project
      AND gcg.deleted = 0
      AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]'))
LEFT JOIN t_group_category gc
       ON gc.id = gcg.group_category_id
      AND gc.deleted = 0
      AND gc.root = 'assets';
`)

	var phases []phaseRow
	if err := r.db.WithContext(ctx).
		Raw(sb.String(), params...).
		Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// =========================================================
	// 4) STITCH RESULTS (UNCHANGED, SAFE)
	// =========================================================
	type keyStruct struct {
		p, r, g, rel string
	}

	m := make(map[keyStruct]*AssetPivot, len(keys))
	orderedPtrs := make([]*AssetPivot, 0, len(keys))

	for _, k := range keys {
		id := keyStruct{k.Project, k.Root, k.Group1, k.Relation}
		ap := &AssetPivot{
			Project:  k.Project,
			Root:     k.Root,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
		m[id] = ap
		orderedPtrs = append(orderedPtrs, ap)
	}

	for _, pr := range phases {
		id := keyStruct{pr.Project, pr.Root, pr.Group1, pr.Relation}
		if ap, ok := m[id]; ok {
			if ap.LeafGroupName == "" {
				ap.LeafGroupName = pr.LeafGroupName
				ap.GroupCategoryPath = pr.GroupCategoryPath
				ap.TopGroupNode = pr.TopGroupNode
			}

			switch strings.ToLower(pr.Phase) {
			case "mdl":
				ap.MDLWorkStatus = pr.WorkStatus
				ap.MDLApprovalStatus = pr.ApprovalStatus
				ap.MDLSubmittedAtUTC = pr.SubmittedAtUTC
			case "rig":
				ap.RIGWorkStatus = pr.WorkStatus
				ap.RIGApprovalStatus = pr.ApprovalStatus
				ap.RIGSubmittedAtUTC = pr.SubmittedAtUTC
			case "bld":
				ap.BLDWorkStatus = pr.WorkStatus
				ap.BLDApprovalStatus = pr.ApprovalStatus
				ap.BLDSubmittedAtUTC = pr.SubmittedAtUTC
			case "dsn":
				ap.DSNWorkStatus = pr.WorkStatus
				ap.DSNApprovalStatus = pr.ApprovalStatus
				ap.DSNSubmittedAtUTC = pr.SubmittedAtUTC
			case "ldv":
				ap.LDVWorkStatus = pr.WorkStatus
				ap.LDVApprovalStatus = pr.ApprovalStatus
				ap.LDVSubmittedAtUTC = pr.SubmittedAtUTC
			}
		}
	}

	ordered := make([]AssetPivot, len(orderedPtrs))
	for i, ap := range orderedPtrs {
		ordered[i] = *ap
	}

	return ordered, total, nil
}
