package repository

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"gorm.io/gorm"
)

//
// ========================================================================
// ============================== MODELS ==================================
// ========================================================================
//

type AssetPivot struct {
	Root     string `json:"root"`
	Project  string `json:"project"`
	Group1   string `json:"group_1"`
	Relation string `json:"relation"`

	// grouping info (resolved in Go)
	LeafGroupName     string `json:"leaf_group_name"`
	GroupCategoryPath string `json:"group_category_path"`
	TopGroupNode      string `json:"top_group_node"`

	MDLWorkStatus     *string    `json:"mdl_work_status"`
	MDLApprovalStatus *string    `json:"mdl_approval_status"`
	MDLSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

	RIGWorkStatus     *string    `json:"rig_work_status"`
	RIGApprovalStatus *string    `json:"rig_approval_status"`
	RIGSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

	BLDWorkStatus     *string    `json:"bld_work_status"`
	BLDApprovalStatus *string    `json:"bld_approval_status"`
	BLDSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

	DSNWorkStatus     *string    `json:"dsn_work_status"`
	DSNApprovalStatus *string    `json:"dsn_approval_status"`
	DSNSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

	LDVWorkStatus     *string    `json:"ldv_work_status"`
	LDVApprovalStatus *string    `json:"ldv_approval_status"`
	LDVSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`
}

//
// ========================================================================
// ========================== GROUPED VIEW ================================
// ========================================================================
//

type SortDirection string

const (
	SortASC  SortDirection = "ASC"
	SortDESC SortDirection = "DESC"
)

type GroupedAssetBucket struct {
	TopGroupNode string       `json:"top_group_node"`
	Items        []AssetPivot `json:"items"`
}

func GroupAndSortByTopNode(rows []AssetPivot, dir SortDirection) []GroupedAssetBucket {
	grouped := make(map[string][]AssetPivot)
	order := make([]string, 0)

	for _, r := range rows {
		key := strings.TrimSpace(r.TopGroupNode)
		if key == "" {
			key = "Unassigned"
		}
		if _, ok := grouped[key]; !ok {
			order = append(order, key)
		}
		grouped[key] = append(grouped[key], r)
	}

	sort.Slice(order, func(i, j int) bool {
		a, b := strings.ToLower(order[i]), strings.ToLower(order[j])
		if a == "unassigned" {
			return true
		}
		if b == "unassigned" {
			return false
		}
		if dir == SortDESC {
			return a > b
		}
		return a < b
	})

	out := make([]GroupedAssetBucket, 0, len(order))
	for _, k := range order {
		items := grouped[k]
		sort.Slice(items, func(i, j int) bool {
			if dir == SortDESC {
				return strings.ToLower(items[i].Group1) > strings.ToLower(items[j].Group1)
			}
			return strings.ToLower(items[i].Group1) < strings.ToLower(items[j].Group1)
		})
		out = append(out, GroupedAssetBucket{
			TopGroupNode: k,
			Items:        items,
		})
	}
	return out
}

//
// ========================================================================
// ======================= CATEGORY RESOLVER ==============================
// ========================================================================
//

type categoryInfo struct {
	Path     string
	TopGroup string
}

func (r *ReviewInfo) loadCategoryMap(
	ctx context.Context,
	project string,
) (map[string]categoryInfo, error) {

	type row struct {
		Path string
	}

	var rows []row
	err := r.db.WithContext(ctx).
		Table("t_group_category_group").
		Select("path").
		Where("project = ? AND deleted = 0", project).
		Scan(&rows).Error
	if err != nil {
		return nil, err
	}

	m := make(map[string]categoryInfo, len(rows))
	for _, r := range rows {
		top := r.Path
		if i := strings.Index(top, "/"); i > 0 {
			top = top[:i]
		}
		m[r.Path] = categoryInfo{
			Path:     r.Path,
			TopGroup: top,
		}
	}
	return m, nil
}

//
// ========================================================================
// ========================= ORDER BUILDER ================================
// ========================================================================
//

// IMPORTANT:
// Asset-level ordering ONLY.
// Never reference phase-level columns here.
func buildOrderClause(key, dir string) string {
	dir = strings.ToUpper(dir)
	if dir != "ASC" && dir != "DESC" {
		dir = "ASC"
	}

	switch key {

	case "relation_only":
		return fmt.Sprintf("LOWER(relation) %s, LOWER(group_1) ASC", dir)

	case "group_rel_submitted":
		return fmt.Sprintf(
			"LOWER(group_1) ASC, LOWER(relation) ASC, (latest_submitted_at IS NULL) ASC, latest_submitted_at %s",
			dir,
		)

	case "mdl_submitted", "rig_submitted", "bld_submitted", "dsn_submitted", "ldv_submitted":
		return fmt.Sprintf(
			"(latest_submitted_at IS NULL) ASC, latest_submitted_at %s, LOWER(group_1) ASC",
			dir,
		)

	default: // group1_only
		return fmt.Sprintf(
			"LOWER(group_1) %s, LOWER(relation) ASC, (latest_submitted_at IS NULL) ASC, latest_submitted_at %s",
			dir,
		)
	}
}

//
// ========================================================================
// ============================ REPOSITORY ================================
// ========================================================================
//

type ReviewInfo struct {
	db *gorm.DB
}

func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, _preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	where := []string{
		"ri.project = ?",
		"ri.root = ?",
		"ri.deleted = 0",
	}
	args := []any{project, root}

	if assetNameKey != "" {
		where = append(where, "LOWER(ri.group_1) LIKE ?")
		args = append(args, strings.ToLower(assetNameKey)+"%")
	}

	whereSQL := strings.Join(where, " AND ")
	orderSQL := buildOrderClause(orderKey, direction)

	sql := fmt.Sprintf(`
WITH base AS (
    SELECT
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase,
        ri.work_status,
        ri.approval_status,
        ri.submitted_at_utc,
        ri.modified_at_utc,

        -- JSON extraction ONCE (kept intentionally)
        JSON_UNQUOTE(JSON_EXTRACT(ri.%s,'$[0]')) AS leaf_group_name,

        ROW_NUMBER() OVER (
            PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
            ORDER BY ri.modified_at_utc DESC
        ) AS rn
    FROM t_review_info ri
    WHERE %s
),
latest_phases AS (
    SELECT * FROM base WHERE rn = 1
),
asset_keys AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        MAX(submitted_at_utc) AS latest_submitted_at
    FROM latest_phases
    GROUP BY project, root, group_1, relation
),
ordered_assets AS (
    SELECT *,
           ROW_NUMBER() OVER (ORDER BY %s) AS asset_row_num,
           COUNT(*) OVER () AS total_count
    FROM asset_keys
),
paged_assets AS (
    SELECT *
    FROM ordered_assets
    WHERE asset_row_num > ? AND asset_row_num <= ?
)
SELECT
    lp.project,
    lp.root,
    lp.group_1,
    lp.relation,
    lp.leaf_group_name,
    pa.total_count,

    MAX(CASE WHEN lp.phase='mdl' THEN lp.work_status END)      AS mdl_work_status,
    MAX(CASE WHEN lp.phase='mdl' THEN lp.approval_status END)  AS mdl_approval_status,
    MAX(CASE WHEN lp.phase='mdl' THEN lp.submitted_at_utc END) AS mdl_submitted_at_utc,

    MAX(CASE WHEN lp.phase='rig' THEN lp.work_status END)      AS rig_work_status,
    MAX(CASE WHEN lp.phase='rig' THEN lp.approval_status END)  AS rig_approval_status,
    MAX(CASE WHEN lp.phase='rig' THEN lp.submitted_at_utc END) AS rig_submitted_at_utc,

    MAX(CASE WHEN lp.phase='bld' THEN lp.work_status END)      AS bld_work_status,
    MAX(CASE WHEN lp.phase='bld' THEN lp.approval_status END)  AS bld_approval_status,
    MAX(CASE WHEN lp.phase='bld' THEN lp.submitted_at_utc END) AS bld_submitted_at_utc,

    MAX(CASE WHEN lp.phase='dsn' THEN lp.work_status END)      AS dsn_work_status,
    MAX(CASE WHEN lp.phase='dsn' THEN lp.approval_status END)  AS dsn_approval_status,
    MAX(CASE WHEN lp.phase='dsn' THEN lp.submitted_at_utc END) AS dsn_submitted_at_utc,

    MAX(CASE WHEN lp.phase='ldv' THEN lp.work_status END)      AS ldv_work_status,
    MAX(CASE WHEN lp.phase='ldv' THEN lp.approval_status END)  AS ldv_approval_status,
    MAX(CASE WHEN lp.phase='ldv' THEN lp.submitted_at_utc END) AS ldv_submitted_at_utc

FROM paged_assets pa
JOIN latest_phases lp
  ON lp.project  = pa.project
 AND lp.root     = pa.root
 AND lp.group_1  = pa.group_1
 AND lp.relation = pa.relation
GROUP BY
    lp.project, lp.root, lp.group_1, lp.relation,
    lp.leaf_group_name, pa.total_count
ORDER BY pa.asset_row_num;
`,
		"`groups`",
		whereSQL,
		orderSQL,
	)

	args = append(args, offset, offset+limit)

	var rows []struct {
		AssetPivot
		Total int64 `gorm:"column:total_count"`
	}

	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	if len(rows) == 0 {
		return []AssetPivot{}, 0, nil
	}

	// Resolve category info in Go (fast, cacheable)
	catMap, _ := r.loadCategoryMap(ctx, project)

	out := make([]AssetPivot, len(rows))
	for i := range rows {
		out[i] = rows[i].AssetPivot
		if info, ok := catMap[out[i].LeafGroupName]; ok {
			out[i].GroupCategoryPath = info.Path
			out[i].TopGroupNode = info.TopGroup
		}
	}

	return out, rows[0].Total, nil
}
