package repository

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"gorm.io/gorm"
)

//
// ========================================================================
// ============================== MODELS ==================================
// ========================================================================
//

type AssetPivot struct {
	Root     string `json:"root"`
	Project  string `json:"project"`
	Group1   string `json:"group_1"`
	Relation string `json:"relation"`

	LeafGroupName     string `json:"leaf_group_name"`
	GroupCategoryPath string `json:"group_category_path"`
	TopGroupNode      string `json:"top_group_node"`

	MDLWorkStatus     *string    `json:"mdl_work_status"`
	MDLApprovalStatus *string    `json:"mdl_approval_status"`
	MDLSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

	RIGWorkStatus     *string    `json:"rig_work_status"`
	RIGApprovalStatus *string    `json:"rig_approval_status"`
	RIGSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

	BLDWorkStatus     *string    `json:"bld_work_status"`
	BLDApprovalStatus *string    `json:"bld_approval_status"`
	BLDSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

	DSNWorkStatus     *string    `json:"dsn_work_status"`
	DSNApprovalStatus *string    `json:"dsn_approval_status"`
	DSNSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

	LDVWorkStatus     *string    `json:"ldv_work_status"`
	LDVApprovalStatus *string    `json:"ldv_approval_status"`
	LDVSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`
}

//
// ========================================================================
// ========================== GROUPED VIEW ================================
// ========================================================================
//

type SortDirection string

const (
	SortASC  SortDirection = "ASC"
	SortDESC SortDirection = "DESC"
)

type GroupedAssetBucket struct {
	TopGroupNode string       `json:"top_group_node"`
	Items        []AssetPivot `json:"items"`
}

func GroupAndSortByTopNode(rows []AssetPivot, dir SortDirection) []GroupedAssetBucket {
	grouped := make(map[string][]AssetPivot)
	order := make([]string, 0)

	for _, r := range rows {
		key := strings.TrimSpace(r.TopGroupNode)
		if key == "" {
			key = "Unassigned"
		}
		if _, ok := grouped[key]; !ok {
			order = append(order, key)
		}
		grouped[key] = append(grouped[key], r)
	}

	sort.Slice(order, func(i, j int) bool {
		a, b := strings.ToLower(order[i]), strings.ToLower(order[j])
		if a == "unassigned" {
			return true
		}
		if b == "unassigned" {
			return false
		}
		if dir == SortDESC {
			return a > b
		}
		return a < b
	})

	out := make([]GroupedAssetBucket, 0, len(order))
	for _, k := range order {
		items := grouped[k]
		sort.Slice(items, func(i, j int) bool {
			if dir == SortDESC {
				return strings.ToLower(items[i].Group1) > strings.ToLower(items[j].Group1)
			}
			return strings.ToLower(items[i].Group1) < strings.ToLower(items[j].Group1)
		})
		out = append(out, GroupedAssetBucket{
			TopGroupNode: k,
			Items:        items,
		})
	}
	return out
}

//
// ========================================================================
// ========================= FILTER / ORDER ===============================
// ========================================================================
//

// IMPORTANT:
// buildOrderClause is used ONLY for ASSET-LEVEL window ordering.
// Only columns present in `asset_keys` may be referenced here.
// NEVER use phase-level columns like `submitted_at_utc`.
func buildOrderClause(key, dir string) string {
	dir = strings.ToUpper(dir)
	if dir != "ASC" && dir != "DESC" {
		dir = "ASC"
	}

	col := func(c string) string { return c }

	switch key {

	case "group1_only":
		return fmt.Sprintf(
			"LOWER(%s) %s, LOWER(%s) ASC",
			col("group_1"), dir,
			col("relation"),
		)

	case "relation_only":
		return fmt.Sprintf(
			"LOWER(%s) %s, LOWER(%s) ASC",
			col("relation"), dir,
			col("group_1"),
		)

	case "group_rel_submitted":
		return fmt.Sprintf(
			"LOWER(%s) ASC, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
			col("group_1"),
			col("relation"),
			col("latest_submitted_at"),
			col("latest_submitted_at"), dir,
		)

	// phase-specific submitted date (asset-level)
	case "mdl_submitted", "rig_submitted", "bld_submitted", "dsn_submitted", "ldv_submitted":
		return fmt.Sprintf(
			"(%s IS NULL) ASC, %s %s, LOWER(%s) ASC",
			col("latest_submitted_at"),
			col("latest_submitted_at"), dir,
			col("group_1"),
		)

	default:
		return fmt.Sprintf(
			"LOWER(%s) %s, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
			col("group_1"), dir,
			col("relation"),
			col("latest_submitted_at"),
			col("latest_submitted_at"), dir,
		)
	}
}

//
// ========================================================================
// ============================ REPOSITORY ================================
// ========================================================================
//

type ReviewInfo struct {
	db *gorm.DB
}

func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, _preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	where := []string{
		"ri.project = ?",
		"ri.root = ?",
		"ri.deleted = 0",
	}
	args := []any{project, root}

	if assetNameKey != "" {
		where = append(where, "LOWER(ri.group_1) LIKE ?")
		args = append(args, strings.ToLower(assetNameKey)+"%")
	}

	whereSQL := strings.Join(where, " AND ")
	orderSQL := buildOrderClause(orderKey, direction)

	sql := fmt.Sprintf(`
WITH base AS (
    SELECT
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase,
        ri.work_status,
        ri.approval_status,
        ri.submitted_at_utc,
        ri.modified_at_utc,
        JSON_UNQUOTE(JSON_EXTRACT(ri.%s,'$[0]')) AS leaf_group_name,
        ROW_NUMBER() OVER (
            PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
            ORDER BY ri.modified_at_utc DESC
        ) AS phase_rn
    FROM t_review_info ri
    WHERE %s
),
latest_phases AS (
    SELECT * FROM base WHERE phase_rn = 1
),
with_category AS (
    SELECT
        lp.*,
        gc.path AS group_category_path,
        SUBSTRING_INDEX(gc.path,'/',1) AS top_group_node
    FROM latest_phases lp
    LEFT JOIN t_group_category_group gcg
        ON gcg.project = lp.project
       AND gcg.deleted = 0
       AND gcg.path = lp.leaf_group_name
    LEFT JOIN t_group_category gc
        ON gc.id = gcg.group_category_id
       AND gc.deleted = 0
       AND gc.root = 'assets'
),
asset_keys AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        MAX(submitted_at_utc) AS latest_submitted_at
    FROM with_category
    GROUP BY project, root, group_1, relation
),
ordered_assets AS (
    SELECT *,
           ROW_NUMBER() OVER (ORDER BY %s) AS asset_row_num,
           COUNT(*) OVER () AS total_count
    FROM asset_keys
),
paged_assets AS (
    SELECT *
    FROM ordered_assets
    WHERE asset_row_num > ? AND asset_row_num <= ?
),
final_data AS (
    SELECT
        wc.*,
        pa.total_count,
        pa.asset_row_num
    FROM paged_assets pa
    JOIN with_category wc
      ON wc.project = pa.project
     AND wc.root = pa.root
     AND wc.group_1 = pa.group_1
     AND wc.relation = pa.relation
)
SELECT
    project,
    root,
    group_1,
    relation,
    leaf_group_name,
    group_category_path,
    top_group_node,
    total_count,

    MAX(CASE WHEN phase='mdl' THEN work_status END)      AS mdl_work_status,
    MAX(CASE WHEN phase='mdl' THEN approval_status END)  AS mdl_approval_status,
    MAX(CASE WHEN phase='mdl' THEN submitted_at_utc END) AS mdl_submitted_at_utc,

    MAX(CASE WHEN phase='rig' THEN work_status END)      AS rig_work_status,
    MAX(CASE WHEN phase='rig' THEN approval_status END)  AS rig_approval_status,
    MAX(CASE WHEN phase='rig' THEN submitted_at_utc END) AS rig_submitted_at_utc,

    MAX(CASE WHEN phase='bld' THEN work_status END)      AS bld_work_status,
    MAX(CASE WHEN phase='bld' THEN approval_status END)  AS bld_approval_status,
    MAX(CASE WHEN phase='bld' THEN submitted_at_utc END) AS bld_submitted_at_utc,

    MAX(CASE WHEN phase='dsn' THEN work_status END)      AS dsn_work_status,
    MAX(CASE WHEN phase='dsn' THEN approval_status END)  AS dsn_approval_status,
    MAX(CASE WHEN phase='dsn' THEN submitted_at_utc END) AS dsn_submitted_at_utc,

    MAX(CASE WHEN phase='ldv' THEN work_status END)      AS ldv_work_status,
    MAX(CASE WHEN phase='ldv' THEN approval_status END)  AS ldv_approval_status,
    MAX(CASE WHEN phase='ldv' THEN submitted_at_utc END) AS ldv_submitted_at_utc

FROM final_data
GROUP BY
    project, root, group_1, relation,
    leaf_group_name, group_category_path,
    top_group_node, total_count
ORDER BY asset_row_num
`,
		"`groups`",
		whereSQL,
		orderSQL,
	)

	args = append(args, offset, offset+limit)

	var rows []struct {
		AssetPivot
		Total int64 `gorm:"column:total_count"`
	}

	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	if len(rows) == 0 {
		return []AssetPivot{}, 0, nil
	}

	out := make([]AssetPivot, len(rows))
	for i := range rows {
		out[i] = rows[i].AssetPivot
	}

	return out, rows[0].Total, nil
}
