func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// ------------------------------------------------------------
	// WHERE clause
	// ------------------------------------------------------------
	where := []string{
		"ri.project = ?",
		"ri.root = ?",
		"ri.deleted = 0",
	}
	args := []any{project, root}

	if strings.TrimSpace(assetNameKey) != "" {
		where = append(where, "LOWER(ri.group_1) LIKE ?")
		args = append(args, strings.ToLower(assetNameKey)+"%")
	}

	if sw, sa := buildPhaseAwareStatusWhere(
		preferredPhase,
		approvalStatuses,
		workStatuses,
	); sw != "" {
		where = append(where, sw)
		args = append(args, sa...)
	}

	whereSQL := strings.Join(where, " AND ")
	orderSQL := buildOrderClause("", orderKey, direction)

	// ------------------------------------------------------------
	// SINGLE QUERY â€” JSON EXTRACTED ONCE
	// ------------------------------------------------------------
	sql := fmt.Sprintf(`
WITH base AS (
    SELECT
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase,
        ri.work_status,
        ri.approval_status,
        ri.submitted_at_utc,
        ri.modified_at_utc,

        -- JSON extracted ONCE
        JSON_UNQUOTE(JSON_EXTRACT(ri.%s, '$[0]')) AS leaf_group_name,

        ROW_NUMBER() OVER (
            PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
            ORDER BY ri.modified_at_utc DESC
        ) AS phase_rn
    FROM t_review_info ri
    WHERE %s
),
latest_phases AS (
    SELECT * FROM base WHERE phase_rn = 1
),
with_category AS (
    SELECT
        lp.*,
        gc.path AS group_category_path,
        SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
    FROM latest_phases lp
    LEFT JOIN t_group_category_group gcg
        ON gcg.project = lp.project
       AND gcg.deleted = 0
       AND gcg.path = lp.leaf_group_name
    LEFT JOIN t_group_category gc
        ON gc.id = gcg.group_category_id
       AND gc.deleted = 0
       AND gc.root = 'assets'
),
asset_keys AS (
    SELECT DISTINCT
        project, root, group_1, relation
    FROM with_category
),
ordered_assets AS (
    SELECT
        *,
        ROW_NUMBER() OVER (ORDER BY %s) AS asset_row_num,
        COUNT(*) OVER () AS total_count
    FROM asset_keys
),
paged_assets AS (
    SELECT *
    FROM ordered_assets
    WHERE asset_row_num > ? AND asset_row_num <= ?
),
final_data AS (
    SELECT
        wc.*,
        pa.total_count,
        pa.asset_row_num
    FROM paged_assets pa
    JOIN with_category wc
      ON wc.project  = pa.project
     AND wc.root     = pa.root
     AND wc.group_1  = pa.group_1
     AND wc.relation = pa.relation
)
SELECT
    project,
    root,
    group_1,
    relation,
    leaf_group_name,
    group_category_path,
    top_group_node,
    total_count,

    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN work_status END)      AS mdl_work_status,
    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN approval_status END)  AS mdl_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN submitted_at_utc END) AS mdl_submitted_at_utc,

    MAX(CASE WHEN LOWER(phase) = 'rig' THEN work_status END)      AS rig_work_status,
    MAX(CASE WHEN LOWER(phase) = 'rig' THEN approval_status END)  AS rig_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'rig' THEN submitted_at_utc END) AS rig_submitted_at_utc,

    MAX(CASE WHEN LOWER(phase) = 'bld' THEN work_status END)      AS bld_work_status,
    MAX(CASE WHEN LOWER(phase) = 'bld' THEN approval_status END)  AS bld_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'bld' THEN submitted_at_utc END) AS bld_submitted_at_utc,

    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN work_status END)      AS dsn_work_status,
    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN approval_status END)  AS dsn_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN submitted_at_utc END) AS dsn_submitted_at_utc,

    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN work_status END)      AS ldv_work_status,
    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN approval_status END)  AS ldv_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN submitted_at_utc END) AS ldv_submitted_at_utc

FROM final_data
GROUP BY
    project, root, group_1, relation,
    leaf_group_name, group_category_path,
    top_group_node, total_count
ORDER BY asset_row_num;
`,
		"`groups`",
		whereSQL,
		orderSQL,
	)

	args = append(args, offset, offset+limit)

	var rows []struct {
		AssetPivot
		TotalCount int64 `gorm:"column:total_count"`
	}

	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot: %w", err)
	}

	if len(rows) == 0 {
		return []AssetPivot{}, 0, nil
	}

	out := make([]AssetPivot, len(rows))
	for i := range rows {
		out[i] = rows[i].AssetPivot
	}

	return out, rows[0].TotalCount, nil
}
