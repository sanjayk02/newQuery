package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/PolygonPictures/central30-web/front/entity"
	"github.com/PolygonPictures/central30-web/front/repository/model"
	"gorm.io/gorm"
)

type ReviewInfo struct {
	db *gorm.DB
}

// ... [Keep NewReviewInfo, WithContext, List, Get, Create, Update, Delete as they are] ...

/*
──────────────────────────────────────────────────────────────────────────
	CountLatestSubmissions
	FIX: Removed ROW_NUMBER() from count logic to prevent timeouts.
──────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	preferredPhase string,
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	db := r.db.WithContext(ctx)

	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	// OPTIMIZATION: Use simple GROUP BY to count unique assets.
	// This avoids the window function overhead that caused the timeout.
	sql := `
SELECT COUNT(*) FROM (
	SELECT 1
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0` + nameCond + statusWhere + `
	GROUP BY project, root, group_1, relation
) AS count_table`

	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)

	var total int64
	if err := db.Raw(sql, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}

	return total, nil
}

/*
──────────────────────────────────────────────────────────────────────────
	ListLatestSubmissionsDynamic
	FIX: Simplified the inner FK selection to prevent deadline exceeded.
──────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	orderClauseWindow := buildOrderClause("", orderKey, direction)
	orderClauseInner := buildOrderClause("b", orderKey, direction)

	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	// Simplified keys selection
	keysSQL := `
SELECT project, root, group_1, relation
FROM t_review_info
WHERE project = ? AND root = ? AND deleted = 0` + nameCond + statusWhere + `
GROUP BY project, root, group_1, relation`

	q := fmt.Sprintf(`
WITH ordered AS (
  SELECT *, ROW_NUMBER() OVER (ORDER BY %s) AS _order
  FROM (
    SELECT b.*
    FROM (
      SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
      GROUP BY project, root, group_1, relation, phase
    ) AS a
    LEFT JOIN t_review_info AS b
      ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1 
      AND a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc
    INNER JOIN ( %s ) AS fk
      ON b.project = fk.project AND b.root = fk.root 
      AND b.group_1 = fk.group_1 AND b.relation = fk.relation
    ORDER BY %s
  ) AS k
),
ranked AS (
  SELECT b.*,
    ROW_NUMBER() OVER (
      PARTITION BY b.root, b.project, b.group_1, b.relation
      ORDER BY CASE WHEN ? = 1 THEN 0 WHEN b.phase = ? THEN 0 ELSE 1 END,
      LOWER(b.group_1) ASC, LOWER(b.relation) ASC, b.modified_at_utc DESC
    ) AS _rank,
    CASE WHEN ? = 1 THEN _order WHEN phase = ? THEN _order ELSE 100000 + _order END AS __order
  FROM ordered b
)
SELECT root, project, group_1, relation, phase, submitted_at_utc
FROM ranked
WHERE _rank = 1
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, orderClauseWindow, keysSQL, orderClauseInner)

	args := []any{project, root, project, root, phaseGuard, preferredPhase, phaseGuard, preferredPhase, limit, offset}
	// ... [Insert nameArg and statusArgs into the correct slice position] ...

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}

/*
──────────────────────────────────────────────────────────────────────────
	ListAssetsPivot
	FIX: Filter-Before-Join strategy to handle large per_page counts.
──────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	total, err := r.CountLatestSubmissions(ctx, project, root, assetNameKey, preferredPhase, approvalStatuses, workStatuses)
	if err != nil {
		return nil, 0, err
	}

	keys, err := r.ListLatestSubmissionsDynamic(ctx, project, root, preferredPhase, orderKey, direction, limit, offset, assetNameKey, approvalStatuses, workStatuses)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	var sb strings.Builder
	var params []any
	sb.WriteString("WITH ranked AS ( SELECT ri.*, ROW_NUMBER() OVER (PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase ORDER BY ri.modified_at_utc DESC) AS rn FROM t_review_info AS ri WHERE ri.project = ? AND ri.root = ? AND ri.deleted = 0 AND (")
	params = append(params, project, root)

	for i, k := range keys {
		if i > 0 { sb.WriteString(" OR ") }
		sb.WriteString("(ri.group_1 = ? AND ri.relation = ?)")
		params = append(params, k.Group1, k.Relation)
	}

	sb.WriteString(` ) ),
latest_only AS ( SELECT * FROM ranked WHERE rn = 1 )
SELECT lo.*, JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]')) AS leaf_group_name,
gc.path AS group_category_path, SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
FROM latest_only lo
LEFT JOIN t_group_category_group gcg ON gcg.project = lo.project AND gcg.deleted = 0 AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]'))
LEFT JOIN t_group_category gc ON gc.id = gcg.group_category_id AND gc.deleted = 0 AND gc.root = 'assets'`)

	var phases []phaseRow
	if err := r.db.WithContext(ctx).Raw(sb.String(), params...).Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// ... [Keep the stitching logic from your original code] ...
	return ordered, total, nil
}
