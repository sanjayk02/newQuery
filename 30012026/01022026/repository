package repository

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"gorm.io/gorm"
)

//
// ========================================================================
// ============================== CONSTANTS ================================
// ========================================================================
//

type SortDirection string

const (
	SortASC  SortDirection = "ASC"
	SortDESC SortDirection = "DESC"

	DefaultRoot   = "assets"
	DefaultLimit  = 60
	DefaultOffset = 0

	GroupsJSONField = "`groups`"
)

//
// ========================================================================
// ============================== MODELS ==================================
// ========================================================================
//

type AssetPivot struct {
	Root     string `json:"root"`
	Project  string `json:"project"`
	Group1   string `json:"group_1"`
	Relation string `json:"relation"`

	LeafGroupName     string `json:"leaf_group_name"`
	GroupCategoryPath string `json:"group_category_path"`
	TopGroupNode      string `json:"top_group_node"`

	MDLWorkStatus     *string    `json:"mdl_work_status"`
	MDLApprovalStatus *string    `json:"mdl_approval_status"`
	MDLSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

	RIGWorkStatus     *string    `json:"rig_work_status"`
	RIGApprovalStatus *string    `json:"rig_approval_status"`
	RIGSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

	BLDWorkStatus     *string    `json:"bld_work_status"`
	BLDApprovalStatus *string    `json:"bld_approval_status"`
	BLDSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

	DSNWorkStatus     *string    `json:"dsn_work_status"`
	DSNApprovalStatus *string    `json:"dsn_approval_status"`
	DSNSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

	LDVWorkStatus     *string    `json:"ldv_work_status"`
	LDVApprovalStatus *string    `json:"ldv_approval_status"`
	LDVSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`
}

type GroupedAssetBucket struct {
	TopGroupNode string       `json:"top_group_node"`
	Items        []AssetPivot `json:"items"`
}

type CategoryInfo struct {
	Path     string
	TopGroup string
}

//
// ========================================================================
// ============================ REPOSITORY ================================
// ========================================================================
//

type ReviewInfo struct {
	db *gorm.DB
}

func NewReviewInfo(db *gorm.DB) *ReviewInfo {
	return &ReviewInfo{db: db}
}

//
// ========================================================================
// ======================= GROUPED VIEW SUPPORT ===========================
// ========================================================================
//

func GroupAndSortByTopNode(rows []AssetPivot, dir SortDirection) []GroupedAssetBucket {
	grouped := map[string][]AssetPivot{}
	order := []string{}

	for _, r := range rows {
		key := strings.TrimSpace(r.TopGroupNode)
		if key == "" {
			key = "Unassigned"
		}
		if _, ok := grouped[key]; !ok {
			order = append(order, key)
		}
		grouped[key] = append(grouped[key], r)
	}

	sort.Slice(order, func(i, j int) bool {
		a, b := strings.ToLower(order[i]), strings.ToLower(order[j])
		if a == "unassigned" {
			return true
		}
		if b == "unassigned" {
			return false
		}
		return a < b
	})

	out := make([]GroupedAssetBucket, 0, len(order))
	for _, k := range order {
		items := grouped[k]
		sort.Slice(items, func(i, j int) bool {
			return strings.ToLower(items[i].Group1) < strings.ToLower(items[j].Group1)
		})
		out = append(out, GroupedAssetBucket{
			TopGroupNode: k,
			Items:        items,
		})
	}
	return out
}

//
// ========================================================================
// ======================= CATEGORY RESOLUTION ============================
// ========================================================================
//

func (r *ReviewInfo) loadCategoryMap(
	ctx context.Context,
	project string,
) (map[string]CategoryInfo, error) {

	type row struct {
		Path string
	}

	var rows []row
	if err := r.db.WithContext(ctx).
		Table("t_group_category_group").
		Select("path").
		Where("project = ? AND deleted = 0", project).
		Scan(&rows).Error; err != nil {
		return nil, err
	}

	m := make(map[string]CategoryInfo, len(rows))
	for _, r := range rows {
		top := r.Path
		if i := strings.Index(top, "/"); i > 0 {
			top = top[:i]
		}
		m[r.Path] = CategoryInfo{
			Path:     r.Path,
			TopGroup: top,
		}
	}
	return m, nil
}

//
// ========================================================================
// ============================ ORDER BY ==================================
// ========================================================================
//

func buildOrderClause(dir string) string {
	if strings.ToUpper(dir) == "DESC" {
		return "LOWER(group_1) DESC, LOWER(relation) ASC"
	}
	return "LOWER(group_1) ASC, LOWER(relation) ASC"
}

//
// ========================================================================
// ========================== MAIN PIVOT QUERY ============================
// ========================================================================
//

func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, _, _, direction string,
	limit, offset int,
	assetNameKey string,
	_, _ []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = DefaultRoot
	}
	if limit <= 0 {
		limit = DefaultLimit
	}
	if offset < 0 {
		offset = DefaultOffset
	}

	where := []string{
		"ri.project = ?",
		"ri.root = ?",
		"ri.deleted = 0",
	}
	args := []any{project, root}

	if assetNameKey != "" {
		where = append(where, "LOWER(ri.group_1) LIKE ?")
		args = append(args, strings.ToLower(assetNameKey)+"%")
	}

	whereSQL := strings.Join(where, " AND ")
	orderSQL := buildOrderClause(direction)

	sql := fmt.Sprintf(`
WITH base AS (
    SELECT
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase,
        ri.work_status,
        ri.approval_status,
        ri.submitted_at_utc,
        ri.modified_at_utc,

        -- JSON used ONLY for projection (SAFE)
        JSON_UNQUOTE(JSON_EXTRACT(ri.%s,'$[0]')) AS leaf_group_name,

        ROW_NUMBER() OVER (
            PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
            ORDER BY ri.modified_at_utc DESC
        ) AS rn
    FROM t_review_info ri
    WHERE %s
),
latest AS (
    SELECT * FROM base WHERE rn = 1
),
asset_keys AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        MAX(submitted_at_utc) AS latest_submitted_at
    FROM latest
    GROUP BY project, root, group_1, relation
),
ordered AS (
    SELECT *,
           ROW_NUMBER() OVER (ORDER BY %s) AS rownum,
           COUNT(*) OVER () AS total_count
    FROM asset_keys
)
SELECT
    l.project,
    l.root,
    l.group_1,
    l.relation,
    l.leaf_group_name,
    MAX(o.total_count) AS total_count,

    MAX(CASE WHEN l.phase='mdl' THEN l.work_status END)      AS mdl_work_status,
    MAX(CASE WHEN l.phase='mdl' THEN l.approval_status END)  AS mdl_approval_status,
    MAX(CASE WHEN l.phase='mdl' THEN l.submitted_at_utc END) AS mdl_submitted_at_utc,

    MAX(CASE WHEN l.phase='rig' THEN l.work_status END)      AS rig_work_status,
    MAX(CASE WHEN l.phase='rig' THEN l.approval_status END)  AS rig_approval_status,
    MAX(CASE WHEN l.phase='rig' THEN l.submitted_at_utc END) AS rig_submitted_at_utc,

    MAX(CASE WHEN l.phase='bld' THEN l.work_status END)      AS bld_work_status,
    MAX(CASE WHEN l.phase='bld' THEN l.approval_status END)  AS bld_approval_status,
    MAX(CASE WHEN l.phase='bld' THEN l.submitted_at_utc END) AS bld_submitted_at_utc,

    MAX(CASE WHEN l.phase='dsn' THEN l.work_status END)      AS dsn_work_status,
    MAX(CASE WHEN l.phase='dsn' THEN l.approval_status END)  AS dsn_approval_status,
    MAX(CASE WHEN l.phase='dsn' THEN l.submitted_at_utc END) AS dsn_submitted_at_utc,

    MAX(CASE WHEN l.phase='ldv' THEN l.work_status END)      AS ldv_work_status,
    MAX(CASE WHEN l.phase='ldv' THEN l.approval_status END)  AS ldv_approval_status,
    MAX(CASE WHEN l.phase='ldv' THEN l.submitted_at_utc END) AS ldv_submitted_at_utc

FROM ordered o
JOIN latest l
  ON l.project=o.project
 AND l.root=o.root
 AND l.group_1=o.group_1
 AND l.relation=o.relation
WHERE o.rownum > ? AND o.rownum <= ?
GROUP BY
    l.project, l.root, l.group_1, l.relation, l.leaf_group_name
ORDER BY o.rownum;
`,
		GroupsJSONField,
		whereSQL,
		orderSQL,
	)

	args = append(args, offset, offset+limit)

	var rows []struct {
		AssetPivot
		Total int64 `gorm:"column:total_count"`
	}

	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	catMap, _ := r.loadCategoryMap(ctx, project)

	out := make([]AssetPivot, len(rows))
	for i, r := range rows {
		out[i] = r.AssetPivot
		if c, ok := catMap[out[i].LeafGroupName]; ok {
			out[i].GroupCategoryPath = c.Path
			out[i].TopGroupNode = c.TopGroup
		}
	}

	total := int64(0)
	if len(rows) > 0 {
		total = rows[0].Total
	}

	return out, total, nil
}
