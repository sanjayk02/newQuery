/* ========================================================
   Assets Pivot API (Updated with Options Struct)
======================================================== */
router.GET("/api/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
	project := strings.TrimSpace(c.Param("project"))
	if project == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
		return
	}

	root := c.DefaultQuery("root", defaultRoot)

	// ---- Phase Validation ----
	phaseParam := strings.TrimSpace(c.Query("phase"))
	phases := []string{}
	if phaseParam != "" {
		lp := strings.ToLower(phaseParam)
		if lp != "none" {
			if _, ok := allowedPhases[lp]; !ok {
				c.JSON(http.StatusBadRequest, gin.H{
					"error":          "invalid phase",
					"allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
				})
				return
			}
			phases = []string{lp}
		}
	}

	// ---- Pagination ----
	page := mustAtoi(c.DefaultQuery("page", "1"))
	page = int(math.Max(float64(page), 1))
	perPage := clampPerPage(mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage))))
	limit := perPage
	offset := (page - 1) * perPage

	// ---- Sorting ----
	sortParam := c.DefaultQuery("sort", "group_1")
	dirParam := c.DefaultQuery("dir", "ASC")
	orderKey := normalizeSortKey(sortParam)
	dir := normalizeDir(dirParam)

	// ---- View Mode ----
	viewParam := strings.ToLower(strings.TrimSpace(c.DefaultQuery("view", "list")))
	isGroupedView := viewParam == "group" || viewParam == "grouped" || viewParam == "category"

	// ---- Filters ----
	assetNameKey := strings.TrimSpace(c.Query("name"))
	approvalStatuses := parseStatusParam(c, "approval_status")
	workStatuses := parseStatusParam(c, "work_status")
	
	// Parse group paths if provided
	groupPaths := []string{}
	if groupPathsParam := c.Query("group_paths"); groupPathsParam != "" {
		groupPaths = strings.Split(groupPathsParam, ",")
		for i, path := range groupPaths {
			groupPaths[i] = strings.TrimSpace(path)
		}
	}

	// ---- Preferred Phase Logic ----
	preferredPhase := phaseParam
	if orderKey == "group1_only" || orderKey == "relation_only" || orderKey == "group_rel_submitted" {
		preferredPhase = "none"
	}
	if preferredPhase == "" {
		preferredPhase = "none"
	}

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	// ====================================================================
	// CREATE OPTIONS STRUCT - Updated for new repository
	// ====================================================================
	opts := repository.ListAssetsPivotOptions{
		Project:          project,
		Root:             root,
		PreferredPhase:   preferredPhase,
		OrderKey:         orderKey,
		Direction:        dir,
		Limit:            limit,
		Offset:           offset,
		AssetNameKey:     assetNameKey,
		ApprovalStatuses: approvalStatuses,
		WorkStatuses:     workStatuses,
		Phases:           phases,
		GroupPaths:       groupPaths,
	}

	// ---------------------------------------------------------------
	// CASE 1: LIST VIEW - keep current DB pagination behavior
	// ---------------------------------------------------------------
	if !isGroupedView {
		assets, total, err := reviewInfoRepository.ListAssetsPivot(ctx, opts)
		if err != nil {
			// Enhanced error handling
			if strings.Contains(err.Error(), "invalid sort direction") {
				c.JSON(http.StatusBadRequest, gin.H{
					"error":              err.Error(),
					"allowed_directions": []string{"ASC", "DESC"},
				})
				return
			}
			
			log.Printf("[pivot-submissions] query error for project %q: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			return
		}

		c.Header("Cache-Control", "public, max-age=15")
		baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
		if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
			c.Header("Link", links)
		}

		resp := gin.H{
			"assets":    assets,
			"total":     total,
			"page":      page,
			"per_page":  perPage,
			"sort":      sortParam,
			"dir":       strings.ToLower(dir),
			"project":   project,
			"root":      root,
			"has_next":  offset+limit < int(total),
			"has_prev":  page > 1,
			"page_last": (int(total) + perPage - 1) / perPage,
			"view":      viewParam,
		}
		
		// Add optional fields
		if phaseParam != "" {
			resp["phase"] = phaseParam
		}
		if assetNameKey != "" {
			resp["name"] = assetNameKey
		}
		if len(approvalStatuses) > 0 {
			resp["approval_status"] = approvalStatuses
		}
		if len(workStatuses) > 0 {
			resp["work_status"] = workStatuses
		}
		if len(groupPaths) > 0 {
			resp["group_paths"] = groupPaths
		}

		c.IndentedJSON(http.StatusOK, resp)
		return
	}

	// ---------------------------------------------------------------
	// CASE 2: GROUPED VIEW - group first, then paginate
	// ---------------------------------------------------------------

	// 1) Fetch ALL matching assets (no pagination here)
	allLimit := 1000000
	allOpts := repository.ListAssetsPivotOptions{
		Project:          project,
		Root:             root,
		PreferredPhase:   preferredPhase,
		OrderKey:         "group1_only", // stable order by name for grouping
		Direction:        "ASC",
		Limit:            allLimit,
		Offset:           0,
		AssetNameKey:     assetNameKey,
		ApprovalStatuses: approvalStatuses,
		WorkStatuses:     workStatuses,
		Phases:           phases,
		GroupPaths:       groupPaths,
	}
	
	assetsAll, total, err := reviewInfoRepository.ListAssetsPivot(ctx, allOpts)
	if err != nil {
		log.Printf("[pivot-submissions] query error (group view) for project %q: %v", project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
		return
	}

	// 2) Group ALL assets by top_group_node
	dirUpper := strings.ToUpper(dir)
	if dirUpper != "ASC" && dirUpper != "DESC" {
		dirUpper = "ASC"
	}
	groupedAll := repository.GroupAndSortByTopNode(
		assetsAll,
		repository.SortDirection(dirUpper),
	)

	// 3) Flatten groups in that order → flat slice in group order
	flat := make([]repository.AssetPivot, 0, len(assetsAll))
	for _, g := range groupedAll {
		flat = append(flat, g.Items...)
	}

	// 4) Apply pagination on the flat, grouped-ordered slice
	totalAssets := len(flat)
	start := offset
	if start > totalAssets {
		start = totalAssets
	}
	end := start + limit
	if end > totalAssets {
		end = totalAssets
	}
	pageSlice := flat[start:end]

	// 5) Re-group only the current page slice
	pageGroups := repository.GroupAndSortByTopNode(
		pageSlice,
		repository.SortDirection(dirUpper),
	)

	// ---- Headers ----
	c.Header("Cache-Control", "public, max-age=15")
	baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
	if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
		c.Header("Link", links)
	}

	// ---- Response ----
	resp := gin.H{
		"assets":    pageSlice, // optional: keep flat slice for debugging / UI
		"groups":    pageGroups,
		"total":     total, // total number of matching assets
		"page":      page,
		"per_page":  perPage,
		"sort":      sortParam,
		"dir":       strings.ToLower(dir),
		"project":   project,
		"root":      root,
		"has_next":  offset+limit < int(totalAssets),
		"has_prev":  page > 1,
		"page_last": (int(totalAssets) + perPage - 1) / perPage,
		"view":      viewParam,
	}

	// Add optional fields
	if phaseParam != "" {
		resp["phase"] = phaseParam
	}
	if assetNameKey != "" {
		resp["name"] = assetNameKey
	}
	if len(approvalStatuses) > 0 {
		resp["approval_status"] = approvalStatuses
	}
	if len(workStatuses) > 0 {
		resp["work_status"] = workStatuses
	}
	if len(groupPaths) > 0 {
		resp["group_paths"] = groupPaths
	}

	c.IndentedJSON(http.StatusOK, resp)
})

// ==============================================================================================================
// Maps frontend sort keys → backend order keys
// ==============================================================================================================
func normalizeSortKey(key string) string {
	key = strings.TrimSpace(strings.ToLower(key))

	switch key {
	case "group_1", "group1", "name":
		return repository.OrderKeyGroupOnly

	case "relation":
		return repository.OrderKeyRelationOnly

	case "group_rel":
		return repository.OrderKeyGroupRelSubmitted

	case "submitted", "submitted_at", "submitted_at_utc":
		return "submitted_at_utc"

	case "mdl_work":
		return "mdl_work"
	case "rig_work":
		return "rig_work"
	case "bld_work":
		return "bld_work"
	case "dsn_work":
		return "dsn_work"
	case "ldv_work":
		return "ldv_work"

	case "mdl_appr":
		return "mdl_appr"
	case "rig_appr":
		return "rig_appr"
	case "bld_appr":
		return "bld_appr"
	case "dsn_appr":
		return "dsn_appr"
	case "ldv_appr":
		return "ldv_appr"

	case "mdl_submitted":
		return repository.OrderKeyMDLSubmitted
	case "rig_submitted":
		return repository.OrderKeyRIGSubmitted
	case "bld_submitted":
		return repository.OrderKeyBLDSubmitted
	case "dsn_submitted":
		return repository.OrderKeyDSNSubmitted
	case "ldv_submitted":
		return repository.OrderKeyLDVSubmitted

	default:
		return repository.OrderKeyGroupOnly
	}
}

// ==============================================================================================================
func paginationLinks(baseURL string, page, perPage, total int, queryParams ...url.Values) string {
	if total <= 0 {
		return ""
	}

	lastPage := int(math.Ceil(float64(total) / float64(perPage)))
	if lastPage < 1 {
		lastPage = 1
	}

	var links []string
	
	// Helper to build URL with query params
	buildURL := func(pageNum int) string {
		params := url.Values{}
		
		// Add existing query parameters if provided
		if len(queryParams) > 0 && queryParams[0] != nil {
			for key, values := range queryParams[0] {
				for _, value := range values {
					params.Add(key, value)
				}
			}
		}
		
		// Add pagination params
		params.Set("page", fmt.Sprint(pageNum))
		params.Set("per_page", fmt.Sprint(perPage))
		
		return fmt.Sprintf("%s?%s", baseURL, params.Encode())
	}

	if page > 1 {
		links = append(links,
			fmt.Sprintf(`<%s>; rel="first"`, buildURL(1)),
			fmt.Sprintf(`<%s>; rel="prev"`, buildURL(page-1)),
		)
	}

	if page < lastPage {
		links = append(links,
			fmt.Sprintf(`<%s>; rel="next"`, buildURL(page+1)),
			fmt.Sprintf(`<%s>; rel="last"`, buildURL(lastPage)),
		)
	}

	return strings.Join(links, ", ")
}

// ==============================================================================================================
// In the handler, add this function to extract query params:
// ==============================================================================================================
func extractQueryParams(c *gin.Context) url.Values {
	params := url.Values{}
	
	for key, values := range c.Request.URL.Query() {
		// Skip pagination parameters for link generation
		if key != "page" && key != "per_page" {
			for _, value := range values {
				params.Add(key, value)
			}
		}
	}
	
	return params
}

// Then in the handler, use it:
queryParams := extractQueryParams(c)
if links := paginationLinks(baseURL, page, perPage, int(total), queryParams); links != "" {
	c.Header("Link", links)
}
