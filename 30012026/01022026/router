// Assets Pivot API handler - updated for refactored repository
router.GET("/api/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
    project := strings.TrimSpace(c.Param("project"))
    if project == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
        return
    }

    root := c.DefaultQuery("root", repository.DefaultRoot)

    // ---- Phase Validation ----
    phaseParam := strings.TrimSpace(c.Query("phase"))
    phases := []string{} // Initialize empty phases slice
    if phaseParam != "" {
        lp := strings.ToLower(phaseParam)
        if lp != "none" {
            // Validate single phase
            switch lp {
            case repository.PhaseMDL, repository.PhaseRIG, repository.PhaseBLD,
                repository.PhaseDSN, repository.PhaseLDV:
                phases = []string{lp} // Include this phase only
            default:
                c.JSON(http.StatusBadRequest, gin.H{
                    "error":          "invalid phase",
                    "allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
                })
                return
            }
        }
        // If phase is "none", keep phases empty to get all phases
    }

    // ---- Pagination ----
    page := mustAtoi(c.DefaultQuery("page", "1"))
    page = int(math.Max(float64(page), 1))
    perPage := clampPerPage(mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage))))
    limit := perPage
    offset := (page - 1) * perPage

    // ---- Sorting ----
    sortParam := c.DefaultQuery("sort", "group_1")
    dirParam := c.DefaultQuery("dir", "ASC")
    orderKey := normalizeSortKey(sortParam)
    dir := normalizeDir(dirParam)

    // ---- View Mode ----
    viewParam := strings.ToLower(strings.TrimSpace(c.DefaultQuery("view", "list")))
    isGroupedView := viewParam == "group" || viewParam == "grouped" || viewParam == "category"

    // ---- Filters ----
    assetNameKey := strings.TrimSpace(c.Query("name"))
    approvalStatuses := parseStatusParam(c, "approval_status")
    workStatuses := parseStatusParam(c, "work_status")
    
    // Parse group paths if provided
    groupPaths := []string{}
    if groupPathsParam := c.Query("group_paths"); groupPathsParam != "" {
        groupPaths = strings.Split(groupPathsParam, ",")
        // Trim whitespace from each path
        for i, path := range groupPaths {
            groupPaths[i] = strings.TrimSpace(path)
        }
    }

    // ---- Preferred Phase Logic ----
    preferredPhase := phaseParam
    if orderKey == repository.OrderKeyGroupOnly || 
       orderKey == repository.OrderKeyRelationOnly || 
       orderKey == repository.OrderKeyGroupRelSubmitted {
        preferredPhase = "none"
    }
    if preferredPhase == "" {
        preferredPhase = "none"
    }

    ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
    defer cancel()

    // ---------------------------------------------------------------
    // SINGLE EFFICIENT QUERY CALL WITH REFACTORED REPOSITORY
    // ---------------------------------------------------------------
    opts := repository.ListAssetsPivotOptions{
        Project:          project,
        Root:             root,
        PreferredPhase:   preferredPhase,
        OrderKey:         orderKey,
        Direction:        dir,
        Limit:            limit,
        Offset:           offset,
        AssetNameKey:     assetNameKey,
        ApprovalStatuses: approvalStatuses,
        WorkStatuses:     workStatuses,
        Phases:           phases,
        GroupPaths:       groupPaths,
    }

    assets, total, err := reviewInfoRepository.ListAssetsPivot(ctx, opts)
    if err != nil {
        log.Printf("[pivot-submissions] query error for project %q: %v", project, err)
        
        // Provide more specific error messages
        if strings.Contains(err.Error(), "invalid sort direction") {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
                "allowed_directions": []string{"ASC", "DESC"},
            })
            return
        }
        
        c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
        return
    }

    // Prepare response
    response := gin.H{
        "assets":    assets,
        "total":     total,
        "page":      page,
        "per_page":  perPage,
        "sort":      sortParam,
        "dir":       strings.ToLower(dir),
        "project":   project,
        "root":      root,
        "has_next":  offset+limit < int(total),
        "has_prev":  page > 1,
        "page_last": (int(total) + perPage - 1) / perPage,
        "view":      viewParam,
    }

    // Add optional fields
    if phaseParam != "" {
        response["phase"] = phaseParam
    }
    if assetNameKey != "" {
        response["name"] = assetNameKey
    }
    if len(approvalStatuses) > 0 {
        response["approval_status"] = approvalStatuses
    }
    if len(workStatuses) > 0 {
        response["work_status"] = workStatuses
    }
    if len(groupPaths) > 0 {
        response["group_paths"] = groupPaths
    }

    // For grouped view, apply grouping to the already-paginated results
    if isGroupedView {
        dirUpper := strings.ToUpper(dir)
        if dirUpper != "ASC" && dirUpper != "DESC" {
            dirUpper = "ASC"
        }
        grouped := repository.GroupAndSortByTopNode(
            assets,
            repository.SortDirection(dirUpper),
        )
        response["groups"] = grouped
        
        // Add group summary statistics
        response["group_summary"] = calculateGroupSummary(grouped)
    }

    // ---- Headers ----
    c.Header("Cache-Control", "public, max-age=15")
    baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
    
    // Build query parameters for pagination links
    queryParams := buildQueryParams(c)
    if links := paginationLinks(baseURL, page, perPage, int(total), queryParams); links != "" {
        c.Header("Link", links)
    }

    c.IndentedJSON(http.StatusOK, response)
})

// Helper functions needed for the API handler:

func mustAtoi(s string) int {
    if s == "" {
        return 0
    }
    i, err := strconv.Atoi(s)
    if err != nil {
        return 0
    }
    return i
}

func clampPerPage(n int) int {
    if n <= 0 {
        return repository.DefaultLimit
    }
    if n > 500 { // Set a reasonable maximum
        return 500
    }
    return n
}

func normalizeSortKey(key string) string {
    switch strings.ToLower(key) {
    case "relation":
        return repository.OrderKeyRelationOnly
    case "group_rel_submitted":
        return repository.OrderKeyGroupRelSubmitted
    case "mdl_submitted":
        return repository.OrderKeyMDLSubmitted
    case "rig_submitted":
        return repository.OrderKeyRIGSubmitted
    case "bld_submitted":
        return repository.OrderKeyBLDSubmitted
    case "dsn_submitted":
        return repository.OrderKeyDSNSubmitted
    case "ldv_submitted":
        return repository.OrderKeyLDVSubmitted
    default: // "group_1", "group", "name"
        return repository.OrderKeyGroupOnly
    }
}

func normalizeDir(dir string) string {
    upper := strings.ToUpper(dir)
    if upper == "ASC" || upper == "DESC" {
        return upper
    }
    return "ASC"
}

func parseStatusParam(c *gin.Context, paramName string) []string {
    statusParam := c.Query(paramName)
    if statusParam == "" {
        return []string{}
    }
    
    // Handle comma-separated values
    statuses := strings.Split(statusParam, ",")
    result := make([]string, 0, len(statuses))
    
    for _, status := range statuses {
        trimmed := strings.TrimSpace(status)
        if trimmed != "" {
            result = append(result, strings.ToLower(trimmed))
        }
    }
    
    return result
}

func calculateGroupSummary(groups []repository.GroupedAssetBucket) gin.H {
    summary := gin.H{
        "total_groups": len(groups),
        "total_assets": 0,
        "groups":       make([]gin.H, 0, len(groups)),
    }
    
    for _, group := range groups {
        assetCount := len(group.Items)
        summary["total_assets"] = summary["total_assets"].(int) + assetCount
        
        // Calculate per-group statistics
        groupStats := gin.H{
            "name":        group.TopGroupNode,
            "asset_count": assetCount,
            "phases":      make(gin.H),
        }
        
        // Count assets by phase status
        phaseStats := make(map[string]map[string]int)
        for _, asset := range group.Items {
            // Count by MDL status
            if asset.MDLApprovalStatus != nil {
                status := *asset.MDLApprovalStatus
                if phaseStats["mdl"] == nil {
                    phaseStats["mdl"] = make(map[string]int)
                }
                phaseStats["mdl"][status]++
            }
            // Add other phases as needed...
        }
        
        // Convert phase stats to gin.H
        for phase, stats := range phaseStats {
            groupStats["phases"].(gin.H)[phase] = stats
        }
        
        summary["groups"] = append(summary["groups"].([]gin.H), groupStats)
    }
    
    return summary
}

func buildQueryParams(c *gin.Context) url.Values {
    params := url.Values{}
    
    // Add all query parameters except pagination ones
    for key, values := range c.Request.URL.Query() {
        if key != "page" && key != "per_page" {
            for _, value := range values {
                params.Add(key, value)
            }
        }
    }
    
    return params
}

func paginationLinks(baseURL string, page, perPage, total int, queryParams url.Values) string {
    if total == 0 || perPage == 0 {
        return ""
    }
    
    lastPage := (total + perPage - 1) / perPage
    if lastPage < 1 {
        lastPage = 1
    }
    
    var links []string
    
    // Helper function to build URL with query params
    buildURL := func(pageNum int) string {
        params := queryParams
        params.Set("page", fmt.Sprint(pageNum))
        params.Set("per_page", fmt.Sprint(perPage))
        return fmt.Sprintf("%s?%s", baseURL, params.Encode())
    }
    
    // First page
    if page > 1 {
        links = append(links, fmt.Sprintf(`<%s>; rel="first"`, buildURL(1)))
    }
    
    // Previous page
    if page > 1 {
        links = append(links, fmt.Sprintf(`<%s>; rel="prev"`, buildURL(page-1)))
    }
    
    // Next page
    if page < lastPage {
        links = append(links, fmt.Sprintf(`<%s>; rel="next"`, buildURL(page+1)))
    }
    
    // Last page
    if page < lastPage {
        links = append(links, fmt.Sprintf(`<%s>; rel="last"`, buildURL(lastPage)))
    }
    
    return strings.Join(links, ", ")
}
