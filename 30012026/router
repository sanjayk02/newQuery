/* ========================================================
   Assets Pivot API (Expanded Implementation)
======================================================== */
router.GET("/api/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
    project := strings.TrimSpace(c.Param("project"))
    if project == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
        return
    }

    // ---- OPTIMIZATION: Check for known problematic projects ----
    problematicProjects := map[string]bool{
        "hm": true, // Project "hm" has performance issues
    }
    
    if problematicProjects[project] {
        // For problematic projects, enforce stricter limits
        perPageRequested := mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage)))
        if perPageRequested > 50 {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": "For this project, maximum per_page is 50 due to performance constraints",
                "max_per_page": 50,
                "suggestion": fmt.Sprintf("Use ?per_page=50&page=%d", page),
            })
            return
        }
    }

    root := c.DefaultQuery("root", defaultRoot)

    // ---- Phase Validation ----
    phaseParam := strings.TrimSpace(c.Query("phase"))
    if phaseParam != "" {
        lp := strings.ToLower(phaseParam)
        if lp != "none" {
            if _, ok := allowedPhases[lp]; !ok {
                c.JSON(http.StatusBadRequest, gin.H{
                    "error":          "invalid phase",
                    "allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
                })
                return
            }
        }
    }

    // ---- Pagination ----
    page := mustAtoi(c.DefaultQuery("page", "1"))
    page = int(math.Max(float64(page), 1))
    
    // OPTIMIZATION: Reduce page size for large projects
    maxPerPage := defaultPerPage
    if problematicProjects[project] {
        maxPerPage = 50 // Reduced from 200
    }
    
    perPage := clampPerPage(mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage))))
    if perPage > maxPerPage {
        perPage = maxPerPage
    }
    
    limit := perPage
    offset := (page - 1) * perPage

    // ---- OPTIMIZATION: Prevent deep pagination for large projects ----
    if problematicProjects[project] && page > 50 {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Deep pagination is disabled for this project due to performance",
            "max_page": 50,
            "suggestion": "Use filters to reduce result set size",
        })
        return
    }

    // ---- Sorting ----
    sortParam := c.DefaultQuery("sort", "group_1")
    dirParam := c.DefaultQuery("dir", "ASC")
    orderKey := normalizeSortKey(sortParam)
    dir := normalizeDir(dirParam)

    // ---- View Mode ----
    viewParam := strings.ToLower(strings.TrimSpace(c.DefaultQuery("view", "list")))
    isGroupedView := viewParam == "group" || viewParam == "grouped" || viewParam == "category"
    
    // OPTIMIZATION: Disable grouped view for problematic projects
    if problematicProjects[project] && isGroupedView {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Grouped view is disabled for this project",
            "project": project,
            "auto_redirect": fmt.Sprintf("/api/projects/%s/reviews/assets/pivot?view=list", project),
        })
        return
    }

    // ---- Filters ----
    assetNameKey := strings.TrimSpace(c.Query("name"))
    approvalStatuses := parseStatusParam(c, "approval_status")
    workStatuses := parseStatusParam(c, "work_status")
    
    // OPTIMIZATION: Require at least one filter for large projects
    if problematicProjects[project] && assetNameKey == "" && len(approvalStatuses) == 0 && len(workStatuses) == 0 {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "For this project, at least one filter is required",
            "required_filters": []string{"name", "approval_status", "work_status"},
            "example": "/api/projects/hm/reviews/assets/pivot?name=char&per_page=20",
        })
        return
    }

    // ---- Preferred Phase Logic ----
    preferredPhase := phaseParam
    if orderKey == "group1_only" || orderKey == "relation_only" || orderKey == "group_rel_submitted" {
        preferredPhase = "none"
    }
    if preferredPhase == "" {
        preferredPhase = "none"
    }

    // ---- Create context with timeout ----
    ctx, cancel := context.WithTimeout(c.Request.Context(), 15*time.Second)
    defer cancel()

    // ---------------------------------------------------------------
    // CASE 1: LIST VIEW
    // ---------------------------------------------------------------
    if !isGroupedView {
        assets, total, err := reviewInfoRepository.ListAssetsPivot(
            ctx,
            project, root,
            preferredPhase,
            orderKey,
            dir,
            limit, offset,
            assetNameKey,
            approvalStatuses,
            workStatuses,
        )
        
        if err != nil {
            if errors.Is(err, context.DeadlineExceeded) {
                log.Printf("[pivot-submissions] Query timeout for project %q (page %d): %v", project, page, err)
                
                // Try with even smaller page size
                if limit > 20 {
                    log.Printf("[pivot-submissions] Retrying with smaller page size for project %q", project)
                    smallerLimit := 20
                    smallerOffset := (page - 1) * smallerLimit
                    
                    retryCtx, retryCancel := context.WithTimeout(context.Background(), 10*time.Second)
                    assets, total, err = reviewInfoRepository.ListAssetsPivot(
                        retryCtx,
                        project, root,
                        preferredPhase,
                        orderKey,
                        dir,
                        smallerLimit, smallerOffset,
                        assetNameKey,
                        approvalStatuses,
                        workStatuses,
                    )
                    retryCancel()
                    
                    if err == nil {
                        // Success with smaller page size
                        perPage = smallerLimit
                        resp := gin.H{
                            "assets":        assets,
                            "total":         total,
                            "page":          page,
                            "per_page":      perPage,
                            "sort":          sortParam,
                            "dir":           strings.ToLower(dir),
                            "project":       project,
                            "root":          root,
                            "has_next":      smallerOffset+smallerLimit < int(total),
                            "has_prev":      page > 1,
                            "page_last":     (int(total) + perPage - 1) / perPage,
                            "view":          viewParam,
                            "warning":       fmt.Sprintf("Using reduced page size (%d) for performance", perPage),
                        }
                        
                        c.IndentedJSON(http.StatusOK, resp)
                        return
                    }
                }
                
                c.JSON(http.StatusRequestTimeout, gin.H{
                    "error": "Query timeout. The dataset is too large for current filters.",
                    "suggestions": []string{
                        "Add a name filter: ?name=char",
                        "Reduce page size: ?per_page=10",
                        "Use status filters: ?approval_status=approved",
                    },
                    "max_per_page": 20,
                })
                return
            }
            
            log.Printf("[pivot-submissions] query error for project %q: %v", project, err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
            return
        }

        c.Header("Cache-Control", "public, max-age=15")
        baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
        if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
            c.Header("Link", links)
        }

        resp := gin.H{
            "assets":    assets,
            "total":     total,
            "page":      page,
            "per_page":  perPage,
            "sort":      sortParam,
            "dir":       strings.ToLower(dir),
            "project":   project,
            "root":      root,
            "has_next":  offset+limit < int(total),
            "has_prev":  page > 1,
            "page_last": (int(total) + perPage - 1) / perPage,
            "view":      viewParam,
        }
        
        if problematicProjects[project] {
            resp["performance_note"] = "Performance mode enabled for this project"
        }
        
        if phaseParam != "" {
            resp["phase"] = phaseParam
        }
        if assetNameKey != "" {
            resp["name"] = assetNameKey
        }
        if len(approvalStatuses) > 0 {
            resp["approval_status"] = approvalStatuses
        }
        if len(workStatuses) > 0 {
            resp["work_status"] = workStatuses
        }

        c.IndentedJSON(http.StatusOK, resp)
        return
    }

    // ---------------------------------------------------------------
    // CASE 2: GROUPED VIEW (only for non-problematic projects)
    // ---------------------------------------------------------------
    
    // This section is only reached for non-problematic projects
    // (Grouped view is disabled for problematic projects earlier)
    
    // Quick count check
    quickCtx, quickCancel := context.WithTimeout(ctx, 3*time.Second)
    estimatedTotal, err := reviewInfoRepository.CountLatestSubmissions(
        quickCtx,
        project,
        root,
        assetNameKey,
        preferredPhase,
        approvalStatuses,
        workStatuses,
    )
    quickCancel()
    
    if err != nil {
        // Count failed, use list view
        log.Printf("[pivot-submissions] Count failed, using list view for project %q", project)
        viewParam = "list"
        isGroupedView = false
        // Fall through to list view logic
    }
    
    const maxSafeGroupingRecords = 2000 // Even lower for safety
    
    if estimatedTotal > int64(maxSafeGroupingRecords) {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": fmt.Sprintf(
                "Too many records (%d) for grouped view.",
                estimatedTotal,
            ),
            "suggestion": "Use view=list or add filters",
        })
        return
    }
    
    // Try grouped view
    groupedCtx, groupedCancel := context.WithTimeout(ctx, 10*time.Second)
    fetchLimit := int(math.Min(float64(estimatedTotal), float64(maxSafeGroupingRecords)))
    if fetchLimit <= 0 {
        fetchLimit = maxSafeGroupingRecords
    }
    
    assetsAll, total, err := reviewInfoRepository.ListAssetsPivot(
        groupedCtx,
        project, root,
        preferredPhase,
        "group1_only",
        "ASC",
        fetchLimit, 0,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    groupedCancel()
    
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            // Fall back to list view
            viewParam = "list"
            isGroupedView = false
        } else {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
            return
        }
    }
    
    // If we fell back to list view, handle it
    if !isGroupedView {
        // Re-fetch with list view pagination
        assets, total, err := reviewInfoRepository.ListAssetsPivot(
            ctx,
            project, root,
            preferredPhase,
            orderKey,
            dir,
            limit, offset,
            assetNameKey,
            approvalStatuses,
            workStatuses,
        )
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
            return
        }
        
        resp := gin.H{
            "assets":        assets,
            "total":         total,
            "page":          page,
            "per_page":      perPage,
            "sort":          sortParam,
            "dir":           strings.ToLower(dir),
            "project":       project,
            "root":          root,
            "has_next":      offset+limit < int(total),
            "has_prev":      page > 1,
            "page_last":     (int(total) + perPage - 1) / perPage,
            "view":          "list",
            "warning":       "Grouped view unavailable. Using list view.",
        }
        
        c.IndentedJSON(http.StatusOK, resp)
        return
    }
    
    // Continue with grouped view logic...
    // [Rest of grouped view logic remains similar but with smaller limits]
    
    // For brevity, including only the critical parts
    dirUpper := strings.ToUpper(dir)
    groupedAll := repository.GroupAndSortByTopNode(
        assetsAll,
        repository.SortDirection(dirUpper),
    )
    
    // ... rest of grouped view logic
    
    c.IndentedJSON(http.StatusOK, resp)
})
