// ========================================================================
// ========= Asset Review Pivot Listing ===================================
// ========================================================================

type LatestSubmissionRow struct {
    Root           string     `json:"root"              gorm:"column:root"`
    Project        string     `json:"project"           gorm:"column:project"`
    Group1         string     `json:"group_1"           gorm:"column:group_1"`
    Relation       string     `json:"relation"          gorm:"column:relation"`
    Phase          string     `json:"phase"             gorm:"column:phase"`
    SubmittedAtUTC *time.Time `json:"submitted_at_utc"  gorm:"column:submitted_at_utc"`
}

// ---- Pivot result ----
// Used by UI for both List View and Group Category View.
type AssetPivot struct {
    Root     string `json:"root"`
    Project  string `json:"project"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`

    // Grouping info
    LeafGroupName     string `json:"leaf_group_name"`
    GroupCategoryPath string `json:"group_category_path"`
    TopGroupNode      string `json:"top_group_node"`

    MDLWorkStatus     *string    `json:"mdl_work_status"`
    MDLApprovalStatus *string    `json:"mdl_approval_status"`
    MDLSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

    RIGWorkStatus     *string    `json:"rig_work_status"`
    RIGApprovalStatus *string    `json:"rig_approval_status"`
    RIGSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

    BLDWorkStatus     *string    `json:"bld_work_status"`
    BLDApprovalStatus *string    `json:"bld_approval_status"`
    BLDSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

    DSNWorkStatus     *string    `json:"dsn_work_status"`
    DSNApprovalStatus *string    `json:"dsn_approval_status"`
    DSNSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

    LDVWorkStatus     *string    `json:"ldv_work_status"`
    LDVApprovalStatus *string    `json:"ldv_approval_status"`
    LDVSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`
}

// ---- phase row for internal pivot fetch ----
type phaseRow struct {
    Project        string     `gorm:"column:project"`
    Root           string     `gorm:"column:root"`
    Group1         string     `gorm:"column:group_1"`
    Relation       string     `gorm:"column:relation"`
    Phase          string     `gorm:"column:phase"`
    WorkStatus     *string    `gorm:"column:work_status"`
    ApprovalStatus *string    `gorm:"column:approval_status"`
    SubmittedAtUTC *time.Time `gorm:"column:submitted_at_utc"`

    LeafGroupName     string `gorm:"column:leaf_group_name"`
    GroupCategoryPath string `gorm:"column:group_category_path"`
    TopGroupNode      string `gorm:"column:top_group_node"`
}

// ========================================================================
// ===================== GROUP CATEGORY SUPPORT ==========================
// ========================================================================

type SortDirection string

const (
    SortASC  SortDirection = "ASC"
    SortDESC SortDirection = "DESC"
)

type GroupedAssetBucket struct {
    TopGroupNode string       `json:"top_group_node"` // camera / character / prop / ...
    Items        []AssetPivot `json:"items"`
}

// GroupAndSortByTopNode:
//
// - Groups by TopGroupNode
// - "Unassigned" (no top_group_node) ALWAYS comes first
// - Other groups sorted alphabetically (ASC/DESC)
// - Items inside each group sorted by Group1 (ASC/DESC)
//
// Use this for GROUP CATEGORY VIEW:
//
//    pivots, total, _ := repo.ListAssetsPivot(...)
//    buckets := GroupAndSortByTopNode(pivots, SortASC)
func GroupAndSortByTopNode(rows []AssetPivot, dir SortDirection) []GroupedAssetBucket {
    grouped := make(map[string][]AssetPivot)
    order := make([]string, 0)

    // group and collect TopGroupNode keys
    for _, row := range rows {
        key := row.TopGroupNode
        if strings.TrimSpace(key) == "" {
            key = "Unassigned" // represents NULL / no group
        }
        if _, exists := grouped[key]; !exists {
            grouped[key] = []AssetPivot{}
            order = append(order, key)
        }
        grouped[key] = append(grouped[key], row)
    }

    // custom sort for group headers:
    // - "Unassigned" ALWAYS first
    // - rest alphabetically, ASC or DESC
    sort.Slice(order, func(i, j int) bool {
        ai := strings.ToLower(order[i])
        aj := strings.ToLower(order[j])

        if ai == "unassigned" && aj == "unassigned" {
            return false
        }
        if ai == "unassigned" {
            return true // Unassigned first
        }
        if aj == "unassigned" {
            return false
        }

        if dir == SortDESC {
            return ai > aj
        }
        return ai < aj
    })

    // sort children inside each group by Group1
    for _, key := range order {
        children := grouped[key]
        sort.Slice(children, func(i, j int) bool {
            gi := strings.ToLower(children[i].Group1)
            gj := strings.ToLower(children[j].Group1)

            if dir == SortDESC {
                return gi > gj
            }
            return gi < gj
        })
        grouped[key] = children
    }

    result := make([]GroupedAssetBucket, 0, len(order))
    for _, key := range order {
        result = append(result, GroupedAssetBucket{
            TopGroupNode: key,
            Items:        grouped[key],
        })
    }
    return result
}

// ========================================================================
// ========================= FILTER / ORDER HELPERS ======================
// ========================================================================

// preferredPhase is ignored in filtering, only used for sort priority elsewhere.
func buildPhaseAwareStatusWhere(_ string, approvalStatuses, workStatuses []string) (string, []any) {
    buildIn := func(col string, vals []string) (string, []any) {
        if len(vals) == 0 {
            return "", nil
        }
        ph := strings.Repeat("?,", len(vals))
        ph = ph[:len(ph)-1]

        args := make([]any, len(vals))
        for i, v := range vals {
            args[i] = strings.ToLower(strings.TrimSpace(v))
        }

        return fmt.Sprintf("LOWER(%s) IN (%s)", col, ph), args
    }

    clauses := []string{}
    args := []any{}

    if c, a := buildIn("ri.approval_status", approvalStatuses); c != "" {
        clauses = append(clauses, "("+c+")")
        args = append(args, a...)
    }
    if c, a := buildIn("ri.work_status", workStatuses); c != "" {
        clauses = append(clauses, "("+c+")")
        args = append(args, a...)
    }

    if len(clauses) == 0 {
        return "", nil
    }
    
    // Return without "AND " prefix for better flexibility
    if len(clauses) == 1 {
        return clauses[0], args
    }
    return "(" + strings.Join(clauses, " OR ") + ")", args
}

// ORDER BY builder, safe because key is white-listed in switch and dir normalized.
func buildOrderClause(alias, key, dir string) string {
    dir = strings.ToUpper(strings.TrimSpace(dir))
    if dir != "ASC" && dir != "DESC" {
        dir = "ASC"
    }

    col := func(c string) string {
        if alias == "" {
            return c
        }
        return alias + "." + c
    }

    switch key {
    // generic columns
    case "submitted_at_utc", "modified_at_utc", "phase":
        return col(key) + " " + dir

    // name / relation
    case "group1_only":
        // PRIMARY for LIST VIEW:
        // ORDER BY group_1, relation, submitted_at_utc (NULL last)
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
            col("group_1"), dir,
            col("relation"),
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )

    case "relation_only":
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
            col("relation"), dir,
            col("group_1"),
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )

    case "group_rel_submitted":
        return fmt.Sprintf(
            "LOWER(%s) ASC, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
            col("group_1"),
            col("relation"),
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )

    // phase-specific submitted date (NULL last)
    case "mdl_submitted", "rig_submitted", "bld_submitted", "dsn_submitted", "ldv_submitted":
        return fmt.Sprintf(
            "(%s IS NULL) ASC, %s %s, LOWER(%s) ASC",
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
            col("group_1"),
        )

    // work columns (alphabetical, NULL last)
    case "mdl_work", "rig_work", "bld_work", "dsn_work", "ldv_work", "work_status":
        return fmt.Sprintf(
            "(%s IS NULL) ASC, LOWER(%s) %s, LOWER(%s) ASC",
            col("work_status"),
            col("work_status"), dir,
            col("group_1"),
        )

    // approval columns (alphabetical, NULL last)
    case "mdl_appr", "rig_appr", "bld_appr", "dsn_appr", "ldv_appr":
        return fmt.Sprintf(
            "(%s IS NULL) ASC, LOWER(%s) %s, LOWER(%s) ASC",
            col("approval_status"),
            col("approval_status"), dir,
            col("group_1"),
        )

    // default: group_1 + relation + submitted_at_utc
    default:
        return fmt.Sprintf(
            "LOWER(%s) %s, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
            col("group_1"), dir,
            col("relation"),
            col("submitted_at_utc"),
            col("submitted_at_utc"), dir,
        )
    }
}

// ========================================================================
// ========================= RAW QUERIES (GORM) ==========================
// ========================================================================

// CountLatestSubmissions returns total asset count (for pagination) after filters.
// Note: This function is kept for backward compatibility but the logic is now
// integrated into ListAssetsPivot.
func (r *ReviewInfo) CountLatestSubmissions(
    ctx context.Context,
    project, root, assetNameKey string,
    preferredPhase string, // kept for API compatibility; ignored in filtering
    approvalStatuses []string,
    workStatuses []string,
) (int64, error) {
    // Call ListAssetsPivot with limit=1 to get total count efficiently
    pivots, total, err := r.ListAssetsPivot(
        ctx,
        project, root, preferredPhase,
        "group1_only", "ASC",
        1, 0,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return 0, err
    }
    _ = pivots // unused, only need total
    return total, nil
}

// ListLatestSubmissionsDynamic returns one "primary" row per asset for a page.
// Note: This function is kept for backward compatibility but the logic is now
// integrated into ListAssetsPivot.
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
    ctx context.Context,
    project string,
    root string,
    preferredPhase string,
    orderKey string,
    direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
) ([]LatestSubmissionRow, error) {
    // For backward compatibility - extract basic info from ListAssetsPivot results
    pivots, _, err := r.ListAssetsPivot(
        ctx,
        project, root, preferredPhase,
        orderKey, direction,
        limit, offset,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return nil, err
    }
    
    // Convert to LatestSubmissionRow format
    rows := make([]LatestSubmissionRow, len(pivots))
    for i, pivot := range pivots {
        // Determine which phase to use for submitted date
        var submittedAtUTC *time.Time
        var phase string
        
        // Check phases in order of preference
        if pivot.MDLSubmittedAtUTC != nil {
            submittedAtUTC = pivot.MDLSubmittedAtUTC
            phase = "mdl"
        } else if pivot.RIGSubmittedAtUTC != nil {
            submittedAtUTC = pivot.RIGSubmittedAtUTC
            phase = "rig"
        } else if pivot.BLDSubmittedAtUTC != nil {
            submittedAtUTC = pivot.BLDSubmittedAtUTC
            phase = "bld"
        } else if pivot.DSNSubmittedAtUTC != nil {
            submittedAtUTC = pivot.DSNSubmittedAtUTC
            phase = "dsn"
        } else if pivot.LDVSubmittedAtUTC != nil {
            submittedAtUTC = pivot.LDVSubmittedAtUTC
            phase = "ldv"
        }
        
        rows[i] = LatestSubmissionRow{
            Root:           pivot.Root,
            Project:        pivot.Project,
            Group1:         pivot.Group1,
            Relation:       pivot.Relation,
            Phase:          phase,
            SubmittedAtUTC: submittedAtUTC,
        }
    }
    
    return rows, nil
}

// ListAssetsPivot returns the fully pivoted rows + total count in a single efficient query.
//
// LIST VIEW:
//
//    pivots, total, _ := repo.ListAssetsPivot(
//        ctx, project, root, preferredPhase,
//        "group1_only", "ASC",  // DB orders by group_1
//        limit, offset,
//        assetNameKey, approvalStatuses, workStatuses)
//
// GROUP CATEGORY VIEW (with GroupAndSortByTopNode):
//
//    pivots, total, _ := repo.ListAssetsPivot(
//        ctx, project, root, preferredPhase,
//        "group1_only", "ASC",
//        limit, offset,
//        assetNameKey, approvalStatuses, workStatuses)
//    buckets := GroupAndSortByTopNode(pivots, SortASC)
func (r *ReviewInfo) ListAssetsPivot(
    ctx context.Context,
    project, root, preferredPhase, orderKey, direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
) ([]AssetPivot, int64, error) {
    if project == "" {
        return nil, 0, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }
    if limit <= 0 {
        limit = 60
    }
    if offset < 0 {
        offset = 0
    }

    // Build WHERE conditions
    var whereConditions []string
    var args []any
    
    // Base conditions
    whereConditions = append(whereConditions, "ri.project = ?", "ri.root = ?", "ri.deleted = 0")
    args = append(args, project, root)
    
    // Name filter
    if strings.TrimSpace(assetNameKey) != "" {
        whereConditions = append(whereConditions, "LOWER(ri.group_1) LIKE ?")
        args = append(args, strings.ToLower(strings.TrimSpace(assetNameKey))+"%")
    }
    
    // Status filtering
    statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)
    if statusWhere != "" {
        whereConditions = append(whereConditions, statusWhere)
        args = append(args, statusArgs...)
    }
    
    whereClause := strings.Join(whereConditions, " AND ")
    
    // Build ORDER BY clause
    orderClause := buildOrderClause("", orderKey, direction)
    
    // Consolidated SQL query - single query for everything
    sql := fmt.Sprintf(`
WITH filtered_base AS (
    -- Base filtered records with row numbering for latest per asset-phase
    SELECT 
        ri.project,
        ri.root,
        ri.group_1,
        ri.relation,
        ri.phase,
        ri.work_status,
        ri.approval_status,
        ri.submitted_at_utc,
        ri.modified_at_utc,
        JSON_UNQUOTE(JSON_EXTRACT(ri.\` + "`groups`" + `, '$[0]')) AS leaf_group_name,
        gc.path AS group_category_path,
        SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node,
        ROW_NUMBER() OVER (
            PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
            ORDER BY ri.modified_at_utc DESC
        ) AS phase_rn
    FROM t_review_info AS ri
    LEFT JOIN t_group_category_group AS gcg
        ON gcg.project = ri.project
        AND gcg.deleted = 0
        AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(ri.\` + "`groups`" + `, '$[0]'))
    LEFT JOIN t_group_category AS gc
        ON gc.id = gcg.group_category_id
        AND gc.deleted = 0
        AND gc.root = 'assets'
    WHERE %s
),
latest_phases AS (
    -- Latest record per asset-phase
    SELECT *
    FROM filtered_base
    WHERE phase_rn = 1
),
asset_keys AS (
    -- Distinct assets that match filters (for total count and pagination)
    SELECT DISTINCT 
        project,
        root,
        group_1,
        relation
    FROM latest_phases
),
ordered_assets AS (
    -- Apply ordering and pagination to asset keys
    SELECT 
        *,
        ROW_NUMBER() OVER (ORDER BY %s) as asset_row_num,
        COUNT(*) OVER () as total_count
    FROM asset_keys
),
paged_assets AS (
    -- Get only the paginated assets
    SELECT *
    FROM ordered_assets
    WHERE asset_row_num > ? AND asset_row_num <= ?
),
final_data AS (
    -- Join back to get phase data for paginated assets
    SELECT 
        lp.*,
        pa.total_count,
        pa.asset_row_num
    FROM paged_assets pa
    INNER JOIN latest_phases lp
        ON lp.project = pa.project
        AND lp.root = pa.root
        AND lp.group_1 = pa.group_1
        AND lp.relation = pa.relation
)
-- Pivot the data
SELECT 
    project,
    root,
    group_1,
    relation,
    leaf_group_name,
    group_category_path,
    top_group_node,
    total_count,
    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN work_status END) as mdl_work_status,
    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN approval_status END) as mdl_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'mdl' THEN submitted_at_utc END) as mdl_submitted_at_utc,
    MAX(CASE WHEN LOWER(phase) = 'rig' THEN work_status END) as rig_work_status,
    MAX(CASE WHEN LOWER(phase) = 'rig' THEN approval_status END) as rig_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'rig' THEN submitted_at_utc END) as rig_submitted_at_utc,
    MAX(CASE WHEN LOWER(phase) = 'bld' THEN work_status END) as bld_work_status,
    MAX(CASE WHEN LOWER(phase) = 'bld' THEN approval_status END) as bld_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'bld' THEN submitted_at_utc END) as bld_submitted_at_utc,
    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN work_status END) as dsn_work_status,
    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN approval_status END) as dsn_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'dsn' THEN submitted_at_utc END) as dsn_submitted_at_utc,
    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN work_status END) as ldv_work_status,
    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN approval_status END) as ldv_approval_status,
    MAX(CASE WHEN LOWER(phase) = 'ldv' THEN submitted_at_utc END) as ldv_submitted_at_utc
FROM final_data
GROUP BY project, root, group_1, relation, leaf_group_name, group_category_path, top_group_node, total_count
ORDER BY asset_row_num;
`, whereClause, orderClause)
    
    // Calculate row number range for pagination
    startRow := offset
    endRow := offset + limit
    args = append(args, startRow, endRow)
    
    // Define result struct
    var results []struct {
        Project            string     `gorm:"column:project"`
        Root               string     `gorm:"column:root"`
        Group1             string     `gorm:"column:group_1"`
        Relation           string     `gorm:"column:relation"`
        LeafGroupName      string     `gorm:"column:leaf_group_name"`
        GroupCategoryPath  string     `gorm:"column:group_category_path"`
        TopGroupNode       string     `gorm:"column:top_group_node"`
        TotalCount         int64      `gorm:"column:total_count"`
        MDLWorkStatus      *string    `gorm:"column:mdl_work_status"`
        MDLApprovalStatus  *string    `gorm:"column:mdl_approval_status"`
        MDLSubmittedAtUTC  *time.Time `gorm:"column:mdl_submitted_at_utc"`
        RIGWorkStatus      *string    `gorm:"column:rig_work_status"`
        RIGApprovalStatus  *string    `gorm:"column:rig_approval_status"`
        RIGSubmittedAtUTC  *time.Time `gorm:"column:rig_submitted_at_utc"`
        BLDWorkStatus      *string    `gorm:"column:bld_work_status"`
        BLDApprovalStatus  *string    `gorm:"column:bld_approval_status"`
        BLDSubmittedAtUTC  *time.Time `gorm:"column:bld_submitted_at_utc"`
        DSNWorkStatus      *string    `gorm:"column:dsn_work_status"`
        DSNApprovalStatus  *string    `gorm:"column:dsn_approval_status"`
        DSNSubmittedAtUTC  *time.Time `gorm:"column:dsn_submitted_at_utc"`
        LDVWorkStatus      *string    `gorm:"column:ldv_work_status"`
        LDVApprovalStatus  *string    `gorm:"column:ldv_approval_status"`
        LDVSubmittedAtUTC  *time.Time `gorm:"column:ldv_submitted_at_utc"`
    }
    
    if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&results).Error; err != nil {
        return nil, 0, fmt.Errorf("ListAssetsPivot: %w", err)
    }
    
    if len(results) == 0 {
        return []AssetPivot{}, 0, nil
    }
    
    // Convert to AssetPivot
    var total int64 = 0
    pivots := make([]AssetPivot, len(results))
    
    for i, res := range results {
        pivots[i] = AssetPivot{
            Root:               res.Root,
            Project:            res.Project,
            Group1:             res.Group1,
            Relation:           res.Relation,
            LeafGroupName:      res.LeafGroupName,
            GroupCategoryPath:  res.GroupCategoryPath,
            TopGroupNode:       res.TopGroupNode,
            MDLWorkStatus:      res.MDLWorkStatus,
            MDLApprovalStatus:  res.MDLApprovalStatus,
            MDLSubmittedAtUTC:  res.MDLSubmittedAtUTC,
            RIGWorkStatus:      res.RIGWorkStatus,
            RIGApprovalStatus:  res.RIGApprovalStatus,
            RIGSubmittedAtUTC:  res.RIGSubmittedAtUTC,
            BLDWorkStatus:      res.BLDWorkStatus,
            BLDApprovalStatus:  res.BLDApprovalStatus,
            BLDSubmittedAtUTC:  res.BLDSubmittedAtUTC,
            DSNWorkStatus:      res.DSNWorkStatus,
            DSNApprovalStatus:  res.DSNApprovalStatus,
            DSNSubmittedAtUTC:  res.DSNSubmittedAtUTC,
            LDVWorkStatus:      res.LDVWorkStatus,
            LDVApprovalStatus:  res.LDVApprovalStatus,
            LDVSubmittedAtUTC:  res.LDVSubmittedAtUTC,
        }
        
        // Get total from first result
        if i == 0 {
            total = res.TotalCount
        }
    }
    
    return pivots, total, nil
}
