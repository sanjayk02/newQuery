package reviewinfo

import (
    "context"
    "fmt"
    "strings"

    "gorm.io/gorm"
)

// --- STRUCTS ---

// ReviewInfo represents the final output of the query.
// Map this to your desired JSON keys.
type ReviewInfo struct {
    Project  string `json:"project"`
    Root     string `json:"root"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`
    // Add other fields you might eventually want to select from the t_review_info table
}

// ReviewInfoRepository defines the methods for interacting with the t_review_info table.
type ReviewInfoRepository struct {
    // You might include the GORM DB connection here if not passed in the method.
}

// --- SQL CONSTANT ---

// The complex SQL query with placeholders for parameters.
// NOTE: We'll use ? placeholders for GORM/database/sql compatibility.
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM
        t_review_info
    WHERE
        project = ? AND deleted = 0
    GROUP BY
        project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root,
        b.project,
        b.group_1,
        b.phase,
        b.relation,
        b.work_status,
        b.submitted_at_utc,
        b.modified_at_utc,
        b.executed_computer
    FROM
        max_modified AS a
    INNER JOIN
        t_review_info AS b
    ON
        a.project = b.project AND
        a.root = b.root AND
        a.group_1 = b.group_1 AND
        a.relation = b.relation AND
        a.phase = b.phase AND
        a.modified_at_utc = b.modified_at_utc
    WHERE
        b.project = ? AND b.deleted = 0 -- Re-apply project filter for security/performance
    ORDER BY
        b.submitted_at_utc ASC 
),
ordered AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            ORDER BY group_1 ASC -- DEFAULT SORT: group_1
        ) AS _order,
        submitted_at_utc
    FROM
        latest_reviews
),
offset_ordered AS (
    SELECT
        c.*,
        CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order 
    FROM
        ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END -- phase filter for ranking
        ) AS _rank
    FROM
        offset_ordered b
)
SELECT
    root,
    project,
    group_1,
    relation
FROM
(
    SELECT
        *
    FROM
        ranked
    WHERE
        _rank = 1
) AS t
%s -- Placeholder for dynamic ORDER BY clause
LIMIT ? OFFSET ?
`

// --- REPOSITORY METHOD ---

// ListLatestSubmissionsWithSort executes the complex SQL query with dynamic parameters.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
    ctx context.Context, 
    db *gorm.DB, 
    project string, 
    limit, offset int, 
    sortParam string,
) ([]ReviewInfo, error) {
    
    // 1. Determine the dynamic ORDER BY clause
    orderByClause := ""
    
    // NOTE: This is a simplification. For robust sorting, you'd use a whitelist 
    // of allowed columns and sanitize the input to prevent SQL injection.
    if sortParam != "" {
        sortField := strings.TrimPrefix(sortParam, "-")
        direction := "ASC"
        if strings.HasPrefix(sortParam, "-") {
            direction = "DESC"
        }
        
        // This is the field we want to sort the FINAL result by. 
        // We'll use the 'submitted_at_utc' field from the CTE as an example.
        if sortField == "submitted" { 
             // In your original query, the final order is by __order. 
             // To use another field, it must be available in the final 't' subquery. 
             // I'm adding a hypothetical sort option here.
             orderByClause = fmt.Sprintf("ORDER BY t.%s %s", "submitted_at_utc", direction)
        } else if sortField == "group_1" {
             orderByClause = fmt.Sprintf("ORDER BY t.%s %s", "group_1", direction)
        }
        // If sortParam isn't recognized, we default to the __order from the query.
    }
    
    // Default to the complex order from the query if no valid sortParam is provided
    if orderByClause == "" {
        orderByClause = "ORDER BY __order ASC"
    }

    // 2. Construct the final query string
    finalQuery := fmt.Sprintf(complexReviewInfoQuery, orderByClause)

    // 3. Execute the query using GORM's Raw method
    var out []ReviewInfo
    
    // The parameters are: project, project, limit, offset
    result := db.WithContext(ctx).Raw(
        finalQuery, 
        project, 
        project, 
        limit, 
        offset,
    ).Scan(&out)
    
    if result.Error != nil {
        return nil, result.Error
    }

    return out, nil
}
