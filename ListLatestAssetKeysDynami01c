package repository

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// ---------------------------------------------------------------------------
// Entity: the minimal columns returned from the dynamic sort query
// ---------------------------------------------------------------------------

type ReviewAssetRow struct {
	Project  string `json:"project"  gorm:"column:project"`
	Root     string `json:"root"     gorm:"column:root"`
	Group1   string `json:"group_1"  gorm:"column:group_1"`
	Relation string `json:"relation" gorm:"column:relation"`
}

// ---------------------------------------------------------------------------
// Repository
// ---------------------------------------------------------------------------

type ReviewInfo struct{}

func NewReviewInfo(db *gorm.DB) (*ReviewInfo, error) {
	return &ReviewInfo{}, nil
}

// ---------------------------------------------------------------------------
// Dynamic sort SQL (no pivot, no MAX/CASE)
// ---------------------------------------------------------------------------

const listLatestSubmissionsDynamicSQL = `
WITH ordered AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (ORDER BY b.group_1 ASC) AS _order
  FROM (
    SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
    GROUP BY project, root, group_1, relation, phase
  ) a
  LEFT JOIN (
    SELECT root, project, group_1, phase, relation,
           work_status, approval_status, submitted_at_utc, modified_at_utc, executed_computer
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
  ) b
    ON a.project=b.project AND a.root=b.root AND a.group_1=b.group_1
   AND a.relation=b.relation AND a.phase=b.phase AND a.modified_at_utc=b.modified_at_utc
),
offset_ordered AS (
  SELECT c.*,
         CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
),
phase_latest AS (
  SELECT o.project, o.root, o.group_1, o.relation,
         o.work_status, o.approval_status, o.submitted_at_utc, o.modified_at_utc
  FROM ordered o
  WHERE o.phase = ?
),
winner AS (
  SELECT r.root, r.project, r.group_1, r.relation, r.__order
  FROM ranked r
  WHERE r._rank = 1
)
SELECT w.root, w.project, w.group_1, w.relation
FROM winner w
LEFT JOIN phase_latest pl
  ON pl.project=w.project AND pl.root=w.root
 AND pl.group_1=w.group_1 AND pl.relation=w.relation
ORDER BY
  w.__order ASC,
  CASE
    WHEN ?='work'         THEN pl.work_status
    WHEN ?='appr'         THEN pl.approval_status
    WHEN ?='submitted_at' THEN pl.submitted_at_utc
    WHEN ?='modified_at'  THEN pl.modified_at_utc
  END ASC,
  CASE WHEN ?='desc' THEN
    CASE
      WHEN ?='work'         THEN pl.work_status
      WHEN ?='appr'         THEN pl.approval_status
      WHEN ?='submitted_at' THEN pl.submitted_at_utc
      WHEN ?='modified_at'  THEN pl.modified_at_utc
    END
  END DESC,
  w.group_1 ASC
LIMIT ? OFFSET ?;
`

// ---------------------------------------------------------------------------
// Main Function
// ---------------------------------------------------------------------------

func (r *ReviewInfo) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	limit int,
	offset int,
	sortParam string, // e.g., "mdl:work:asc" or "rig:submitted_at:desc"
) ([]*ReviewAssetRow, error) {

	// Default project (just ensure)
	if project == "" {
		project = "potoodev"
	}

	// Defaults
	sortPhase := "mdl"
	sortField := "submitted_at"
	sortDir := "asc"

	// Parse param like "mdl:work:desc"
	if sortParam != "" {
		parts := strings.Split(sortParam, ":")
		if len(parts) >= 1 && parts[0] != "" {
			sortPhase = strings.ToLower(parts[0])
		}
		if len(parts) >= 2 && parts[1] != "" {
			sortField = strings.ToLower(parts[1])
		}
		if len(parts) >= 3 && parts[2] != "" {
			sortDir = strings.ToLower(parts[2])
		}
	}

	// Whitelists
	phaseOK := map[string]bool{"mdl": true, "rig": true, "bld": true, "dsn": true, "ldv": true}
	fieldOK := map[string]bool{"work": true, "appr": true, "submitted_at": true, "modified_at": true}
	if !phaseOK[sortPhase] {
		sortPhase = "mdl"
	}
	if !fieldOK[sortField] {
		sortField = "submitted_at"
	}
	if sortDir != "desc" {
		sortDir = "asc"
	}
	if limit <= 0 || limit > 500 {
		limit = 15
	}
	if offset < 0 {
		offset = 0
	}

	// Ordered params
	args := []any{
		project,
		project,
		sortPhase,
		sortField, sortField, sortField, sortField,
		sortDir,
		sortField, sortField, sortField, sortField,
		limit, offset,
	}

	var result []*ReviewAssetRow
	if err := db.WithContext(ctx).Raw(listLatestSubmissionsDynamicSQL, args...).Scan(&result).Error; err != nil {
		return nil, err
	}
	return result, nil
}



package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"<your-module-path>/repository" // <-- replace this with your actual Go module import path
)

// -----------------------------------------------------------------------------
// MAIN ENTRY
// -----------------------------------------------------------------------------
func main() {
	// -------------------------------------------------------------------------
	// DB CONNECTION (replace DSN with your local one)
	// -------------------------------------------------------------------------
	dsn := "root:root@tcp(127.0.0.1:3306)/potoodev?charset=utf8mb4&parseTime=True&loc=Local"
	gormDB, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("❌ DB connection failed: %v", err)
	}
	log.Println("✅ Connected to MySQL (potoodev)")

	// -------------------------------------------------------------------------
	// REPOSITORY INITIALIZATION
	// -------------------------------------------------------------------------
	reviewInfoRepo, err := repository.NewReviewInfo(gormDB)
	if err != nil {
		log.Fatalf("❌ Repo init failed: %v", err)
	}

	// -------------------------------------------------------------------------
	// ROUTER
	// -------------------------------------------------------------------------
	router := gin.Default()

	// --- Dynamic sort route ---------------------------------------------------
	// Example:
	// /api/latest/review-submissions/potoodev?sort=mdl:work:desc&limit=15&offset=0
	router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
		project := c.Param("project")
		if project == "" {
			project = "potoodev"
		}

		// Optional sort parameter: mdl:work:desc
		sortParam := c.DefaultQuery("sort", "mdl:submitted_at:asc")

		// Pagination
		limit := parseIntDefault(c.Query("limit"), 15)
		offset := parseIntDefault(c.Query("offset"), 0)

		// Context with timeout
		ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
		defer cancel()

		rows, err := reviewInfoRepo.ListLatestSubmissionsWithSort(
			ctx, gormDB, project, limit, offset, sortParam,
		)
		if err != nil {
			log.Printf("❌ Query error: %v", err)
			c.String(http.StatusInternalServerError, fmt.Sprintf("DB error: %v", err))
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"project":  project,
			"count":    len(rows),
			"limit":    limit,
			"offset":   offset,
			"sort":     sortParam,
			"results":  rows,
			"status":   "success",
			"message":  fmt.Sprintf("✅ Sorted review submissions for %s", project),
		})
	})

	// -------------------------------------------------------------------------
	// SERVER START
	// -------------------------------------------------------------------------
	if err := router.Run(":4000"); err != nil {
		log.Fatalf("❌ Server failed: %v", err)
	}
}

// -----------------------------------------------------------------------------
// HELPERS
// -----------------------------------------------------------------------------
func parseIntDefault(s string, def int) int {
	if s == "" {
		return def
	}
	n, err := strconv.Atoi(s)
	if err != nil {
		return def
	}
	return n
}




How It Works
Feature	Example	Behavior
Default (no click)	/api/latest/review-submissions/potoodev	Sorts by group_1 ASC (default stable order)
Sort by MDL WORK ↓	/api/latest/review-submissions/potoodev?sort=mdl:work:desc	Sorts by MDL phase → work_status descending
Sort by RIG SUBMITTED ↑	/api/latest/review-submissions/potoodev?sort=rig:submitted_at:asc	Sorts by rig phase’s submitted date ascending
Sort by DSN APPROVAL ↓	/api/latest/review-submissions/potoodev?sort=dsn:appr:desc	S
