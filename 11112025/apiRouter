	// ============================================================================
	// START: UNAUTHENTICATED ENDPOINT BLOCK (ASSET LISTING WITH DYNAMIC SORT)
	// ============================================================================
	apiRouter.GET("/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
		project := strings.TrimSpace(c.Param("project"))
		if project == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
			return
		}

		root := c.DefaultQuery("root", defaultRoot)

		// NO DEFAULT PHASE: read as-is; if empty, we won't echo it back.
		phaseParam := strings.TrimSpace(c.Query("phase")) // "" if not provided

		// If a phase is supplied, allow only known phases (plus "none")
		if phaseParam != "" {
			lp := strings.ToLower(phaseParam)
			if lp != "none" {
				if _, ok := allowedPhases[lp]; !ok {
					c.JSON(http.StatusBadRequest, gin.H{
						"error":          "invalid phase",
						"allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
					})
					return
				}
			}
		}

		// Pagination
		page := mustAtoi(c.DefaultQuery("page", "1"))
		page = int(math.Max(float64(page), 1))
		perPage := clampPerPage(mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage))))
		limit := perPage
		offset := (page - 1) * perPage

		// Sorting
		sortParam := c.DefaultQuery("sort", "group_1")
		dirParam := c.DefaultQuery("dir", "ASC")
		orderKey := normalizeSortKey(sortParam)
		dir := normalizeDir(dirParam)

		// Internal preferredPhase we pass to repo:
		// - If sorting by group/relation buckets, force "none" (no phase bias).
		// - Else, use the provided phase if any, otherwise "none".
		preferredPhase := phaseParam
		if orderKey == "group1_only" || orderKey == "relation_only" || orderKey == "group_rel_submitted" {
			preferredPhase = "none"
		}
		if preferredPhase == "" {
			preferredPhase = "none"
		}

		ctx, cancel := context.WithTimeout(c.Request.Context(), 7*time.Second)
		defer cancel()

		assets, total, err := reviewInfoRepository.ListAssetsPivot(
			ctx, project, root, preferredPhase, orderKey, dir, limit, offset,
		)
		if err != nil {
			log.Printf("[pivot-submissions] query error for project %q: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			return
		}

		// Response
		c.Header("Cache-Control", "public, max-age=15")

		// Preserve current filters in pagination links
		q := url.Values{}
		q.Set("root", root)
		q.Set("sort", sortParam)
		q.Set("dir", strings.ToLower(dir))
		q.Set("per_page", fmt.Sprint(perPage))
		if phaseParam != "" {
			q.Set("phase", phaseParam)
		}

		baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot?%s", project, q.Encode())
		if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
			c.Header("Link", links)
		}

		// Build payload; only echo "phase" if user supplied it
		resp := gin.H{
			"assets":    assets,
			"total":     total,
			"page":      page,
			"per_page":  perPage,
			"sort":      sortParam,
			"dir":       strings.ToLower(dir),
			"project":   project,
			"root":      root,
			"has_next":  offset+limit < int(total),
			"has_prev":  page > 1,
			"page_last": (int(total) + perPage - 1) / perPage,
		}
		if phaseParam != "" {
			resp["phase"] = phaseParam
		}

		c.IndentedJSON(http.StatusOK, resp)
	})
	// ============================================================================
	// END: UNAUTHENTICATED ENDPOINT BLOCK
	// ============================================================================

	srv := &http.Server{
		Addr:         serverAddr,
		Handler:      router,
		ReadTimeout:  readTimeoutSec * time.Second,
		WriteTimeout: writeTimeoutSec * time.Second,
	}
	log.Printf("listening on %s ...", serverAddr)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("server error: %v", err)
	}
}
