apiRouter.GET("/projects/:project/reviews/assets/pivot", func(c *gin.Context) {
    project := strings.TrimSpace(c.Param("project"))
    if project == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
        return
    }

    const defaultRoot = "assets"
    root := c.DefaultQuery("root", defaultRoot)

    // Phase (optional): allow mdl/rig/bld/dsn/ldv/none
    phaseParam := strings.TrimSpace(c.Query("phase"))
    if phaseParam != "" {
        lp := strings.ToLower(phaseParam)
        if lp != "none" && lp != "mdl" && lp != "rig" && lp != "bld" && lp != "dsn" && lp != "ldv" {
            c.JSON(http.StatusBadRequest, gin.H{
                "error":          "invalid phase",
                "allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
            })
            return
        }
    }

    // Pagination
    perPage := parseIntDefault(c.Query("per_page"), 15)
    perPage = clamp(perPage, 1, 200)
    page := clamp(parseIntDefault(c.Query("page"), 1), 1, 1_000_000)
    limit := perPage
    offset := (page - 1) * perPage

    // Sorting (pass-through to repo/buildOrderClause)
    sortParam := c.DefaultQuery("sort", "group_1") // e.g. group_1, relation, mdl_work, mdl_appr, mdl_submitted, etc.
    dirParam := strings.ToLower(c.DefaultQuery("dir", "asc"))
    if dirParam != "asc" && dirParam != "desc" {
        dirParam = "asc"
    }

    // Phase preference: if not provided, default to "none"
    preferredPhase := strings.TrimSpace(phaseParam)
    if preferredPhase == "" {
        preferredPhase = "none"
    }

    // Filters (match frontend param names)
    // Text box: case-insensitive contains on asset name
    assetNameKey := strings.TrimSpace(c.Query("asset_name_key"))

    // Multi-selects: accept both repeated params ...?approval_statuses=A&approval_statuses=B
    // and CSV fallback ...?approval_statuses=A,B
    approvalStatuses := readArrayOrCSV(c, "approval_statuses")
    workStatuses := readArrayOrCSV(c, "work_statuses")

    // Execute
    ctx, cancel := context.WithTimeout(c.Request.Context(), 7*time.Second)
    defer cancel()

    assets, total, err := reviewInfoRepository.ListAssetsPivot(
        ctx,
        project, root,
        preferredPhase,     // phase bias for ranking
        sortParam,          // orderKey
        dirParam,           // direction
        limit, offset,
        assetNameKey,       // ðŸ”Ž name filter
        approvalStatuses,   // ðŸ”Ž appr filter
        workStatuses,       // ðŸ”Ž work filter
    )
    if err != nil {
        log.Printf("[pivot] query error project=%q err=%v", project, err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
        return
    }

    // Pagination headers
    c.Header("Cache-Control", "public, max-age=15")
    baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", url.PathEscape(project))
    if links := buildPaginationLinks(baseURL, page, perPage, int(total), c.Request.URL.Query()); links != "" {
        c.Header("Link", links)
    }

    // Response
    resp := gin.H{
        "assets":    assets,
        "total":     total,
        "page":      page,
        "per_page":  perPage,
        "sort":      sortParam,
        "dir":       dirParam,
        "project":   project,
        "root":      root,
        "has_next":  offset+limit < int(total),
        "has_prev":  page > 1,
        "page_last": (int(total) + perPage - 1) / perPage,
    }
    if phaseParam != "" {
        resp["phase"] = phaseParam
    }

    c.IndentedJSON(http.StatusOK, resp)
})

// ---- helpers (keep near the route) ----
func parseIntDefault(s string, def int) int {
    if s == "" {
        return def
    }
    if n, err := strconv.Atoi(s); err == nil {
        return n
    }
    return def
}
func clamp(n, lo, hi int) int {
    if n < lo { return lo }
    if n > hi { return hi }
    return n
}
func readArrayOrCSV(c *gin.Context, key string) []string {
    arr := c.QueryArray(key)
    if len(arr) == 0 {
        csv := strings.TrimSpace(c.Query(key))
        if csv != "" {
            for _, part := range strings.Split(csv, ",") {
                if t := strings.TrimSpace(part); t != "" {
                    arr = append(arr, t)
                }
            }
        }
    }
    // de-dup + normalize spaces
    seen := map[string]struct{}{}
    out := make([]string, 0, len(arr))
    for _, v := range arr {
        t := strings.TrimSpace(v)
        if t == "" { continue }
        if _, ok := seen[t]; ok { continue }
        seen[t] = struct{}{}
        out = append(out, t)
    }
    return out
}
func buildPaginationLinks(base string, page, perPage, total int, q url.Values) string {
    if perPage <= 0 { return "" }
    last := (total + perPage - 1) / perPage
    if last < 1 { last = 1 }
    // retain other query params
    makeURL := func(p int) string {
        q2 := url.Values{}
        for k, v := range q {
            for _, vv := range v {
                q2.Add(k, vv)
            }
        }
        q2.Set("page", strconv.Itoa(p))
        q2.Set("per_page", strconv.Itoa(perPage))
        return fmt.Sprintf("%s?%s", base, q2.Encode())
    }

    var links []string
    if page > 1 {
        links = append(links, fmt.Sprintf("<%s>; rel=\"prev\"", makeURL(page-1)))
        links = append(links, fmt.Sprintf("<%s>; rel=\"first\"", makeURL(1)))
    }
    if page < last {
        links = append(links, fmt.Sprintf("<%s>; rel=\"next\"", makeURL(page+1)))
        links = append(links, fmt.Sprintf("<%s>; rel=\"last\"", makeURL(last)))
    }
    return strings.Join(links, ", ")
}
