// AssetsDataTablePanel.tsx
// Add/replace this resolver
const resolveServerSort = (key: string): { sort: string; phase: string } => {
  // simple columns
  if (key === 'group_1') return { sort: 'group_1', phase: 'none' };
  if (key === 'relation') return { sort: 'relation', phase: 'none' };

  // phase columns: mdl|rig|bld|dsn|ldv
  const m = key.match(/^(mdl|rig|bld|dsn|ldv)_(work|appr|submitted)$/i);
  if (!m) return { sort: 'group_1', phase: 'none' };

  const phase = m[1].toLowerCase();
  const field = m[2].toLowerCase();

  if (field === 'submitted') return { sort: 'submitted_at_utc', phase };
  if (field === 'work')      return { sort: 'work_status_priority', phase };
  return { sort: 'approval_status_priority', phase }; // 'appr'
};


// on header click
const handleSortChange = (uiKey: string) => {
  setSortKey(uiKey);                   // keep UI state (e.g., "mdl_work")
  setSortDir(prev => prev === 'asc' ? 'desc' : 'asc');
  const { sort, phase } = resolveServerSort(uiKey);
  // fetch with these params:
  fetchPivot({ sort, phase, dir: nextDir, page: 1 });
};

Whitelist sort keys in the API router (main.go)
var sortKeyMap = map[string]string{
  "group_1": "group1_only",
  "relation": "relation_only",
  "submitted_at_utc": "submitted_at_utc",
  "modified_at_utc": "modified_at_utc",
  "phase": "phase",
  "group_rel_submitted": "group_rel_submitted",
  "work_status": "work_status", // legacy alpha
  "work_status_priority": "work_status_priority",         // ✅ NEW
  "approval_status_priority": "approval_status_priority", // ✅ NEW
}

Add priority ranking to buildOrderClause (reviewInfo.go)

func workStatusPriorityExpr(col string) string {
  return fmt.Sprintf(`CASE
    WHEN %s IS NULL THEN 999
    WHEN LOWER(%s)='check' THEN 10
    WHEN LOWER(%s) IN ('cgsvretake','svretake','leadretake') THEN 40
    WHEN LOWER(%s) IN ('cgsvonhold','svonhold','leadonhold') THEN 60
    WHEN LOWER(%s) IN ('cgsvapproved','svapproved','leadapproved') THEN 100
    WHEN LOWER(%s) IN ('omit','svother','leadother','other') THEN 900
    ELSE 900 END`, col, col, col, col, col, col)
}

func approvalStatusPriorityExpr(col string) string {
  return fmt.Sprintf(`CASE
    WHEN %s IS NULL THEN 999
    WHEN LOWER(%s)='check' THEN 10
    WHEN LOWER(%s) IN ('clientreview','dirreview','epdreview','review') THEN 20
    WHEN LOWER(%s) IN ('clientonhold','dironhold','epdonhold','onhold') THEN 60
    WHEN LOWER(%s) IN ('execretake','clientretake','dirretake','epdretake','retake') THEN 80
    WHEN LOWER(%s) IN ('clientapproved','dirapproved','epdapproved','approved') THEN 100
    WHEN LOWER(%s) IN ('omit','other') THEN 900
    ELSE 900 END`, col, col, col, col, col, col, col)
}

func buildOrderClause(alias, key, dir string) string {
  dir = strings.ToUpper(strings.TrimSpace(dir))
  if dir != "ASC" && dir != "DESC" { dir = "ASC" }
  col := func(c string) string { if alias=="" { return c }; return alias+"."+c }

  switch key {
  case "submitted_at_utc":
    // ✅ NULLS LAST both directions + stable tie-breakers
    return fmt.Sprintf("(%s IS NULL) ASC, %s %s, LOWER(%s) ASC, LOWER(%s) ASC",
      col("submitted_at_utc"), col("submitted_at_utc"), dir, col("group_1"), col("relation"))

  case "work_status_priority":
    return fmt.Sprintf("%s %s, LOWER(%s) ASC, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
      workStatusPriorityExpr(col("work_status")), dir,
      col("group_1"), col("relation"),
      col("submitted_at_utc"), col("submitted_at_utc"), dir)

  case "approval_status_priority":
    return fmt.Sprintf("%s %s, LOWER(%s) ASC, LOWER(%s) ASC, (%s IS NULL) ASC, %s %s",
      approvalStatusPriorityExpr(col("approval_status")), dir,
      col("group_1"), col("relation"),
      col("submitted_at_utc"), col("submitted_at_utc"), dir)

  // …(keep your other cases)…
  }
  // default …
}



3) Make the phase filter hard (when provided) in ListLatestSubmissionsDynamic

Ensure the CTE only considers the requested phase instead of mixing phases before sorting:

// Inside the two inner SELECTs in the CTE:
WHERE project = ? AND root = ? AND deleted = 0
  AND ( ? = 1 OR LOWER(phase) = LOWER(?) )


…and add the two extra args for each inner SELECT:

args := []any{
  project, root, phaseGuard, preferredPhase,  // inner A
  project, root, phaseGuard, preferredPhase,  // inner B
  phaseGuard, preferredPhase,                 // offset_ordered
  phaseGuard, preferredPhase,                 // ranked
  limit, offset,
}
