package reviewinfo

import (
    "context"
    "fmt"
    "strings"

    "gorm.io/gorm"
)

// --- STRUCTS ---

// ReviewInfo represents the final output of the query.
// Map this to your desired JSON keys.
type ReviewInfo struct {
    Project  string `json:"project"`
    Root     string `json:"root"`
    Group1   string `json:"group_1"`
    Relation string `json:"relation"`
    // Add other fields you might eventually want to select from the t_review_info table
}

// ReviewInfoRepository defines the methods for interacting with the t_review_info table.
type ReviewInfoRepository struct {
    // You might include the GORM DB connection here if not passed in the method.
}

// --- SQL CONSTANT ---

// The complex SQL query with placeholders for parameters.
// NOTE: We'll use ? placeholders for GORM/database/sql compatibility.
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM
        t_review_info
    WHERE
        project = ? AND deleted = 0
    GROUP BY
        project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root,
        b.project,
        b.group_1,
        b.phase,
        b.relation,
        b.work_status,
        b.submitted_at_utc,
        b.modified_at_utc,
        b.executed_computer
    FROM
        max_modified AS a
    INNER JOIN
        t_review_info AS b
    ON
        a.project = b.project AND
        a.root = b.root AND
        a.group_1 = b.group_1 AND
        a.relation = b.relation AND
        a.phase = b.phase AND
        a.modified_at_utc = b.modified_at_utc
    WHERE
        b.project = ? AND b.deleted = 0 -- Re-apply project filter for security/performance
    ORDER BY
        b.submitted_at_utc ASC 
),
ordered AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            ORDER BY group_1 ASC -- DEFAULT SORT: group_1
        ) AS _order,
        submitted_at_utc
    FROM
        latest_reviews
),
offset_ordered AS (
    SELECT
        c.*,
        CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order 
    FROM
        ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END -- phase filter for ranking
        ) AS _rank
    FROM
        offset_ordered b
)
SELECT
    root,
    project,
    group_1,
    relation
FROM
(
    SELECT
        *
    FROM
        ranked
    WHERE
        _rank = 1
) AS t
%s -- Placeholder for dynamic ORDER BY clause
LIMIT ? OFFSET ?
`

// --- REPOSITORY METHOD ---

// ListLatestSubmissionsWithSort executes the complex SQL query with dynamic parameters.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
    ctx context.Context, 
    db *gorm.DB, 
    project string, 
    limit, offset int, 
    sortParam string,
) ([]ReviewInfo, error) {
    
    // 1. Determine the dynamic ORDER BY clause
    orderByClause := ""
    
    // NOTE: This is a simplification. For robust sorting, you'd use a whitelist 
    // of allowed columns and sanitize the input to prevent SQL injection.
    if sortParam != "" {
        sortField := strings.TrimPrefix(sortParam, "-")
        direction := "ASC"
        if strings.HasPrefix(sortParam, "-") {
            direction = "DESC"
        }
        
        // This is the field we want to sort the FINAL result by. 
        // We'll use the 'submitted_at_utc' field from the CTE as an example.
        if sortField == "submitted" { 
             // In your original query, the final order is by __order. 
             // To use another field, it must be available in the final 't' subquery. 
             // I'm adding a hypothetical sort option here.
             orderByClause = fmt.Sprintf("ORDER BY t.%s %s", "submitted_at_utc", direction)
        } else if sortField == "group_1" {
             orderByClause = fmt.Sprintf("ORDER BY t.%s %s", "group_1", direction)
        }
        // If sortParam isn't recognized, we default to the __order from the query.
    }
    
    // Default to the complex order from the query if no valid sortParam is provided
    if orderByClause == "" {
        orderByClause = "ORDER BY __order ASC"
    }

    // 2. Construct the final query string
    finalQuery := fmt.Sprintf(complexReviewInfoQuery, orderByClause)

    // 3. Execute the query using GORM's Raw method
    var out []ReviewInfo
    
    // The parameters are: project, project, limit, offset
    result := db.WithContext(ctx).Raw(
        finalQuery, 
        project, 
        project, 
        limit, 
        offset,
    ).Scan(&out)
    
    if result.Error != nil {
        return nil, result.Error
    }

    return out, nil
}



package main

import (
	"context"
	"log"
	"net/http"
	"strconv"
	"strings"
	
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
    
    // Replace with the actual path to your reviewinfo package
	"your_module_path/reviewinfo" 
)

// Global (or dependency injected) database and repository instances
var (
	gormDB *gorm.DB
	reviewInfoRepository = &reviewinfo.ReviewInfoRepository{} 
)

// NOTE: In a real application, you'd initialize gormDB in your main function 
// and pass dependencies via structs/interfaces (Dependency Injection).

// SetupRouter configures the API route.
func SetupRouter(router *gin.Engine) {

    // --- The Handler You Requested ---
    router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
        
        // 1. Get and Validate Path/Query Parameters
        project := strings.TrimSpace(c.Param("project"))

        if project == "" {
            c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
            return
        }

        // Use c.DefaultQuery for safe type conversion with defaults
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        
        // --- Get optional sort parameter ---
        sortParam := c.Query("sort") // e.g., submitted, -group_1, etc.
        // -----------------------------------

        // 2. Call the MODIFIED Repository method
        // Use c.Request.Context() for proper request cancellation/timeout handling
        out, err := reviewInfoRepository.ListLatestSubmissionsWithSort(
            c.Request.Context(), 
            gormDB, 
            project, 
            limit, 
            offset, 
            sortParam,
        )
        
        if err != nil {
            log.Printf("[review-submissions] query error for project %s: %v", project, err)
            // Log the error but return a generic message to the client for security
            c.JSON(http.StatusInternalServerError, gin.H{"error": "An internal database error occurred."})
            return
        }

        // 3. Respond
        log.Printf("[review-submissions] Fetched %d rows for project %s (limit=%d offset=%d)", len(out), project, limit, offset)
        c.IndentedJSON(http.StatusOK, out)
    })
    // -----------------------------------
}

Goal	URL Example			
Basic Call (Default limit/offset)	/api/latest/review-submissions/potoo			
Pagination (Page 2, 20 items per page)	/api/latest/review-submissions/potoo?limit=20&offset=20			
Sorting (Sort by group_1 descending)	/api/latest/review-submissions/potoo?sort=-group_1			
Combined (Paginated, sorted results)	/api/latest/review-submissions/potoo?limit=10&offset=50&sort=submitted			
				
				
				
				
