package reviewinfo

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// ReviewInfo represents the final output of the query.
type ReviewInfo struct {
	Root                 string `json:"root"`
	Project              string `json:"project"`
	Group1               string `json:"group_1"`
	Relation             string `json:"relation"`
	Phase                string `json:"phase"`
	WorkStatus           string `json:"work_status"`
	SubmittedAtUtc       string `json:"submitted_at_utc"`
	ModifiedAtUtc        string `json:"modified_at_utc"`
	ExecutedComputer     string `json:"executed_computer"`
	// Note: We don't need __order in the struct unless we want to return it. 
    // GORM/Scan will typically ignore extra columns if they are not mapped.
}

// ReviewInfoRepository defines the methods for interacting with the t_review_info table.
type ReviewInfoRepository struct {
    // In a real app, you might inject the DB here: DB *gorm.DB
}

// --- CORRECTED SQL CONSTANT ---

// complexReviewInfoQuery uses '?' placeholders for GORM/database/sql.
// It includes __order in the final SELECT to fix the "Unknown column" error.
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM
        t_review_info
    WHERE
        project = ? AND deleted = 0
    GROUP BY
        project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root,
        b.project,
        b.group_1,
        b.phase,
        b.relation,
        b.work_status,
        b.submitted_at_utc,
        b.modified_at_utc,
        b.executed_computer
    FROM
        max_modified AS a
    INNER JOIN
        t_review_info AS b
    ON
        a.project = b.project AND
        a.root = b.root AND
        a.group_1 = b.group_1 AND
        a.relation = b.relation AND
        a.phase = b.phase AND
        a.modified_at_utc = b.modified_at_utc
    WHERE
        b.project = ? AND b.deleted = 0
    ORDER BY
        b.submitted_at_utc ASC 
),
ordered AS (
    SELECT
        t1.*,
        ROW_NUMBER() OVER (
            ORDER BY t1.group_1 ASC -- DEFAULT SORT
        ) AS _order
    FROM
        latest_reviews t1
),
offset_ordered AS (
    SELECT
        c.*,
        CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
    FROM
        ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END -- phase filter for ranking
        ) AS _rank
    FROM
        offset_ordered b
)
SELECT
    root,
    project,
    group_1,
    relation,
    phase,
    work_status,
    submitted_at_utc,
    modified_at_utc,
    executed_computer,
    __order -- <--- CORRECTED: Includes the column needed for the outer ORDER BY
FROM
(
    SELECT
        *
    FROM
        ranked
    WHERE
        _rank = 1
) AS t
%s -- Placeholder for dynamic ORDER BY clause
LIMIT ? OFFSET ?
`

// ListLatestSubmissionsWithSort executes the complex SQL query with dynamic parameters.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	limit, offset int,
	sortParam string,
) ([]ReviewInfo, error) {

	// 1. Determine the dynamic ORDER BY clause
	orderByClause := ""
	
	// Default to the complex order from the query if no valid sortParam is provided
	orderByClause = "ORDER BY __order ASC"

	if sortParam != "" {
		sortField := strings.TrimPrefix(sortParam, "-")
		direction := "ASC"
		if strings.HasPrefix(sortParam, "-") {
			direction = "DESC"
		}
		
		// Whitelist fields for security
		switch sortField {
		case "submitted":
			orderByClause = fmt.Sprintf("ORDER BY t.submitted_at_utc %s", direction)
		case "group_1":
			orderByClause = fmt.Sprintf("ORDER BY t.group_1 %s", direction)
		// Default case uses the complex __order
		}
	}

	// 2. Construct the final query string
	finalQuery := fmt.Sprintf(complexReviewInfoQuery, orderByClause)

	// 3. Execute the query using GORM's Raw method
	var out []ReviewInfo

	// Parameters: project, project, limit, offset
	result := db.WithContext(ctx).Raw(
		finalQuery,
		project, // ?1: max_modified WHERE project
		project, // ?2: latest_reviews WHERE project
		limit,   // ?3: LIMIT
		offset,  // ?4: OFFSET
	).Scan(&out)

	if result.Error != nil {
		return nil, result.Error
	}

	return out, nil
}

package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"

	"myapp/reviewservice/reviewinfo" // Adjust the import path based on your go.mod
	"github.com/gin-gonic/gin"
    "gorm.io/driver/postgres" // Or: gorm.io/driver/mysql
	"gorm.io/gorm"
)

// Global database and repository instances
var (
	gormDB *gorm.DB
	reviewInfoRepository = &reviewinfo.ReviewInfoRepository{} 
)

func main() {
	// 1. Initialize Database Connection (Replace with your actual DSN)
    // Example for PostgreSQL:
    dsn := "host=localhost user=youruser password=yourpassword dbname=yourdb port=5432 sslmode=disable TimeZone=Asia/Shanghai"
    
	var err error
	gormDB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	fmt.Println("Successfully connected to the database with GORM.")

	// 2. Setup Gin Router
	router := gin.Default()
	
	// Register the API handler
	setupRoutes(router)

	// 3. Start the server
	log.Fatal(router.Run(":8080"))
}

// setupRoutes configures the API routes.
func setupRoutes(router *gin.Engine) {
	router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
		// 1. Get and Validate Path/Query Parameters
		project := strings.TrimSpace(c.Param("project"))

		if project == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
			return
		}

		// Use c.DefaultQuery for safe type conversion with defaults
		limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
		offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
		
		// --- Get optional sort parameter ---
		sortParam := c.Query("sort") 
		// -----------------------------------

		// 2. Call the Repository method
		out, err := reviewInfoRepository.ListLatestSubmissionsWithSort(
			c.Request.Context(), 
			gormDB, 
			project, 
			limit, 
			offset, 
			sortParam,
		)
		
		if err != nil {
			log.Printf("[review-submissions] query error for project %s: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "An internal database error occurred."})
			return
		}

		// 3. Respond
		log.Printf("[review-submissions] Fetched %d rows for project %s (limit=%d offset=%d)", len(out), project, limit, offset)
		c.IndentedJSON(http.StatusOK, out)
	})
}





Goal	URL Example			
Basic Call (Default limit/offset)	/api/latest/review-submissions/potoo			
Pagination (Page 2, 20 items per page)	/api/latest/review-submissions/potoo?limit=20&offset=20			
Sorting (Sort by group_1 descending)	/api/latest/review-submissions/potoo?sort=-group_1			
Combined (Paginated, sorted results)	/api/latest/review-submissions/potoo?limit=10&offset=50&sort=submitted			
				
				
				
				
