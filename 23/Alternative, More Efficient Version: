-- Single query approach with reusability
WITH asset_filter AS (
  SELECT 'heroA' AS group_1, 'main' AS relation UNION ALL
  SELECT 'heroB', 'main' UNION ALL
  SELECT 'tree01', 'bg'
),
latest_phase AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.modified_at_utc,
    JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]')) AS leaf_group_name,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS rn
  FROM t_review_info AS ri
  INNER JOIN asset_filter af
          ON ri.group_1 = af.group_1
         AND ri.relation = af.relation
  WHERE ri.project = 'MY_PROJECT'
    AND ri.root = 'assets'
    AND ri.deleted = 0
),
latest_with_metadata AS (
  SELECT
    lp.*,
    gc.path AS group_category_path,
    SUBSTRING_INDEX(COALESCE(gc.path, ''), '/', 1) AS top_group_node
  FROM latest_phase lp
  LEFT JOIN t_group_category_group gcg
         ON gcg.project = lp.project
        AND gcg.deleted = 0
        AND gcg.path = lp.leaf_group_name
  LEFT JOIN t_group_category gc
         ON gc.id = gcg.group_category_id
        AND gc.deleted = 0
        AND gc.root = 'assets'
  WHERE lp.rn = 1
),
ordered AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      ORDER BY LOWER(group_1) ASC, LOWER(relation) ASC
    ) AS _order
  FROM latest_with_metadata
  -- Add status filters here if needed
)

-- For count:
SELECT COUNT(*) AS total_count FROM ordered;

-- For paginated data:
SELECT
  root,
  project,
  group_1,
  relation,
  phase,
  work_status,
  approval_status,
  submitted_at_utc,
  leaf_group_name,
  group_category_path,
  top_group_node,
  _order
FROM ordered
ORDER BY _order ASC
LIMIT 50 OFFSET 0;
