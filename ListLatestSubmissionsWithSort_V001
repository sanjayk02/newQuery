package reviewinfo

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// Output row (unchanged)
type ReviewInfo struct {
	Root             string `json:"root"`
	Project          string `json:"project"`
	Group1           string `json:"group_1"`
	Relation         string `json:"relation"`
	Phase            string `json:"phase"`
	WorkStatus       string `json:"work_status"`
	SubmittedAtUtc   string `json:"submitted_at_utc"`
	ModifiedAtUtc    string `json:"modified_at_utc"`
	ExecutedComputer string `json:"executed_computer"`
}

type ReviewInfoRepository struct{}

// 3 string placeholders:
// 1 & 2: WHERE clauses (%s)
// 3: final ORDER BY (%s)
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project, root, group_1, relation, phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM t_review_info AS t1
    WHERE %s -- Dynamic filter 1
    GROUP BY project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root, b.project, b.group_1, b.phase, b.relation, b.work_status,
        b.submitted_at_utc, b.modified_at_utc, b.executed_computer
    FROM max_modified AS a
    INNER JOIN t_review_info AS b
      ON  a.project = b.project
      AND a.root    = b.root
      AND a.group_1 = b.group_1
      AND a.relation= b.relation
      AND a.phase   = b.phase
      AND a.modified_at_utc = b.modified_at_utc
    WHERE %s -- Dynamic filter 2
),
ordered AS (
    SELECT
        t1.*,
        ROW_NUMBER() OVER (ORDER BY t1.group_1 ASC, t1.relation ASC) AS _order
    FROM latest_reviews t1
),
offset_ordered AS (
    SELECT
        c.*,
        c._order AS __order -- FIXED: Stable order based on group_1
    FROM ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY
              b.submitted_at_utc DESC, -- FIXED: Ranking based ONLY on time
              b.modified_at_utc  DESC
        ) AS _rank
    FROM offset_ordered b
)
SELECT
    root, project, group_1, relation, phase, work_status, submitted_at_utc,
    modified_at_utc, executed_computer, __order
FROM (
    SELECT * FROM ranked WHERE _rank = 1
) AS t
%s -- Final ORDER BY
LIMIT ? OFFSET ?;
`

// ListLatestSubmissionsWithSort supports optional root & phase filters.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	rootParam string,   
	phaseParam string,  
	limit, offset int,
	sortParam string,   
) ([]ReviewInfo, error) {

	// --- 1. Define SQL Wildcards for Filtering ---
	actualRoot := rootParam
	if actualRoot == "" {
		actualRoot = "%" // Wildcard
	}
	actualPhase := phaseParam
	if actualPhase == "" {
		actualPhase = "%" // Wildcard (Returns all 32 assets)
	}

	// The base filter structure uses LIKE ? for optional fields, and ? for required project
	baseFilter := "project = ? AND deleted = 0 AND root LIKE ? AND phase LIKE ?"

	// --- 2. Alias the Filters ---
	
	// Clauses for max_modified (aliased as t1)
	filterClauseT1 := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(
		baseFilter, "project", "t1.project"),
		"root", "t1.root"),
		"phase", "t1.phase")
	filterClauseT1 = strings.ReplaceAll(filterClauseT1, "deleted", "t1.deleted")

	// Clauses for latest_reviews (aliased as b)
	filterClauseB := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(
		baseFilter, "project", "b.project"),
		"root", "b.root"),
		"phase", "b.phase")
	filterClauseB = strings.ReplaceAll(filterClauseB, "deleted", "b.deleted")

	// --- 3. Determine ORDER BY (whitelist) ---
	allowed := map[string]string{
		"group_1": "t.group_1",
		"relation": "t.relation",
		"phase": "t.phase",
		"work": "t.work_status", 
		"work_status": "t.work_status",
		"submitted": "t.submitted_at_utc",
		"modified": "t.modified_at_utc",
		"__order": "t.__order",
	}

	orderByClause := "ORDER BY t.__order ASC, t.group_1 ASC, t.relation ASC"
	if sortParam != "" {
		dir := "ASC"
		field := sortParam
		if strings.HasPrefix(field, "-") {
			dir = "DESC"
			field = strings.TrimPrefix(field, "-")
		}
		if col, ok := allowed[field]; ok {
			orderByClause = fmt.Sprintf("ORDER BY %s %s, t.__order ASC, t.group_1 ASC", col, dir)
		}
	}

	// --- 4. Build final SQL and Parameter Set ---
    // Inject three placeholders: two WHERE clauses, one ORDER BY.
	finalQuery := fmt.Sprintf(
        complexReviewInfoQuery, 
        filterClauseT1, 
        filterClauseB, 
        orderByClause)

	// Function to build the parameter set for one WHERE clause
	buildParamSet := func() []interface{} {
		// Parameters must match baseFilter: project, root LIKE ?, phase LIKE ?
		return []interface{}{project, actualRoot, actualPhase} 
	}

	params := append([]interface{}{}, buildParamSet()...) // for t1
	params = append(params, buildParamSet()...)           // for b
	params = append(params, limit, offset)                // LIMIT/OFFSET

	var out []ReviewInfo
	if err := db.WithContext(ctx).Raw(finalQuery, params...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}


package main

import (
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	reviewinfo "your/module/path/reviewinfo" // TODO: change to your real module path
)

// --- tiny helper: normalize sort into "-field1,field2" ---
func canonicalizeSort(sortCSV, dirCSV, descFlag string) string {
	sortCSV = strings.TrimSpace(sortCSV)
	dirCSV = strings.TrimSpace(strings.ToUpper(dirCSV))
	descFlag = strings.TrimSpace(strings.ToLower(descFlag))

	if sortCSV == "" {
		return ""
	}
	// already using minus form and no extra hints
	if strings.HasPrefix(sortCSV, "-") && dirCSV == "" && descFlag == "" {
		return sortCSV
	}

	// make single-field canonical; easy to extend for multi later
	field := strings.TrimPrefix(sortCSV, "-")
	isDesc := dirCSV == "DESC" || descFlag == "true" || descFlag == "1" || descFlag == "yes"

	if isDesc {
		return "-" + field
	}
	return field
}

func RegisterLatestReviewSubmissionsRoute(
	router *gin.Engine,
	gormDB *gorm.DB,
	repo *reviewinfo.ReviewInfoRepository,
) {
	router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
		// 1. Get and Validate Path/Query Parameters
		project := strings.TrimSpace(c.Param("project"))
		if project == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
			return
		}

		rootParam := c.Query("root") 
		phaseParam := c.Query("phase") 

		// Safe integer parsing and bounds checking
		limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
		if limit <= 0 {
			limit = 50
		}
		if limit > 500 {
			limit = 500
		}
		offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
		if offset < 0 {
			offset = 0
		}

		// hybrid sort inputs
		sortParam := canonicalizeSort(
			c.Query("sort"),
			c.DefaultQuery("dir", ""),
			c.DefaultQuery("desc", ""),
		)

		// 2. Execute repository method
		out, err := repo.ListLatestSubmissionsWithSort(
			c.Request.Context(),
			gormDB,
			project,
			rootParam,
			phaseParam, 
			limit,
			offset,
			sortParam,
		)
		if err != nil {
			log.Printf("[review-submissions] query error project=%s: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "internal database error"})
			return
		}

		// 3. Respond
		log.Printf("[review-submissions] fetched=%d project=%s root=%s phase=%s limit=%d offset=%d sort=%s",
			len(out), project, rootParam, phaseParam, limit, offset, sortParam)

		c.IndentedJSON(http.StatusOK, gin.H{
			"project": project,
			"root":    rootParam,
			"phase":   phaseParam,
			"limit":   limit,
			"offset":  offset,
			"sort":    sortParam,
			"count":   len(out),
			"data":    out,
			"ts":      time.Now().UTC().Format(time.RFC3339),
		})
	})
}
