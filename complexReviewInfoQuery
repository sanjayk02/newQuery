package reviewinfo

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// ReviewInfo represents the final output of the query.
type ReviewInfo struct {
	Root                 string `json:"root"`
	Project              string `json:"project"`
	Group1               string `json:"group_1"`
	Relation             string `json:"relation"`
	Phase                string `json:"phase"`
	WorkStatus           string `json:"work_status"`
	SubmittedAtUtc       string `json:"submitted_at_utc"`
	ModifiedAtUtc        string `json:"modified_at_utc"`
	ExecutedComputer     string `json:"executed_computer"`
}

// ReviewInfoRepository defines the methods for interacting with the t_review_info table.
type ReviewInfoRepository struct {
    // In a production app, you might inject the DB here.
}

// --- CORRECTED SQL CONSTANT ---

// complexReviewInfoQuery uses %s for dynamic WHERE clauses and ? for LIMIT/OFFSET.
const complexReviewInfoQuery = `
WITH max_modified AS (
    SELECT
        project,
        root,
        group_1,
        relation,
        phase,
        MAX(modified_at_utc) AS modified_at_utc
    FROM
        t_review_info
    WHERE
        %s -- Dynamic WHERE clause 1
    GROUP BY
        project, root, group_1, relation, phase
),
latest_reviews AS (
    SELECT
        b.root,
        b.project,
        b.group_1,
        b.phase,
        b.relation,
        b.work_status,
        b.submitted_at_utc,
        b.modified_at_utc,
        b.executed_computer
    FROM
        max_modified AS a
    INNER JOIN
        t_review_info AS b
    ON
        a.project = b.project AND
        a.root = b.root AND
        a.group_1 = b.group_1 AND
        a.relation = b.relation AND
        a.phase = b.phase AND
        a.modified_at_utc = b.modified_at_utc
    WHERE
        %s -- Dynamic WHERE clause 2 (must match)
    ORDER BY
        b.submitted_at_utc ASC 
),
ordered AS (
    SELECT
        t1.*,
        ROW_NUMBER() OVER (
            ORDER BY t1.group_1 ASC -- Initial sort based on group_1
        ) AS _order
    FROM
        latest_reviews t1
),
offset_ordered AS (
    SELECT
        c.*,
        CASE WHEN c.phase = 'rel' THEN c._order ELSE 100000 + c._order END AS __order -- Phase prioritization ('rel' first)
    FROM
        ordered c
),
ranked AS (
    SELECT
        b.*,
        ROW_NUMBER() OVER (
            PARTITION BY b.root, b.project, b.group_1, b.relation
            ORDER BY CASE WHEN b.phase = 'rel' THEN 0 ELSE 1 END -- Ranking: 'rel' first
        ) AS _rank
    FROM
        offset_ordered b
)
SELECT
    root,
    project,
    group_1,
    relation,
    phase,
    work_status,
    submitted_at_utc,
    modified_at_utc,
    executed_computer,
    __order -- Necessary for final ORDER BY
FROM
(
    SELECT
        *
    FROM
        ranked
    WHERE
        _rank = 1
) AS t
%s -- Placeholder for dynamic final ORDER BY clause
LIMIT ? OFFSET ?
`

// ListLatestSubmissionsWithSort executes the complex SQL query with dynamic parameters.
func (r *ReviewInfoRepository) ListLatestSubmissionsWithSort(
	ctx context.Context,
	db *gorm.DB,
	project string,
	rootParam string, // Now accepts root
	limit, offset int,
	sortParam string,
) ([]ReviewInfo, error) {

	// 1. Build the Dynamic WHERE Clause and parameters
	filterQuery := "project = ? AND deleted = 0"
	var queryParams []interface{}
	queryParams = append(queryParams, project)

	if rootParam != "" {
		filterQuery += " AND root = ?"
		queryParams = append(queryParams, rootParam)
	}

	// 2. Determine the dynamic ORDER BY clause
	orderByClause := "ORDER BY __order ASC" // Default order
	if sortParam != "" {
		sortField := strings.TrimPrefix(sortParam, "-")
		direction := "ASC"
		if strings.HasPrefix(sortParam, "-") {
			direction = "DESC"
		}

		switch sortField {
		case "submitted":
			orderByClause = fmt.Sprintf("ORDER BY t.submitted_at_utc %s", direction)
		case "group_1":
			orderByClause = fmt.Sprintf("ORDER BY t.group_1 %s", direction)
		}
	}

	// 3. Construct the final query string and parameter list
	finalQuery := fmt.Sprintf(complexReviewInfoQuery, filterQuery, filterQuery, orderByClause)

	// We pass the parameters for the two WHERE clauses, plus limit and offset.
	var finalParams []interface{}
	finalParams = append(finalParams, queryParams...) // Params for max_modified WHERE
	finalParams = append(finalParams, queryParams...) // Params for latest_reviews WHERE
	finalParams = append(finalParams, limit, offset)  // Params for LIMIT and OFFSET

	// 4. Execute the query using GORM's Raw method
	var out []ReviewInfo

	result := db.WithContext(ctx).Raw(
		finalQuery,
		finalParams..., // Pass the combined array of parameters
	).Scan(&out)

	if result.Error != nil {
		return nil, result.Error
	}

	return out, nil
}


package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"

	"myapp/reviewservice/reviewinfo" // Adjust the import path based on your go.mod
	"github.com/gin-gonic/gin"
	"gorm.io/driver/postgres" // Use appropriate driver (e.g., mysql)
	"gorm.io/gorm"
)

// Global database and repository instances
var (
	gormDB *gorm.DB
	reviewInfoRepository = &reviewinfo.ReviewInfoRepository{} 
)

func main() {
	// 1. Initialize Database Connection (MOCK/REPLACE THIS WITH YOUR REAL DSN)
    // Example for PostgreSQL:
    dsn := "host=localhost user=youruser password=yourpassword dbname=yourdb port=5432 sslmode=disable TimeZone=Asia/Shanghai"
    
	var err error
	gormDB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	fmt.Println("Successfully connected to the database with GORM.")

	// 2. Setup Gin Router
	router := gin.Default()
	setupRoutes(router)

	// 3. Start the server
	log.Fatal(router.Run(":8080"))
}

// setupRoutes configures the API routes.
func setupRoutes(router *gin.Engine) {
	router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
		// 1. Get and Validate Path/Query Parameters
		project := strings.TrimSpace(c.Param("project"))
        rootParam := c.Query("root") // <-- Extract the optional root query parameter
        
		if project == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
			return
		}

		// Use c.DefaultQuery for safe type conversion with defaults
		limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
		offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
		sortParam := c.Query("sort") 

		// 2. Call the Repository method with all parameters
		out, err := reviewInfoRepository.ListLatestSubmissionsWithSort(
			c.Request.Context(), 
			gormDB, 
			project, 
			rootParam, // Pass the root parameter
			limit, 
			offset, 
			sortParam,
		)
		
		if err != nil {
			log.Printf("[review-submissions] query error for project %s: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "An internal database error occurred."})
			return
		}

		// 3. Respond
		log.Printf("[review-submissions] Fetched %d rows for project %s (root=%s limit=%d offset=%d)", 
            len(out), project, rootParam, limit, offset)
		c.IndentedJSON(http.StatusOK, out)
	})
}
