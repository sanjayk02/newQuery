apiRouter.GET("/projects/:project/reviews/assets/pivot", func(c *gin.Context) {

    project := strings.TrimSpace(c.Param("project"))
    if project == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "project is required in the path"})
        return
    }

    root := c.DefaultQuery("root", defaultRoot)

    // ---- Phase Validation ----
    phaseParam := strings.TrimSpace(c.Query("phase"))
    if phaseParam != "" {
        lp := strings.ToLower(phaseParam)
        if lp != "none" {
            if _, ok := allowedPhases[lp]; !ok {
                c.JSON(http.StatusBadRequest, gin.H{
                    "error":          "invalid phase",
                    "allowed_phases": []string{"mdl", "rig", "bld", "dsn", "ldv", "none"},
                })
                return
            }
        }
    }

    // ---- Pagination ----
    page := mustAtoi(c.DefaultQuery("page", "1"))
    page = int(math.Max(float64(page), 1))
    perPage := clampPerPage(mustAtoi(c.DefaultQuery("per_page", fmt.Sprint(defaultPerPage))))
    limit := perPage
    offset := (page - 1) * perPage

    // ---- Sorting ----
    sortParam := c.DefaultQuery("sort", "group_1")
    dirParam := c.DefaultQuery("dir", "ASC")
    orderKey := normalizeSortKey(sortParam)
    dir := normalizeDir(dirParam)

    // ---- View Mode ----
    viewParam := strings.ToLower(strings.TrimSpace(c.DefaultQuery("view", "list")))
    isGroupedView := viewParam == "group" || viewParam == "grouped" || viewParam == "category"

    // ---- Filters ----
    assetNameKey := strings.TrimSpace(c.Query("name"))
    approvalStatuses := parseStatusParam(c, "approval_status")
    workStatuses := parseStatusParam(c, "work_status")

    // ---- Preferred Phase Logic ----
    preferredPhase := phaseParam
    if orderKey == "group1_only" || orderKey == "relation_only" || orderKey == "group_rel_submitted" {
        preferredPhase = "none"
    }
    if preferredPhase == "" {
        preferredPhase = "none"
    }

    ctx, cancel := context.WithTimeout(c.Request.Context(), 7*time.Second)
    defer cancel()

    // ---------------------------------------------------------------
    // CASE 1: LIST VIEW - keep current DB pagination behavior
    // ---------------------------------------------------------------
    if !isGroupedView {
        assets, total, err := reviewInfoRepository.ListAssetsPivot(
            ctx,
            project, root,
            preferredPhase,
            orderKey,
            dir,
            limit, offset,
            assetNameKey,
            approvalStatuses,
            workStatuses,
        )
        if err != nil {
            log.Printf("[pivot-submissions] query error for project %q: %v", project, err)
            c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
            return
        }

        c.Header("Cache-Control", "public, max-age=15")
        baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
        if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
            c.Header("Link", links)
        }

        resp := gin.H{
            "assets":    assets,
            "total":     total,
            "page":      page,
            "per_page":  perPage,
            "sort":      sortParam,
            "dir":       strings.ToLower(dir),
            "project":   project,
            "root":      root,
            "has_next":  offset+limit < int(total),
            "has_prev":  page > 1,
            "page_last": (int(total) + perPage - 1) / perPage,
            "view":      viewParam,
        }
        if phaseParam != "" {
            resp["phase"] = phaseParam
        }
        if assetNameKey != "" {
            resp["name"] = assetNameKey
        }
        if len(approvalStatuses) > 0 {
            resp["approval_status"] = approvalStatuses
        }
        if len(workStatuses) > 0 {
            resp["work_status"] = workStatuses
        }

        c.IndentedJSON(http.StatusOK, resp)
        return
    }

    // ---------------------------------------------------------------
    // CASE 2: GROUPED VIEW - group first, then paginate
    // ---------------------------------------------------------------

    // 1) Fetch ALL matching assets (no pagination here).
    //    We still let the repo compute "total" for us.
    //    Use a very large limit and offset=0,
    //    or create a dedicated "ListAllAssetsPivot" if you prefer.
    allLimit := 1000000
    assetsAll, total, err := reviewInfoRepository.ListAssetsPivot(
        ctx,
        project, root,
        preferredPhase,
        "group1_only", // base: stable order by name
        "ASC",
        allLimit, 0,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        log.Printf("[pivot-submissions] query error (group view) for project %q: %v", project, err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
        return
    }

    // 2) Group ALL assets by top_group_node
    dirUpper := strings.ToUpper(dir)
    if dirUpper != "ASC" && dirUpper != "DESC" {
        dirUpper = "ASC"
    }
    groupedAll := repository.GroupAndSortByTopNode(
        assetsAll,
        repository.SortDirection(dirUpper),
    )

    // 3) Flatten groups in that order â†’ flat slice in group order
    flat := make([]repository.AssetPivot, 0, len(assetsAll))
    for _, g := range groupedAll {
        flat = append(flat, g.Items...)
    }

    // 4) Apply pagination on the flat, grouped-ordered slice
    totalAssets := len(flat)
    start := offset
    if start > totalAssets {
        start = totalAssets
    }
    end := start + limit
    if end > totalAssets {
        end = totalAssets
    }
    pageSlice := flat[start:end]

    // 5) Re-group only the current page slice
    pageGroups := repository.GroupAndSortByTopNode(
        pageSlice,
        repository.SortDirection(dirUpper),
    )

    // ---- Headers ----
    c.Header("Cache-Control", "public, max-age=15")
    baseURL := fmt.Sprintf("/api/projects/%s/reviews/assets/pivot", project)
    if links := paginationLinks(baseURL, page, perPage, int(total)); links != "" {
        c.Header("Link", links)
    }

    // ---- Response ----
    resp := gin.H{
        "assets":    pageSlice, // optional: keep flat slice for debugging / UI
        "groups":    pageGroups,
        "total":     total, // total number of matching assets
        "page":      page,
        "per_page":  perPage,
        "sort":      sortParam,
        "dir":       strings.ToLower(dir),
        "project":   project,
        "root":      root,
        "has_next":  offset+limit < int(totalAssets),
        "has_prev":  page > 1,
        "page_last": (int(totalAssets) + perPage - 1) / perPage,
        "view":      viewParam,
    }

    if phaseParam != "" {
        resp["phase"] = phaseParam
    }
    if assetNameKey != "" {
        resp["name"] = assetNameKey
    }
    if len(approvalStatuses) > 0 {
        resp["approval_status"] = approvalStatuses
    }
    if len(workStatuses) > 0 {
        resp["work_status"] = workStatuses
    }

    c.IndentedJSON(http.StatusOK, resp)
})
