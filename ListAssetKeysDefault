package repository

import (
	"context"

	"gorm.io/gorm"
)

// AssetKeyRow is the simple model for the final result.
type AssetKeyRow struct {
	Project  string `json:"project"  gorm:"column:project"`
	Root     string `json:"root"     gorm:"column:root"`
	Group1   string `json:"group_1"  gorm:"column:group_1"`
	Relation string `json:"relation" gorm:"column:relation"`
}

// ReviewInfo Repository type
type ReviewInfo struct{}

// ========================================================================
// ListAssetKeysDefault
// ========================================================================
// ListAssetKeysDefault retrieves unique asset keys for a project, 
// using a fixed internal sorting logic (group_1 ASC) and pagination.
func (r *ReviewInfo) ListAssetKeysDefault(
	ctx context.Context,
	db *gorm.DB,
	project string,
	limit, offset int,
) ([]AssetKeyRow, error) {

	// The SQL query provided in the request
	const q = `
WITH ordered AS (
	SELECT
		*,
		ROW_NUMBER() OVER (
			ORDER BY group_1 ASC 
		) AS _order
	FROM (
		SELECT b.* FROM (
			SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
			FROM t_review_info
			WHERE project = ? AND root = 'assets' AND deleted = 0 
			GROUP BY project, root, group_1, relation, phase
		) AS a 
		LEFT JOIN
		(
			SELECT root, project, group_1, phase, relation, work_status, submitted_at_utc, modified_at_utc, executed_computer 
			FROM t_review_info
			WHERE project = ? AND root = 'assets' AND deleted = 0
		) AS b 
		ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1 AND
		a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc
		ORDER BY submitted_at_utc ASC -- This inner sort is harmless but can be removed
	) AS k
),
offset_ordered AS (
	SELECT c.*,
	CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order 
	FROM ordered c
),
ranked AS (
	SELECT b.*,
	ROW_NUMBER() OVER (
		PARTITION BY b.root, b.project, b.group_1, b.relation
		ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
	) AS _rank
	FROM offset_ordered b
)
SELECT root, project, group_1, relation 
FROM (
	SELECT *
	FROM ranked
	WHERE _rank=1
) AS t
ORDER BY __order ASC
LIMIT ? OFFSET ?;`

	args := []any{
		project, // First project filter
		project, // Second project filter
		limit,   // LIMIT
		offset,  // OFFSET
	}

	var out []AssetKeyRow
	if err := db.WithContext(ctx).Raw(q, args...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}
