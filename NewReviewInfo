// somewhere in your setup/bootstrap (once):
reviewInfoRepo, err := repository.NewReviewInfo(gormDB)
if err != nil {
    log.Fatalf("review repo init: %v", err)
}

// unauthenticated endpoint
router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
    project := c.Param("project")
    if project == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "missing :project"})
        return
    }

    // phase bias: mdl/rig/bld/dsn/ldv or "group_1" (default)
    phase := strings.ToLower(c.DefaultQuery("phase", "group_1"))
    switch phase {
    case "mdl", "rig", "bld", "dsn", "ldv", "group_1":
        // ok
    default:
        phase = "group_1"
    }

    // sort direction
    order := strings.ToUpper(c.DefaultQuery("order", "ASC"))
    if order != "ASC" && order != "DESC" {
        order = "ASC"
    }

    // pagination
    page := 1
    if v := c.DefaultQuery("page", "1"); v != "" {
        if n, err := strconv.Atoi(v); err == nil && n > 0 {
            page = n
        }
    }
    perPage := 15
    if v := c.DefaultQuery("per_page", "15"); v != "" {
        if n, err := strconv.Atoi(v); err == nil && n > 0 {
            if n > 200 { // hard cap to prevent abuse
                n = 200
            }
            perPage = n
        }
    }

    params := &entity.AssetListParams{
        Project: project,
        Page:    page,
        PerPage: perPage,
    }

    rows, total, err := reviewInfoRepo.ListLatestAssetReviewInfoForAssets(gormDB, params, phase, order)
    if err != nil {
        log.Printf("latest review-submissions error: %v", err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": "internal error"})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "project":  project,
        "phase":    phase,
        "order":    order,
        "page":     page,
        "per_page": perPage,
        "total":    total,
        "data":     rows,
    })
})
