func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	preferredPhase string, // ignored (API compatibility)
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {

	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	db := r.db.WithContext(ctx)

	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	statusWhere, statusArgs := buildPhaseAwareStatusWhere(
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)

	sql := `
WITH latest_phase AS (
  SELECT
    project,
    root,
    group_1,
    relation,
    phase,
    work_status,
    approval_status,
    modified_at_utc,
    ROW_NUMBER() OVER (
      PARTITION BY project, root, group_1, relation, phase
      ORDER BY modified_at_utc DESC
    ) AS rn
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0` + nameCond + `
)
SELECT COUNT(*) FROM (
  SELECT project, root, group_1, relation
  FROM latest_phase
  WHERE rn = 1` + statusWhere + `
  GROUP BY project, root, group_1, relation
) x;
`

	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)

	var total int64
	if err := db.Raw(sql, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}

	return total, nil
}

func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string,
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	orderOuter := buildOrderClause("", orderKey, direction)
	orderInner := buildOrderClause("b", orderKey, direction)

	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	statusWhere, statusArgs := buildPhaseAwareStatusWhere(
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)

	sql := fmt.Sprintf(`
WITH latest_phase AS (
  SELECT *,
         ROW_NUMBER() OVER (
           PARTITION BY project, root, group_1, relation, phase
           ORDER BY modified_at_utc DESC
         ) rn
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0%s
),
keys AS (
  SELECT project, root, group_1, relation
  FROM latest_phase
  WHERE rn = 1%s
  GROUP BY project, root, group_1, relation
),
ordered AS (
  SELECT b.*,
         ROW_NUMBER() OVER (ORDER BY %s) ord
  FROM (
    SELECT *
    FROM latest_phase
    WHERE rn = 1
  ) b
  JOIN keys k
    ON k.project=b.project
   AND k.root=b.root
   AND k.group_1=b.group_1
   AND k.relation=b.relation
  ORDER BY %s
),
ranked AS (
  SELECT *,
         ROW_NUMBER() OVER (
           PARTITION BY root, project, group_1, relation
           ORDER BY
             CASE
               WHEN ? = 1 THEN 0
               WHEN phase = ? THEN 0
               ELSE 1
             END,
             modified_at_utc DESC
         ) rnk
  FROM ordered
)
SELECT
  root,
  project,
  group_1,
  relation,
  phase,
  submitted_at_utc
FROM ranked
WHERE rnk = 1
ORDER BY ord
LIMIT ? OFFSET ?;
`, nameCond, statusWhere, orderOuter, orderInner)

	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)
	args = append(args,
		phaseGuard,
		preferredPhase,
		limit,
		offset,
	)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}

	return rows, nil
}

func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// 1️⃣ total count
	total, err := r.CountLatestSubmissions(
		ctx,
		project,
		root,
		assetNameKey,
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}

	// 2️⃣ ordered asset keys (LIST VIEW ORDER)
	keys, err := r.ListLatestSubmissionsDynamic(
		ctx,
		project,
		root,
		preferredPhase,
		orderKey,
		direction,
		limit,
		offset,
		assetNameKey,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// 3️⃣ fetch latest phase rows for these keys
	var sb strings.Builder
	var params []any

	sb.WriteString(`
WITH latest_phase AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.modified_at_utc,
    JSON_UNQUOTE(JSON_EXTRACT(ri.` + "`groups`" + `, '$[0]')) AS leaf_group_name,
    gc.path AS group_category_path,
    SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) rn
  FROM t_review_info ri
  LEFT JOIN t_group_category_group gcg
         ON gcg.project = ri.project
        AND gcg.deleted = 0
        AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(ri.` + "`groups`" + `, '$[0]'))
  LEFT JOIN t_group_category gc
         ON gc.id = gcg.group_category_id
        AND gc.deleted = 0
        AND gc.root = 'assets'
  WHERE ri.project = ? AND ri.root = ? AND ri.deleted = 0
    AND (
`)

	params = append(params, project, root)

	for i, k := range keys {
		if i > 0 {
			sb.WriteString(" OR ")
		}
		sb.WriteString("(ri.group_1 = ? AND ri.relation = ?)")
		params = append(params, k.Group1, k.Relation)
	}

	sb.WriteString(`
    )
)
SELECT *
FROM latest_phase
WHERE rn = 1;
`)

	var phases []phaseRow
	if err := r.db.WithContext(ctx).Raw(sb.String(), params...).Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// 4️⃣ stitch pivot rows (ORDER PRESERVED)
	type keyStruct struct {
		p, r, g, rel string
	}

	m := make(map[keyStruct]*AssetPivot, len(keys))
	orderedPtrs := make([]*AssetPivot, 0, len(keys))

	for _, k := range keys {
		id := keyStruct{k.Project, k.Root, k.Group1, k.Relation}
		ap := &AssetPivot{
			Root:     k.Root,
			Project:  k.Project,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
		m[id] = ap
		orderedPtrs = append(orderedPtrs, ap)
	}

	for _, pr := range phases {
		id := keyStruct{pr.Project, pr.Root, pr.Group1, pr.Relation}
		if ap, ok := m[id]; ok {

			if ap.LeafGroupName == "" {
				ap.LeafGroupName = pr.LeafGroupName
				ap.GroupCategoryPath = pr.GroupCategoryPath
				ap.TopGroupNode = pr.TopGroupNode
			}

			switch strings.ToLower(pr.Phase) {
			case "mdl":
				ap.MDLWorkStatus = pr.WorkStatus
				ap.MDLApprovalStatus = pr.ApprovalStatus
				ap.MDLSubmittedAtUTC = pr.SubmittedAtUTC
			case "rig":
				ap.RIGWorkStatus = pr.WorkStatus
				ap.RIGApprovalStatus = pr.ApprovalStatus
				ap.RIGSubmittedAtUTC = pr.SubmittedAtUTC
			case "bld":
				ap.BLDWorkStatus = pr.WorkStatus
				ap.BLDApprovalStatus = pr.ApprovalStatus
				ap.BLDSubmittedAtUTC = pr.SubmittedAtUTC
			case "dsn":
				ap.DSNWorkStatus = pr.WorkStatus
				ap.DSNApprovalStatus = pr.ApprovalStatus
				ap.DSNSubmittedAtUTC = pr.SubmittedAtUTC
			case "ldv":
				ap.LDVWorkStatus = pr.WorkStatus
				ap.LDVApprovalStatus = pr.ApprovalStatus
				ap.LDVSubmittedAtUTC = pr.SubmittedAtUTC
			}
		}
	}

	out := make([]AssetPivot, len(orderedPtrs))
	for i, ap := range orderedPtrs {
		out[i] = *ap
	}

	return out, total, nil
}

