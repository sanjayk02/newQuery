// CountLatestSubmissions returns total asset count (for pagination) after filters.
func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	preferredPhase string, // kept for API compatibility; ignored in filtering
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	db := r.db.WithContext(ctx)

	// Subquery for latest phase rows
	latestPhaseSubquery := db.Model(&model.ReviewInfo{}).
		Select(`
			project,
			root,
			group_1,
			relation,
			phase,
			work_status,
			approval_status,
			submitted_at_utc,
			modified_at_utc,
			ROW_NUMBER() OVER (
				PARTITION BY project, root, group_1, relation, phase
				ORDER BY modified_at_utc DESC
			) AS rn
		`).
		Where("project = ?", project).
		Where("root = ?", root).
		Where("deleted = 0")

	// Apply name filter if provided
	if strings.TrimSpace(assetNameKey) != "" {
		searchTerm := strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
		latestPhaseSubquery = latestPhaseSubquery.Where("LOWER(group_1) LIKE ?", searchTerm)
	}

	// Create CTE for latest phase
	latestPhaseCTE := db.Table("(?) AS latest_phase", latestPhaseSubquery)

	// Build filtered assets query
	filteredAssets := latestPhaseCTE.
		Select("project, root, group_1, relation").
		Where("rn = 1")

	// Apply approval status filter
	if len(approvalStatuses) > 0 {
		// Convert to lowercase for case-insensitive comparison
		lowerStatuses := make([]string, len(approvalStatuses))
		for i, status := range approvalStatuses {
			lowerStatuses[i] = strings.ToLower(strings.TrimSpace(status))
		}
		filteredAssets = filteredAssets.Where("LOWER(approval_status) IN ?", lowerStatuses)
	}

	// Apply work status filter
	if len(workStatuses) > 0 {
		// Convert to lowercase for case-insensitive comparison
		lowerStatuses := make([]string, len(workStatuses))
		for i, status := range workStatuses {
			lowerStatuses[i] = strings.ToLower(strings.TrimSpace(status))
		}
		filteredAssets = filteredAssets.Where("LOWER(work_status) IN ?", lowerStatuses)
	}

	// Group by asset
	filteredAssets = filteredAssets.Group("project, root, group_1, relation")

	// Count distinct assets
	var total int64
	err := db.Table("(?) AS x", filteredAssets).Count(&total).Error
	if err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}

	return total, nil
}

// ListLatestSubmissionsDynamic returns one "primary" row per asset for a page.
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string,
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	db := r.db.WithContext(ctx)

	// Phase guard logic
	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	// Build keys subquery (filtered assets)
	latestPhaseSubquery := db.Model(&model.ReviewInfo{}).
		Select(`
			project,
			root,
			group_1,
			relation,
			phase,
			work_status,
			approval_status,
			submitted_at_utc,
			modified_at_utc,
			ROW_NUMBER() OVER (
				PARTITION BY project, root, group_1, relation, phase
				ORDER BY modified_at_utc DESC
			) AS rn
		`).
		Where("project = ?", project).
		Where("root = ?", root).
		Where("deleted = 0")

	// Apply name filter if provided
	if strings.TrimSpace(assetNameKey) != "" {
		searchTerm := strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
		latestPhaseSubquery = latestPhaseSubquery.Where("LOWER(group_1) LIKE ?", searchTerm)
	}

	latestPhaseCTE := db.Table("(?) AS latest_phase", latestPhaseSubquery)

	keysSubquery := latestPhaseCTE.
		Select("project, root, group_1, relation").
		Where("rn = 1")

	// Apply approval status filter
	if len(approvalStatuses) > 0 {
		lowerStatuses := make([]string, len(approvalStatuses))
		for i, status := range approvalStatuses {
			lowerStatuses[i] = strings.ToLower(strings.TrimSpace(status))
		}
		keysSubquery = keysSubquery.Where("LOWER(approval_status) IN ?", lowerStatuses)
	}

	// Apply work status filter
	if len(workStatuses) > 0 {
		lowerStatuses := make([]string, len(workStatuses))
		for i, status := range workStatuses {
			lowerStatuses[i] = strings.ToLower(strings.TrimSpace(status))
		}
		keysSubquery = keysSubquery.Where("LOWER(work_status) IN ?", lowerStatuses)
	}

	keysSubquery = keysSubquery.Group("project, root, group_1, relation")

	// Build phase aggregation query
	phaseAggSubquery := db.Model(&model.ReviewInfo{}).
		Select(`
			project,
			root,
			group_1,
			relation,
			phase,
			MAX(modified_at_utc) AS modified_at_utc
		`).
		Where("project = ?", project).
		Where("root = ?", root).
		Where("deleted = 0").
		Group("project, root, group_1, relation, phase")

	// Build latest review info query
	latestReviewSubquery := db.Model(&model.ReviewInfo{}).
		Select(`
			root,
			project,
			group_1,
			phase,
			relation,
			work_status,
			approval_status,
			submitted_at_utc,
			modified_at_utc
		`).
		Where("project = ?", project).
		Where("root = ?", root).
		Where("deleted = 0")

	// Build the main query using GORM's CTE support
	var rows []LatestSubmissionRow

	// First CTE: ordered
	orderedCTE := db.Table("(?) AS a", phaseAggSubquery).
		Select("b.*").
		Joins("LEFT JOIN (?) AS b ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1 AND a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc", latestReviewSubquery).
		Joins("INNER JOIN (?) AS fk ON b.project = fk.project AND b.root = fk.root AND b.group_1 = fk.group_1 AND b.relation = fk.relation", keysSubquery).
		Order(buildOrderClause("b", orderKey, direction))

	// Apply window function to ordered CTE
	orderedWithWindow := db.Table("(?) AS k", orderedCTE).
		Select(`
			*,
			ROW_NUMBER() OVER (ORDER BY ?) AS _order
		`, buildOrderClause("", orderKey, direction))

	// Second CTE: offset_ordered
	offsetOrderedCTE := db.Table("(?) AS c", orderedWithWindow).
		Select(`
			c.*,
			CASE
				WHEN ? = 1 THEN c._order
				WHEN c.phase = ? THEN c._order
				ELSE 100000 + c._order
			END AS __order
		`, phaseGuard, preferredPhase)

	// Final query with ranking
	err := db.Table("(?) AS b", offsetOrderedCTE).
		Select(`
			b.*,
			ROW_NUMBER() OVER (
				PARTITION BY b.root, b.project, b.group_1, b.relation
				ORDER BY
					CASE
						WHEN ? = 1 THEN 0
						WHEN b.phase = ? THEN 0
						ELSE 1
					END,
					LOWER(b.group_1) ASC,
					LOWER(b.relation) ASC,
					b.modified_at_utc DESC
			) AS _rank
		`, phaseGuard, preferredPhase).
		Where("_rank = 1").
		Select(`
			root,
			project,
			group_1,
			relation,
			phase,
			submitted_at_utc
		`).
		Order("__order ASC").
		Limit(limit).
		Offset(offset).
		Find(&rows).Error

	if err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}

	return rows, nil
}
