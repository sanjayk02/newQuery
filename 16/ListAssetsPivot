func (r *ReviewInfo) ListAssetsPivot(
    ctx context.Context,
    project, root, preferredPhase, orderKey, direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
) ([]AssetPivot, int64, error) {

    if project == "" {
        return nil, 0, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }

    total, err := r.CountLatestSubmissions(
        ctx,
        project,
        root,
        assetNameKey,
        preferredPhase,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return nil, 0, err
    }

    keys, err := r.ListLatestSubmissionsDynamic(
        ctx,
        project,
        root,
        preferredPhase,
        orderKey,
        direction,
        limit,
        offset,
        assetNameKey,
        approvalStatuses,
        workStatuses,
    )
    if err != nil {
        return nil, 0, err
    }
    if len(keys) == 0 {
        return []AssetPivot{}, total, nil
    }

    // Build OR conditions for keys - PRESERVE ORDER
    var orConditions []clause.Expression
    // Keep track of the original order
    keyOrder := make([]struct {
        Group1   string
        Relation string
    }, len(keys))
    
    for i, k := range keys {
        keyOrder[i] = struct {
            Group1   string
            Relation string
        }{
            Group1:   k.Group1,
            Relation: k.Relation,
        }
        orConditions = append(orConditions, clause.And(
            clause.Eq{Column: "ri.group_1", Value: k.Group1},
            clause.Eq{Column: "ri.relation", Value: k.Relation},
        ))
    }

    if len(orConditions) == 0 {
        return []AssetPivot{}, total, nil
    }

    db := r.db.WithContext(ctx)

    latestPhaseQuery := db.Model(&model.ReviewInfo{}).
        Table("t_review_info AS ri").
        Select(`
            ri.project,
            ri.root,
            ri.group_1,
            ri.relation,
            ri.phase,
            ri.work_status,
            ri.approval_status,
            ri.submitted_at_utc,
            JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]')) AS leaf_group_name,
            gc.path AS group_category_path,
            SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node,
            ROW_NUMBER() OVER (
                PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
                ORDER BY ri.modified_at_utc DESC
            ) AS rn
        `).
        Joins(`
            LEFT JOIN t_group_category_group AS gcg
            ON gcg.project = ri.project
            AND gcg.deleted = 0
            AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]'))
        `).
        Joins(`
            LEFT JOIN t_group_category AS gc
            ON gc.id = gcg.group_category_id
            AND gc.deleted = 0
            AND gc.root = 'assets'
        `).
        Where("ri.project = ?", project).
        Where("ri.root = ?", root).
        Where("ri.deleted = 0").
        Where(clause.Or(orConditions...))

    var phases []struct {
        Project           string     `gorm:"column:project"`
        Root              string     `gorm:"column:root"`
        Group1            string     `gorm:"column:group_1"`
        Relation          string     `gorm:"column:relation"`
        Phase             string     `gorm:"column:phase"`
        WorkStatus        *string    `gorm:"column:work_status"`
        ApprovalStatus    *string    `gorm:"column:approval_status"`
        SubmittedAtUTC    *time.Time `gorm:"column:submitted_at_utc"`
        LeafGroupName     string     `gorm:"column:leaf_group_name"`
        GroupCategoryPath string     `gorm:"column:group_category_path"`
        TopGroupNode      string     `gorm:"column:top_group_node"`
    }

    err = db.
        Table("(?) AS latest_phase", latestPhaseQuery).
        Select(`
            project,
            root,
            group_1,
            relation,
            phase,
            work_status,
            approval_status,
            submitted_at_utc,
            leaf_group_name,
            group_category_path,
            top_group_node
        `).
        Where("rn = 1").
        Scan(&phases).Error

    if err != nil {
        return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
    }

    // Create a map for quick lookup
    phaseMap := make(map[string]map[string][]interface{})
    for _, pr := range phases {
        key := pr.Group1 + ":" + pr.Relation
        if _, ok := phaseMap[key]; !ok {
            phaseMap[key] = make(map[string][]interface{})
        }
        
        phaseMap[key]["project"] = []interface{}{pr.Project}
        phaseMap[key]["root"] = []interface{}{pr.Root}
        phaseMap[key]["group1"] = []interface{}{pr.Group1}
        phaseMap[key]["relation"] = []interface{}{pr.Relation}
        phaseMap[key]["leaf_group_name"] = []interface{}{pr.LeafGroupName}
        phaseMap[key]["group_category_path"] = []interface{}{pr.GroupCategoryPath}
        phaseMap[key]["top_group_node"] = []interface{}{pr.TopGroupNode}
        
        // Store phase-specific data
        phaseKey := strings.ToLower(pr.Phase)
        phaseMap[key][phaseKey+"_work"] = []interface{}{pr.WorkStatus}
        phaseMap[key][phaseKey+"_appr"] = []interface{}{pr.ApprovalStatus}
        phaseMap[key][phaseKey+"_submitted"] = []interface{}{pr.SubmittedAtUTC}
    }

    // Build results in the ORIGINAL SORTED ORDER
    results := make([]AssetPivot, 0, len(keyOrder))
    
    for _, ko := range keyOrder {
        key := ko.Group1 + ":" + ko.Relation
        if data, ok := phaseMap[key]; ok {
            ap := AssetPivot{
                Root:               getString(data["root"]),
                Project:            getString(data["project"]),
                Group1:             getString(data["group1"]),
                Relation:           getString(data["relation"]),
                LeafGroupName:      getString(data["leaf_group_name"]),
                GroupCategoryPath:  getString(data["group_category_path"]),
                TopGroupNode:       getString(data["top_group_node"]),
            }
            
            // Set phase-specific fields
            if mdlWork := data["mdl_work"]; len(mdlWork) > 0 && mdlWork[0] != nil {
                ap.MDLWorkStatus = mdlWork[0].(*string)
            }
            if mdlAppr := data["mdl_appr"]; len(mdlAppr) > 0 && mdlAppr[0] != nil {
                ap.MDLApprovalStatus = mdlAppr[0].(*string)
            }
            if mdlSubmitted := data["mdl_submitted"]; len(mdlSubmitted) > 0 && mdlSubmitted[0] != nil {
                ap.MDLSubmittedAtUTC = mdlSubmitted[0].(*time.Time)
            }
            
            // Repeat for other phases (RIG, BLD, DSN, LDV)...
            
            results = append(results, ap)
        }
    }

    return results, total, nil
}

// Helper function to safely extract strings
func getString(data []interface{}) string {
    if len(data) > 0 && data[0] != nil {
        return data[0].(string)
    }
    return ""
}
