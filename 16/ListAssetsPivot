// ListAssetsPivot returns the fully pivoted rows + total count.
// Uses a hybrid approach: GORM for building queries, raw SQL for execution.
func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// 1) Get total count
	total, err := r.CountLatestSubmissions(
		ctx,
		project,
		root,
		assetNameKey,
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}

	// 2) Get page keys
	keys, err := r.ListLatestSubmissionsDynamic(
		ctx,
		project,
		root,
		preferredPhase,
		orderKey,
		direction,
		limit,
		offset,
		assetNameKey,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// 3) Build WHERE conditions dynamically
	var whereBuilder strings.Builder
	var params []interface{}
	
	params = append(params, project, root)
	
	whereBuilder.WriteString("ri.project = ? AND ri.root = ? AND ri.deleted = 0 AND (")
	
	for i, k := range keys {
		if i > 0 {
			whereBuilder.WriteString(" OR ")
		}
		whereBuilder.WriteString("(ri.group_1 = ? AND ri.relation = ?)")
		params = append(params, k.Group1, k.Relation)
	}
	whereBuilder.WriteString(")")

	// 4) Build the query using GORM-style building but execute as raw SQL
	db := r.db.WithContext(ctx)
	
	// Build the base query parts
	selectClause := `
SELECT
	ri.project,
	ri.root,
	ri.group_1,
	ri.relation,
	ri.phase,
	ri.work_status,
	ri.approval_status,
	ri.submitted_at_utc,
	ri.modified_at_utc,
	JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]')) AS leaf_group_name,
	gc.path AS group_category_path,
	SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node,
	ROW_NUMBER() OVER (
		PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
		ORDER BY ri.modified_at_utc DESC
	) AS rn`

	fromClause := `
FROM t_review_info AS ri
LEFT JOIN t_group_category_group AS gcg ON gcg.project = ri.project 
	AND gcg.deleted = 0 
	AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]'))
LEFT JOIN t_group_category AS gc ON gc.id = gcg.group_category_id 
	AND gc.deleted = 0 
	AND gc.root = 'assets'`

	// Combine into final query
	finalQuery := fmt.Sprintf(`
WITH latest_phase AS (
	%s
	%s
	WHERE %s
)
SELECT
	project,
	root,
	group_1,
	relation,
	phase,
	work_status,
	approval_status,
	submitted_at_utc,
	leaf_group_name,
	group_category_path,
	top_group_node
FROM latest_phase
WHERE rn = 1`, selectClause, fromClause, whereBuilder.String())

	// 5) Execute query
	var phases []struct {
		Project            string     `gorm:"column:project"`
		Root               string     `gorm:"column:root"`
		Group1             string     `gorm:"column:group_1"`
		Relation           string     `gorm:"column:relation"`
		Phase              string     `gorm:"column:phase"`
		WorkStatus         *string    `gorm:"column:work_status"`
		ApprovalStatus     *string    `gorm:"column:approval_status"`
		SubmittedAtUTC     *time.Time `gorm:"column:submitted_at_utc"`
		LeafGroupName      string     `gorm:"column:leaf_group_name"`
		GroupCategoryPath  string     `gorm:"column:group_category_path"`
		TopGroupNode       string     `gorm:"column:top_group_node"`
	}

	if err := db.Raw(finalQuery, params...).Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// 6) Process results (same mapping logic)
	type keyStruct struct {
		p, r, g, rel string
	}

	m := make(map[keyStruct]*AssetPivot, len(keys))
	orderedPtrs := make([]*AssetPivot, 0, len(keys))

	for _, k := range keys {
		id := keyStruct{k.Project, k.Root, k.Group1, k.Relation}
		ap := &AssetPivot{
			Root:     k.Root,
			Project:  k.Project,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
		m[id] = ap
		orderedPtrs = append(orderedPtrs, ap)
	}

	for _, pr := range phases {
		id := keyStruct{pr.Project, pr.Root, pr.Group1, pr.Relation}
		if ap, ok := m[id]; ok {
			if ap.LeafGroupName == "" {
				ap.LeafGroupName = pr.LeafGroupName
				ap.GroupCategoryPath = pr.GroupCategoryPath
				ap.TopGroupNode = pr.TopGroupNode
			}

			switch strings.ToLower(pr.Phase) {
			case "mdl":
				ap.MDLWorkStatus = pr.WorkStatus
				ap.MDLApprovalStatus = pr.ApprovalStatus
				ap.MDLSubmittedAtUTC = pr.SubmittedAtUTC
			case "rig":
				ap.RIGWorkStatus = pr.WorkStatus
				ap.RIGApprovalStatus = pr.ApprovalStatus
				ap.RIGSubmittedAtUTC = pr.SubmittedAtUTC
			case "bld":
				ap.BLDWorkStatus = pr.WorkStatus
				ap.BLDApprovalStatus = pr.ApprovalStatus
				ap.BLDSubmittedAtUTC = pr.SubmittedAtUTC
			case "dsn":
				ap.DSNWorkStatus = pr.WorkStatus
				ap.DSNApprovalStatus = pr.ApprovalStatus
				ap.DSNSubmittedAtUTC = pr.SubmittedAtUTC
			case "ldv":
				ap.LDVWorkStatus = pr.WorkStatus
				ap.LDVApprovalStatus = pr.ApprovalStatus
				ap.LDVSubmittedAtUTC = pr.SubmittedAtUTC
			}
		}
	}

	ordered := make([]AssetPivot, len(orderedPtrs))
	for i, ap := range orderedPtrs {
		ordered[i] = *ap
	}

	return ordered, total, nil
}
