func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project string,
	root string,
	sortKey string,
	direction string,
	limit int,
	offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	db := r.db.WithContext(ctx)

	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 15
	}
	if offset < 0 {
		offset = 0
	}

	// -------------------------------------------------------
	// SUBQUERY A: latest per (asset + relation + phase)
	// -------------------------------------------------------
	latestPerPhase := db.
		Model(&model.ReviewInfo{}).
		Select(`
			project,
			root,
			group_1,
			relation,
			phase,
			MAX(modified_at_utc) AS modified_at_utc
		`).
		Where("deleted = ?", 0).
		Where("project = ?", project).
		Where("root = ?", root).
		Group("project").
		Group("root").
		Group("group_1").
		Group("relation").
		Group("phase")

	// -------------------------------------------------------
	// MAIN QUERY (JOIN BACK)
	// -------------------------------------------------------
	query := db.
		Table("(?) AS a", latestPerPhase).
		Joins(`
			JOIN t_review_info AS b
			  ON a.project = b.project
			 AND a.root = b.root
			 AND a.group_1 = b.group_1
			 AND a.relation = b.relation
			 AND a.phase = b.phase
			 AND a.modified_at_utc = b.modified_at_utc
		`)

	// -------------------------------------------------------
	// FILTERS
	// -------------------------------------------------------
	if assetNameKey != "" {
		query = query.Where("b.group_1 LIKE ?", "%"+assetNameKey+"%")
	}

	if len(approvalStatuses) > 0 {
		query = query.Where("b.approval_status IN ?", approvalStatuses)
	}

	if len(workStatuses) > 0 {
		query = query.Where("b.work_status IN ?", workStatuses)
	}

	// -------------------------------------------------------
	// TOTAL COUNT (before pagination)
	// -------------------------------------------------------
	var total int64
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// -------------------------------------------------------
	// SORTING
	// -------------------------------------------------------
	dir := "ASC"
	if strings.EqualFold(direction, "desc") {
		dir = "DESC"
	}

	order := "b.group_1 ASC"

	switch sortKey {
	case "submitted_at_utc":
		order = "b.submitted_at_utc " + dir
	case "mdl_work", "rig_work", "bld_work", "dsn_work", "ldv_work":
		order = "b.work_status " + dir
	case "mdl_appr", "rig_appr", "bld_appr", "dsn_appr", "ldv_appr":
		order = "b.approval_status " + dir
	}

	query = query.Order(order)

	// -------------------------------------------------------
	// FETCH ROWS
	// -------------------------------------------------------
	var rows []phaseRow
	if err := query.
		Select(`
			b.project,
			b.root,
			b.group_1,
			b.relation,
			b.phase,
			b.work_status,
			b.approval_status,
			b.submitted_at_utc
		`).
		Limit(limit).
		Offset(offset).
		Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	// -------------------------------------------------------
	// PIVOT (PHASE → COLUMNS)
	// -------------------------------------------------------
	pivotMap := make(map[string]*AssetPivot)

	keyOf := func(r phaseRow) string {
		return r.Project + "|" + r.Root + "|" + r.Group1 + "|" + r.Relation
	}

	for _, r := range rows {
		key := keyOf(r)

		if _, ok := pivotMap[key]; !ok {
			pivotMap[key] = &AssetPivot{
				Project:  r.Project,
				Root:     r.Root,
				Group1:   r.Group1,
				Relation: r.Relation,
			}
		}

		p := pivotMap[key]

		switch strings.ToLower(r.Phase) {
		case "mdl":
			p.MDLWorkStatus = r.WorkStatus
			p.MDLApprovalStatus = r.ApprovalStatus
			p.MDLSubmittedAtUTC = r.SubmittedAtUTC
		case "rig":
			p.RIGWorkStatus = r.WorkStatus
			p.RIGApprovalStatus = r.ApprovalStatus
			p.RIGSubmittedAtUTC = r.SubmittedAtUTC
		case "bld":
			p.BLDWorkStatus = r.WorkStatus
			p.BLDApprovalStatus = r.ApprovalStatus
			p.BLDSubmittedAtUTC = r.SubmittedAtUTC
		case "dsn":
			p.DSNWorkStatus = r.WorkStatus
			p.DSNApprovalStatus = r.ApprovalStatus
			p.DSNSubmittedAtUTC = r.SubmittedAtUTC
		case "ldv":
			p.LDVWorkStatus = r.WorkStatus
			p.LDVApprovalStatus = r.ApprovalStatus
			p.LDVSubmittedAtUTC = r.SubmittedAtUTC
		}
	}

	// -------------------------------------------------------
	// MAP → SLICE
	// -------------------------------------------------------
	out := make([]AssetPivot, 0, len(pivotMap))
	for _, v := range pivotMap {
		out = append(out, *v)
	}

	return out, total, nil
}
