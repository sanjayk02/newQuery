func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string,
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	orderOuter := buildOrderClause("", orderKey, direction)
	orderInner := buildOrderClause("b", orderKey, direction)

	// ---- name filter
	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	// ---- status filter (APPLIED LATER)
	statusWhere, statusArgs := buildPhaseAwareStatusWhere(
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)

	sql := fmt.Sprintf(`
WITH latest_phase AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY project, root, group_1, relation, phase
      ORDER BY modified_at_utc DESC
    ) rn
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0%s
),
keys AS (
  SELECT project, root, group_1, relation
  FROM latest_phase
  WHERE rn = 1
  GROUP BY project, root, group_1, relation
),
filtered AS (
  SELECT lp.*
  FROM latest_phase lp
  JOIN keys k
    ON k.project = lp.project
   AND k.root = lp.root
   AND k.group_1 = lp.group_1
   AND k.relation = lp.relation
  WHERE lp.rn = 1%s
),
ordered AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (ORDER BY %s) ord
  FROM filtered b
),
ranked AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY root, project, group_1, relation
      ORDER BY
        CASE
          WHEN ? = 1 THEN 0
          WHEN phase = ? THEN 0
          ELSE 1
        END,
        modified_at_utc DESC
    ) rnk
  FROM ordered
)
SELECT
  root,
  project,
  group_1,
  relation,
  phase,
  submitted_at_utc
FROM ranked
WHERE rnk = 1
ORDER BY ord
LIMIT ? OFFSET ?;
`, nameCond, statusWhere, orderOuter)

	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)
	args = append(args,
		phaseGuard,
		preferredPhase,
		limit,
		offset,
	)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}

	return rows, nil
}
