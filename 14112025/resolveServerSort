/* Resolve UI key -> server sort + phase */
const resolveServerSort = (key: string): { sort: string; phase: string } => {
  // ── 1) Check if any filter is active ─────────────────────────────
  // NOTE: This logic remains the same to check the filter state,
  // but it is no longer used to determine the phase to send.
  const nameFilterActive = !!(filterProps.assetNameKey || '').trim();

  const approvalSelected =
    (((filterProps as any).approvalStatuses || filterProps.applovalStatues) || []).length > 0;

  const workSelected =
    (((filterProps as any).workStatuses || filterProps.workStatues) || []).length > 0;

  const isFilterActive = nameFilterActive || approvalSelected || workSelected;
  // ────────────────────────────────────────────────────────────────

  // ── 2) Fixed keys: map directly, never bias phase ─────────────────
  if (key === 'group_1') return { sort: 'group_1', phase: 'none' };
  if (key === 'relation') return { sort: 'relation', phase: 'none' };

  // ── 3) Phase-specific keys (mdl/rig/bld/dsn/ldv) ──────────────────
  const m = key.match(/^(mdl|rig|bld|dsn|ldv)_(work|appr|submitted)$/i);
  if (!m) return { sort: 'group_1', phase: 'none' };

  const phase = m[1].toLowerCase();
  const field = m[2].toLowerCase();

  // FIX: Always set the phase to the column's phase (e.g., 'mdl')
  // when sorting by a phase-specific column. This provides the
  // best ranking signal to the backend regardless of filter status.
  const resolvedPhase = phase;

  if (field === 'submitted') return { sort: `${phase}_submitted`, phase: resolvedPhase };
  if (field === 'appr')      return { sort: `${phase}_appr`,      phase: resolvedPhase };
  return { sort: `${phase}_work`, phase: resolvedPhase };
};
