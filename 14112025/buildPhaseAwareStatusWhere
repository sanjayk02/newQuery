func buildPhaseAwareStatusWhere(
    _ string, // statusPhase ignored
    approvalStatuses, workStatuses []string,
) (string, []any) {

    buildIn := func(vals []string) (string, []any) {
        if len(vals) == 0 {
            return "", nil
        }
        ph := strings.Repeat("?,", len(vals))
        ph = ph[:len(ph)-1]

        args := make([]any, len(vals))
        for i, v := range vals {
            args[i] = strings.ToLower(strings.TrimSpace(v))
        }
        return ph, args
    }

    clauses := []string{}
    args := []any{}

    // Approval filter across ALL phases
    if ph, a := buildIn(approvalStatuses); ph != "" {
        clauses = append(clauses,
            fmt.Sprintf(`
                (
                    LOWER(mdl_appr) IN (%s)
                    OR LOWER(rig_appr) IN (%s)
                    OR LOWER(bld_appr) IN (%s)
                    OR LOWER(dsn_appr) IN (%s)
                    OR LOWER(ldv_appr) IN (%s)
                )
            `, ph, ph, ph, ph, ph),
        )
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
    }

    // Work filter across ALL phases
    if ph, a := buildIn(workStatuses); ph != "" {
        clauses = append(clauses,
            fmt.Sprintf(`
                (
                    LOWER(mdl_work) IN (%s)
                    OR LOWER(rig_work) IN (%s)
                    OR LOWER(bld_work) IN (%s)
                    OR LOWER(dsn_work) IN (%s)
                    OR LOWER(ldv_work) IN (%s)
                )
            `, ph, ph, ph, ph, ph),
        )
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
        args = append(args, a...)
    }

    if len(clauses) == 0 {
        return "", nil
    }

    return " AND (" + strings.Join(clauses, " AND ") + ")", args
}
