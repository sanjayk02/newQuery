import React, { useMemo, useState, useCallback, useEffect } from 'react';
import { Box, Typography, IconButton } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ChevronRightIcon from '@material-ui/icons/ChevronRight';
import { PivotGroup, SortDir } from './types';

type Props = {
  groups?: PivotGroup[];
  page: number;
  rowsPerPage: number;

  sortKey?: string;
  sortDir?: SortDir;

  // Optional rule
  unassignedFirst?: boolean;

  // A→Z or Z→A
  groupSortDir?: 'asc' | 'desc';
};

const displayKey = (v: string | null) => (v ? String(v) : 'UNASSIGNED').trim().toUpperCase();

const normalizeGroup = (v: any) => {
  const s = (v === null || v === undefined || v === '' ? 'unassigned' : String(v)).trim();
  return s.toLowerCase();
};

const normalizeValue = (v: any) => {
  if (v === null || v === undefined) return '';
  const s = String(v).trim();
  return s === '-' ? '' : s;
};

const isEmptyVal = (v: any) => normalizeValue(v) === '';

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  page,
  rowsPerPage,
  sortKey = 'group_1',
  sortDir = 'asc',
  unassignedFirst = false,
  groupSortDir,
}) => {
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  const toggle = useCallback((key: string) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  }, []);

  // ✅ Debug backend payload (optional)
  useEffect(() => {
    // console.log('GROUPED VIEW - RAW BACKEND DATA', groups);
  }, [groups]);

  const processedGroups = useMemo(() => {
    // 1) Sort groups ShotGrid-style
    const dirForGroups: 'asc' | 'desc' =
      groupSortDir ? groupSortDir : (sortDir === 'desc' ? 'desc' : 'asc');

    const orderedGroups = [...groups].sort((a, b) => {
      const aNorm = normalizeGroup(a && (a as any).top_group_node);
      const bNorm = normalizeGroup(b && (b as any).top_group_node);

      if (unassignedFirst) {
        const aIsUn = aNorm === 'unassigned';
        const bIsUn = bNorm === 'unassigned';
        if (aIsUn && !bIsUn) return -1;
        if (!aIsUn && bIsUn) return 1;
      }

      const comp = aNorm.localeCompare(bNorm, undefined, { numeric: true, sensitivity: 'base' });
      return dirForGroups === 'asc' ? comp : -comp;
    });

    // 2) Sort items inside each group based on current column sort
    return orderedGroups.map((group) => {
      const items = (group && (group as any).items) ? (group as any).items : [];

      // If sorting by group header itself, don't re-sort items by group key again
      const sortingGroupHeader =
        sortKey === 'group_1' || sortKey === 'group_1_name' || sortKey === 'top_group_node';

      if (sortDir === 'none' || sortingGroupHeader) {
        return { ...group, items };
      }

      const key = sortKey === 'group_1_name' ? 'group_1' : sortKey;

      const sortedItems = [...items].sort((a: any, b: any) => {
        const aVal = a ? a[key] : '';
        const bVal = b ? b[key] : '';

        const aEmpty = isEmptyVal(aVal);
        const bEmpty = isEmptyVal(bVal);
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;

        const aa = normalizeValue(aVal).toLowerCase();
        const bb = normalizeValue(bVal).toLowerCase();

        const comp = aa.localeCompare(bb, undefined, { numeric: true, sensitivity: 'base' });
        return sortDir === 'asc' ? comp : -comp;
      });

      return { ...group, items: sortedItems };
    });
  }, [groups, sortKey, sortDir, groupSortDir, unassignedFirst]);

  return (
    <Box width="100%">
      {processedGroups.map((group: any) => {
        const rawGroupName = group && group.top_group_node ? group.top_group_node : 'unassigned';
        const groupKey = normalizeGroup(rawGroupName);
        const isCollapsed = !!collapsed[groupKey];

        const groupItems = group && group.items ? group.items : [];

        // If backend ever sends totals, we will use them automatically:
        // supports: total_count, total, count
        const totalCount =
          (group && (group as any).total_count != null ? (group as any).total_count :
          (group && (group as any).total != null ? (group as any).total :
          (group && (group as any).count != null ? (group as any).count :
          groupItems.length)));

        return (
          <Box key={groupKey} mb={0.5}>
            <Box
              px={1}
              py={0.5}
              display="flex"
              alignItems="center"
              style={{
                background: 'rgba(255,255,255,0.08)',
                borderBottom: '1px solid rgba(255,255,255,0.12)',
                cursor: 'pointer',
                userSelect: 'none',
              }}
              onClick={() => toggle(groupKey)}
            >
              <IconButton size="small" style={{ padding: 4, marginRight: 8 }}>
                {isCollapsed ? <ChevronRightIcon fontSize="small" /> : <ExpandMoreIcon fontSize="small" />}
              </IconButton>

              <Typography variant="subtitle2" style={{ fontWeight: 700, fontSize: '0.75rem' }}>
                {displayKey(rawGroupName)}
                <span style={{ marginLeft: 8, color: '#00b7ff' }}>({totalCount})</span>
              </Typography>
            </Box>

            {!isCollapsed && (
              <Box>
                {groupItems.map((asset: any) => (
                  <Box
                    key={(asset && asset.root ? asset.root : '') + '-' + (asset && asset.relation ? asset.relation : '')}
                    px={6}
                    py={0.75}
                    style={{ borderBottom: '1px solid rgba(255,255,255,0.05)' }}
                  >
                    <Typography variant="body2" style={{ fontSize: '0.85rem' }}>
                      {asset && asset.group_1 ? asset.group_1 : ''}
                    </Typography>
                  </Box>
                ))}
              </Box>
            )}
          </Box>
        );
      })}
    </Box>
  );
};

export default AssetsGroupedDataTable;
