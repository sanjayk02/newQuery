import React, { useMemo, useState, useCallback, useEffect } from 'react';
import { Box, Typography, IconButton } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ChevronRightIcon from '@material-ui/icons/ChevronRight';
import { PivotGroup, SortDir } from './types';

type Props = {
  /** Groups returned by the backend when view=grouped */
  groups?: PivotGroup[];
  /** 0-based UI page index */
  page: number;
  /** Rows per page setting */
  rowsPerPage: number;
  /** Current UI sort key */
  sortKey: string;
  /** Current UI sort direction */
  sortDir: SortDir;
  /** Pinned top nodes to show in a fixed order */
  pinnedTopGroups?: string[];
  /**
   * How to order the top groups:
   * - 'pinned' = DEFAULT_PINNED_ORDER first (recommended)
   * - 'alpha'  = alphabetical A->Z / Z->A based on sortDir
   */
  groupOrderMode?: 'pinned' | 'alpha';
};

// Fixed order you want (as per "Before Sorted")
const DEFAULT_PINNED_ORDER = [
  'unassigned',
  'camera',
  'character',
  'test',
  'set',
  'prop',
  'light',
  'fx',
  'creature',
];

function normalizeTopGroupNode(v: any) {
  var s = v == null ? '' : String(v);
  s = s.trim();
  if (!s) return 'unassigned';
  return s.toLowerCase();
}

function displayKey(v: any) {
  var s = v == null ? '' : String(v);
  s = s.trim();
  if (!s) s = 'UNASSIGNED';
  return s.toUpperCase();
}

function getComparableValue(obj: any, key: string) {
  var v = obj && obj[key] != null ? obj[key] : '';
  var s = String(v).trim();
  if (!s || s === '-') return ''; // treat empty placeholders as empty
  return s.toLowerCase();
}

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  page,
  rowsPerPage,
  sortKey,
  sortDir,
  pinnedTopGroups = DEFAULT_PINNED_ORDER,
  groupOrderMode = 'pinned',
}) => {
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  const toggle = useCallback((key: string) => {
    setCollapsed(function (prev) {
      return { ...prev, [key]: !prev[key] };
    });
  }, []);

  // --- Debug: what backend is sending (no optional chaining) ---
  useEffect(() => {
    // Comment this out once verified
    console.group('GROUPED VIEW - RAW BACKEND DATA');
    for (var i = 0; i < groups.length; i++) {
      var g: any = (groups as any)[i];
      console.log(i, {
        top_group_node: g && g.top_group_node,
        normalized: normalizeTopGroupNode(g && g.top_group_node),
        itemsCount: g && g.items ? g.items.length : 0,
      });
    }
    console.groupEnd();
  }, [groups]);

  const processedGroups = useMemo(() => {
    var pinned = (pinnedTopGroups || []).map(function (x) {
      return normalizeTopGroupNode(x);
    });

    // 1) ORDER GROUPS
    var orderedGroups = groups.slice().sort(function (a: any, b: any) {
      var aName = normalizeTopGroupNode(a && a.top_group_node);
      var bName = normalizeTopGroupNode(b && b.top_group_node);

      // Alphabetical mode (A->Z / Z->A via sortDir)
      if (groupOrderMode === 'alpha') {
        var cmpAlpha = aName.localeCompare(bName, undefined, { numeric: true });
        return sortDir === 'desc' ? -cmpAlpha : cmpAlpha;
      }

      // Pinned mode (DEFAULT_PINNED_ORDER first)
      var ia = pinned.indexOf(aName);
      var ib = pinned.indexOf(bName);

      if (ia !== -1 && ib !== -1) return ia - ib;
      if (ia !== -1) return -1;
      if (ib !== -1) return 1;

      // unknown groups after pinned, but alphabetical among themselves
      return aName.localeCompare(bName, undefined, { numeric: true });
    });

    // 2) SORT ITEMS INSIDE EACH GROUP (based on sortKey/sortDir)
    var key = sortKey === 'group_1_name' ? 'group_1' : sortKey;

    return orderedGroups.map(function (group: any) {
      var items = group && group.items ? group.items.slice() : [];

      items.sort(function (a: any, b: any) {
        if (sortDir === 'none') return 0;

        var asc = sortDir === 'asc';
        var va = getComparableValue(a, key);
        var vb = getComparableValue(b, key);

        // keep empty values at bottom
        if (!va && vb) return 1;
        if (!vb && va) return -1;
        if (!va && !vb) return 0;

        var cmp = va.localeCompare(vb, undefined, { numeric: true });
        return asc ? cmp : -cmp;
      });

      return { ...group, items: items };
    });
  }, [groups, sortKey, sortDir, pinnedTopGroups, groupOrderMode]);

  // NOTE: you’re not using page/rowsPerPage here because grouped view is usually “show all groups”.
  // If you want paging later, we can page the *groups* or page the *flattened items*.

  return (
    <Box width="100%">
      {processedGroups.map(function (group: any) {
        var rawName = group && group.top_group_node ? group.top_group_node : 'unassigned';
        var collapseKey = normalizeTopGroupNode(rawName);
        var isCollapsed = !!collapsed[collapseKey];
        var groupItems = group && group.items ? group.items : [];

        return (
          <Box key={collapseKey} mb={0.5}>
            {/* Group Header */}
            <Box
              px={1}
              py={0.5}
              display="flex"
              alignItems="center"
              style={{
                background: 'rgba(255,255,255,0.08)',
                borderBottom: '1px solid rgba(255,255,255,0.12)',
                cursor: 'pointer',
                userSelect: 'none',
              }}
              onClick={function () {
                toggle(collapseKey);
              }}
            >
              <IconButton size="small" style={{ padding: 4, marginRight: 8 }}>
                {isCollapsed ? (
                  <ChevronRightIcon fontSize="small" />
                ) : (
                  <ExpandMoreIcon fontSize="small" />
                )}
              </IconButton>

              <Typography variant="subtitle2" style={{ fontWeight: 700, fontSize: '0.75rem' }}>
                {displayKey(rawName)}
                <span style={{ marginLeft: 8, color: '#00b7ff' }}>({groupItems.length})</span>
              </Typography>
            </Box>

            {/* Asset Rows */}
            {!isCollapsed && (
              <Box>
                {groupItems.map(function (asset: any, idx: number) {
                  var rowKey =
                    (asset && asset.relation ? String(asset.relation) : 'r') +
                    '-' +
                    (asset && asset.group_1 ? String(asset.group_1) : 'g') +
                    '-' +
                    idx;

                  return (
                    <Box
                      key={rowKey}
                      px={6}
                      py={0.75}
                      style={{ borderBottom: '1px solid rgba(255,255,255,0.05)' }}
                    >
                      <Typography variant="body2" style={{ fontSize: '0.85rem' }}>
                        {asset && asset.group_1 ? asset.group_1 : '-'}
                      </Typography>
                    </Box>
                  );
                })}
              </Box>
            )}
          </Box>
        );
      })}
    </Box>
  );
};

export default AssetsGroupedDataTable;
