/*
──────────────────────────────────────────────────────────────────────────

	ListAssetsPivot retrieves a paginated list of AssetPivot rows for a specified project and asset root,
	optionally filtered by asset name prefix, preferred phase, approval statuses, and work statuses.
	
	FIXED: Now uses a single-query approach to properly handle global sorting by phase-specific fields.
	Parameters:
	- ctx: Context for database operations.
	- project: Project identifier (required).
	- root: Asset root; defaults to "assets" if empty.
	- preferredPhase: Phase to prioritize in sorting; if empty or "none", no bias is applied.
	- orderKey: Column or logical key to sort by (e.g., "submitted_at_utc", "group1_only").
	- direction: Sort direction ("ASC" or "DESC").
	- limit: Maximum number of results to return; defaults to 60 if <= 0.
	- offset: Number of results to skip; defaults to 0 if < 0.
	- assetNameKey: Optional asset name prefix filter (case-insensitive).
	- approvalStatuses: List of approval statuses to filter by.
	- workStatuses: List of work statuses to filter by.
	Returns:
	- []AssetPivot: Slice of AssetPivot rows matching the filters.
	- int64: Total count of assets matching the filters (for pagination).
	- error: Error if project is missing or database query fails.

───────────────────────────────────────────────────────────────────────────
*/
func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	if project == "" {
		return nil, 0, errors.New("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// Safety guards for limit/offset
	const maxPageSize = 200
	if limit <= 0 {
		limit = 15
	}
	if limit > maxPageSize {
		limit = maxPageSize
	}
	if offset < 0 {
		offset = 0
	}

	db := r.db.WithContext(ctx)

	// Build name filter
	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(ri.group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	// Build status filter
	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	// Build order clause for the main query
	// For phase-specific sorting, we need to handle it differently in the main query
	var orderClause string
	if strings.Contains(orderKey, "_") {
		// Phase-specific sorting - use the aggregated column
		switch orderKey {
		case "mdl_submitted":
			orderClause = "mdl_submitted_at_utc " + direction + " NULLS LAST"
		case "rig_submitted":
			orderClause = "rig_submitted_at_utc " + direction + " NULLS LAST"
		case "bld_submitted":
			orderClause = "bld_submitted_at_utc " + direction + " NULLS LAST"
		case "dsn_submitted":
			orderClause = "dsn_submitted_at_utc " + direction + " NULLS LAST"
		case "ldv_submitted":
			orderClause = "ldv_submitted_at_utc " + direction + " NULLS LAST"
		case "mdl_work":
			orderClause = "mdl_work_status " + direction + " NULLS LAST"
		case "rig_work":
			orderClause = "rig_work_status " + direction + " NULLS LAST"
		case "bld_work":
			orderClause = "bld_work_status " + direction + " NULLS LAST"
		case "dsn_work":
			orderClause = "dsn_work_status " + direction + " NULLS LAST"
		case "ldv_work":
			orderClause = "ldv_work_status " + direction + " NULLS LAST"
		case "mdl_appr":
			orderClause = "mdl_approval_status " + direction + " NULLS LAST"
		case "rig_appr":
			orderClause = "rig_approval_status " + direction + " NULLS LAST"
		case "bld_appr":
			orderClause = "bld_approval_status " + direction + " NULLS LAST"
		case "dsn_appr":
			orderClause = "dsn_approval_status " + direction + " NULLS LAST"
		case "ldv_appr":
			orderClause = "ldv_approval_status " + direction + " NULLS LAST"
		case "mdl_take":
			orderClause = "mdl_take " + direction + " NULLS LAST"
		case "rig_take":
			orderClause = "rig_take " + direction + " NULLS LAST"
		case "bld_take":
			orderClause = "bld_take " + direction + " NULLS LAST"
		case "dsn_take":
			orderClause = "dsn_take " + direction + " NULLS LAST"
		case "ldv_take":
			orderClause = "ldv_take " + direction + " NULLS LAST"
		default:
			// Fall back to the regular buildOrderClause
			orderClause = buildOrderClause("", orderKey, direction)
		}
	} else {
		orderClause = buildOrderClause("", orderKey, direction)
	}

	// Main single query that does everything in one pass
	sql := `
WITH phase_latest AS (
  -- Get the latest submission per (asset, relation, phase)
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.component,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.modified_at_utc,
    ri.take,
    JSON_UNQUOTE(JSON_EXTRACT(ri.groups, '$[0]')) AS leaf_group_name,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.component, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS rn
  FROM t_review_info ri
  WHERE ri.project = ?
    AND ri.root = ?
    AND ri.deleted = 0
    ` + nameCond + `
),
phase_data AS (
  -- Filter to only the latest per phase
  SELECT *
  FROM phase_latest
  WHERE rn = 1
),
pivoted_assets AS (
  -- Pivot phases into columns
  SELECT
    project,
    root,
    group_1,
    relation,
    MAX(component) AS component,
    MAX(leaf_group_name) AS leaf_group_name,
    
    -- Generic fields (fallback)
    MAX(CASE WHEN 1=1 THEN work_status END) AS work_status,
    MAX(CASE WHEN 1=1 THEN approval_status END) AS approval_status,
    MAX(CASE WHEN 1=1 THEN submitted_at_utc END) AS submitted_at_utc,
    MAX(CASE WHEN 1=1 THEN take END) AS take,
    
    -- MDL Phase
    MAX(CASE WHEN phase = 'MDL' THEN work_status END) AS mdl_work_status,
    MAX(CASE WHEN phase = 'MDL' THEN approval_status END) AS mdl_approval_status,
    MAX(CASE WHEN phase = 'MDL' THEN submitted_at_utc END) AS mdl_submitted_at_utc,
    MAX(CASE WHEN phase = 'MDL' THEN take END) AS mdl_take,
    
    -- RIG Phase
    MAX(CASE WHEN phase = 'RIG' THEN work_status END) AS rig_work_status,
    MAX(CASE WHEN phase = 'RIG' THEN approval_status END) AS rig_approval_status,
    MAX(CASE WHEN phase = 'RIG' THEN submitted_at_utc END) AS rig_submitted_at_utc,
    MAX(CASE WHEN phase = 'RIG' THEN take END) AS rig_take,
    
    -- BLD Phase
    MAX(CASE WHEN phase = 'BLD' THEN work_status END) AS bld_work_status,
    MAX(CASE WHEN phase = 'BLD' THEN approval_status END) AS bld_approval_status,
    MAX(CASE WHEN phase = 'BLD' THEN submitted_at_utc END) AS bld_submitted_at_utc,
    MAX(CASE WHEN phase = 'BLD' THEN take END) AS bld_take,
    
    -- DSN Phase
    MAX(CASE WHEN phase = 'DSN' THEN work_status END) AS dsn_work_status,
    MAX(CASE WHEN phase = 'DSN' THEN approval_status END) AS dsn_approval_status,
    MAX(CASE WHEN phase = 'DSN' THEN submitted_at_utc END) AS dsn_submitted_at_utc,
    MAX(CASE WHEN phase = 'DSN' THEN take END) AS dsn_take,
    
    -- LDV Phase
    MAX(CASE WHEN phase = 'LDV' THEN work_status END) AS ldv_work_status,
    MAX(CASE WHEN phase = 'LDV' THEN approval_status END) AS ldv_approval_status,
    MAX(CASE WHEN phase = 'LDV' THEN submitted_at_utc END) AS ldv_submitted_at_utc,
    MAX(CASE WHEN phase = 'LDV' THEN take END) AS ldv_take
    
  FROM phase_data
  GROUP BY project, root, group_1, relation
),
filtered_assets AS (
  -- Apply status filters to the pivoted data
  SELECT pa.*
  FROM pivoted_assets pa
  WHERE 1=1
    ` + statusWhere + `
),
ranked_assets AS (
  -- Apply sorting and pagination
  SELECT *,
    ROW_NUMBER() OVER (ORDER BY ` + orderClause + `) AS row_num
  FROM filtered_assets
),
paginated_assets AS (
  SELECT *
  FROM ranked_assets
  WHERE row_num > ? AND row_num <= ?
),
enriched_assets AS (
  -- Add group category information
  SELECT
    pa.*,
    gc.path AS group_category_path,
    SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
  FROM paginated_assets pa
  LEFT JOIN t_group_category_group gcg
    ON gcg.project = pa.project
    AND gcg.deleted = 0
    AND gcg.path = pa.leaf_group_name
  LEFT JOIN t_group_category gc
    ON gc.id = gcg.group_category_id
    AND gc.deleted = 0
    AND gc.root = 'assets'
)
SELECT * FROM enriched_assets
ORDER BY row_num;
`

	// Build count query (for total count)
	countSQL := `
WITH phase_latest AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.component, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS rn
  FROM t_review_info ri
  WHERE ri.project = ?
    AND ri.root = ?
    AND ri.deleted = 0
    ` + nameCond + `
),
phase_data AS (
  SELECT *
  FROM phase_latest
  WHERE rn = 1
),
pivoted_assets AS (
  SELECT
    project,
    root,
    group_1,
    relation
  FROM phase_data
  GROUP BY project, root, group_1, relation
),
filtered_assets AS (
  SELECT pa.*
  FROM pivoted_assets pa
  WHERE 1=1
    ` + statusWhere + `
)
SELECT COUNT(*) FROM filtered_assets;
`

	// Prepare arguments
	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	
	// For the main query, we need to split args for count and main query
	countArgs := append([]any{}, args...)
	countArgs = append(countArgs, statusArgs...)
	
	mainArgs := append([]any{}, args...)
	mainArgs = append(mainArgs, statusArgs...)
	mainArgs = append(mainArgs, offset, offset+limit) // For row_num > ? AND row_num <= ?

	// Get total count
	var total int64
	if err := db.Raw(countSQL, countArgs...).Scan(&total).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.count: %w", err)
	}

	if total == 0 {
		return []AssetPivot{}, total, nil
	}

	// Execute main query
	var results []AssetPivot
	if err := db.Raw(sql, mainArgs...).Scan(&results).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.query: %w", err)
	}

	// Set default TopGroupNode for unassigned assets
	for i := range results {
		if strings.TrimSpace(results[i].TopGroupNode) == "" {
			results[i].TopGroupNode = "Unassigned"
		}
	}

	return results, total, nil
}
