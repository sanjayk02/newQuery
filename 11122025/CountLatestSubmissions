// reviewInfo.go

// ---------- Count (for pagination total) ----------
func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	var total int64
	db := r.db.WithContext(ctx)

	// Step 1: Find all unique assets (base statement)
	countStmt := db.Model(
		&model.ReviewInfo{},
	).Where(
		"project = ? AND root = ? AND deleted = 0", project, root,
	).Group(
		"project, root, group_1, relation",
	)

	// Apply Asset Name filter (Partial match on group_1)
	if assetNameKey != "" {
		countStmt = countStmt.Where("group_1 LIKE ?", "%"+assetNameKey+"%")
	}

	// If no status filters are provided, we can count the distinct asset groups directly.
	if len(approvalStatuses) == 0 && len(workStatuses) == 0 {
		var count int64
		// Use a subquery to count the distinct groups
		err := db.Raw("SELECT COUNT(*) FROM (?) AS x", countStmt).Scan(&count).Error
		return count, err
	}

	// If status filters ARE provided, we need to join against a subquery that identifies
	// the asset keys (group_1, relation) that match the status criteria in ANY phase's latest submission.

	// SQL for finding the distinct asset keys that match the status filters
	const latestStatusSQL = `
SELECT
	group_1, relation
FROM t_review_info AS T1
INNER JOIN (
	SELECT project, root, group_1, relation, MAX(modified_at_utc) AS max_modified
	FROM t_review_info
	WHERE project = ? AND root = ? AND deleted = 0
	GROUP BY project, root, group_1, relation
) AS T2
  ON T1.project = T2.project AND T1.root = T2.root AND T1.group_1 = T2.group_1 AND T1.relation = T2.relation AND T1.modified_at_utc = T2.max_modified
WHERE T1.project = ? AND T1.root = ? AND T1.deleted = 0
`
	latestStatusArgs := []any{project, root, project, root}

	statusFilterClauses := []string{}
	if len(approvalStatuses) > 0 {
		statusFilterClauses = append(statusFilterClauses, fmt.Sprintf("approval_status IN ('%s')", strings.Join(approvalStatuses, "', '")))
	}
	if len(workStatuses) > 0 {
		statusFilterClauses = append(statusFilterClauses, fmt.Sprintf("work_status IN ('%s')", strings.Join(workStatuses, "', '")))
	}

	// This subquery will return the set of asset keys (group_1, relation) that match the status filters
	fullStatusFilterSQL := fmt.Sprintf("SELECT group_1, relation FROM (%s) AS status_check WHERE %s GROUP BY group_1, relation",
		latestStatusSQL, strings.Join(statusFilterClauses, " OR "))

	// Now we combine the Asset Name filter (`countStmt`) and the Status filter (`fullStatusFilterSQL`)
	finalCountStmt := countStmt.
		Joins("INNER JOIN (?) AS filter_keys ON t_review_info.group_1 = filter_keys.group_1 AND t_review_info.relation = filter_keys.relation", db.Raw(fullStatusFilterSQL, latestStatusArgs...))

	// Re-count the number of distinct asset keys
	err := db.Raw("SELECT COUNT(*) FROM (?) AS x", finalCountStmt).Scan(&total).Error

	return total, err
}
