// ---------- Count (for pagination total) ----------
func (r *ReviewInfo) CountLatestSubmissions(
	ctx context.Context,
	project, root, assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) (int64, error) {
	if project == "" {
		return 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	db := r.db.WithContext(ctx)

	// Name predicate: case-insensitive PREFIX (index-friendly)
	nameCond := ""
	var nameArg any
	trim := strings.TrimSpace(assetNameKey)
	if trim != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(trim) + "%"
	}

	// Build status predicate: OR within a type, AND across types
	buildIn := func(col string, vals []string) (string, []any) {
		if len(vals) == 0 {
			return "", nil
		}
		place := strings.Repeat("?,", len(vals))
		place = place[:len(place)-1]
		args := make([]any, 0, len(vals))
		for _, v := range vals {
			args = append(args, strings.ToLower(strings.TrimSpace(v)))
		}
		return fmt.Sprintf("LOWER(%s) IN (%s)", col, place), args
	}
	apprClause, apprArgs := buildIn("approval_status", approvalStatuses)
	workClause, workArgs := buildIn("work_status", workStatuses)

	statusWhere := ""
	statusArgs := []any{}
	if apprClause != "" && workClause != "" {
		statusWhere = " AND (" + apprClause + ") AND (" + workClause + ")"
		statusArgs = append(statusArgs, apprArgs...)
		statusArgs = append(statusArgs, workArgs...)
	} else if apprClause != "" {
		statusWhere = " AND (" + apprClause + ")"
		statusArgs = append(statusArgs, apprArgs...)
	} else if workClause != "" {
		statusWhere = " AND (" + workClause + ")"
		statusArgs = append(statusArgs, workArgs...)
	}

	// Latest per PHASE (not just per asset)
	latestPerPhase := `
WITH latest_phase AS (
  SELECT project, root, group_1, relation, phase,
         work_status, approval_status, submitted_at_utc, modified_at_utc,
         ROW_NUMBER() OVER (
           PARTITION BY project, root, group_1, relation, phase
           ORDER BY modified_at_utc DESC
         ) rn
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0` + nameCond + `
)
SELECT COUNT(*) FROM (
  SELECT project, root, group_1, relation
  FROM latest_phase
  WHERE rn = 1` + statusWhere + `
  GROUP BY project, root, group_1, relation
) x;`

	args := []any{project, root}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)

	var total int64
	if err := db.Raw(latestPerPhase, args...).Scan(&total).Error; err != nil {
		return 0, fmt.Errorf("CountLatestSubmissions: %w", err)
	}
	return total, nil
}
