// ---------- ListLatestSubmissionsDynamic (phase priority is CONDITIONAL) ----------
func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string,
	orderKey string,
	direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	phaseGuard := 0
	if preferredPhase == "" || strings.EqualFold(preferredPhase, "none") {
		phaseGuard = 1
	}

	orderClauseWindow := buildOrderClause("", orderKey, direction)
	orderClauseInner := buildOrderClause("b", orderKey, direction)

	// Name prefix (case-insensitive)
	nameCond := ""
	var nameArg any
	if strings.TrimSpace(assetNameKey) != "" {
		nameCond = " AND LOWER(group_1) LIKE ?"
		nameArg = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}

	// Phase-aware status filter
	statusWhere, statusArgs := buildPhaseAwareStatusWhere(preferredPhase, approvalStatuses, workStatuses)

	// Keys subquery (latest per phase, then apply filters)
	keysSQL := `
WITH latest_phase AS (
  SELECT project, root, group_1, relation, phase,
         work_status, approval_status, submitted_at_utc, modified_at_utc,
         ROW_NUMBER() OVER (
           PARTITION BY project, root, group_1, relation, phase
           ORDER BY modified_at_utc DESC
         ) rn
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0` + nameCond + `
)
SELECT project, root, group_1, relation
FROM latest_phase
WHERE rn = 1` + statusWhere + `
GROUP BY project, root, group_1, relation`

	q := fmt.Sprintf(`
WITH ordered AS (
  SELECT *, ROW_NUMBER() OVER (ORDER BY %s) AS _order
  FROM (
    SELECT b.*
    FROM (
      SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
      GROUP BY project, root, group_1, relation, phase
    ) AS a
    LEFT JOIN (
      SELECT root, project, group_1, phase, relation,
             work_status, approval_status, submitted_at_utc, modified_at_utc, executed_computer
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
    ) AS b
      ON a.project = b.project AND a.root = b.root AND a.group_1 = b.group_1
     AND a.relation = b.relation AND a.phase = b.phase AND a.modified_at_utc = b.modified_at_utc

    -- keep only assets present in filtered keys
    INNER JOIN ( %s ) AS fk
      ON b.project = fk.project AND b.root = fk.root AND b.group_1 = fk.group_1 AND b.relation = fk.relation

    ORDER BY %s
  ) AS k
),
offset_ordered AS (
  SELECT c.*,
         CASE WHEN ? = 1 THEN c._order
              WHEN c.phase = ? THEN c._order
              ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN ? = 1 THEN 0 WHEN b.phase = ? THEN 0 ELSE 1 END,
                    LOWER(b.group_1) ASC, LOWER(b.relation) ASC, b.modified_at_utc DESC
         ) AS _rank
  FROM offset_ordered b
)
SELECT root, project, group_1, relation, phase, submitted_at_utc
FROM (SELECT * FROM ranked WHERE _rank = 1) AS t
ORDER BY __order ASC
LIMIT ? OFFSET ?;`, orderClauseWindow, keysSQL, orderClauseInner)

	args := []any{
		// 'a' CTE
		project, root,
		// 'b' join
		project, root,
		// keys subquery params (project, root, [nameArg?], statusArgs...)
		project, root,
	}
	if nameArg != nil {
		args = append(args, nameArg)
	}
	args = append(args, statusArgs...)
	// phase offsets + limit/offset
	args = append(args, phaseGuard, preferredPhase, phaseGuard, preferredPhase, limit, offset)

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}
