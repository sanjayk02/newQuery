func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// 1) Get total count for pagination (after filters)
	total, err := r.CountLatestSubmissions(ctx, project, root, assetNameKey, preferredPhase, approvalStatuses, workStatuses)
	if err != nil {
		return nil, 0, err
	}

	// 2) Get page "keys" (one primary row per asset, correctly ordered)
	keys, err := r.ListLatestSubmissionsDynamic(ctx, project, root, preferredPhase, orderKey, direction, limit, offset, assetNameKey, approvalStatuses, workStatuses)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// 3) Phase fetch â€” fully optimized
	var sb strings.Builder
	var params []any

	sb.WriteString(`
WITH asset_keys AS (
`)

	for i, k := range keys {
		if i > 0 {
			sb.WriteString("  UNION ALL\n")
		}
		sb.WriteString("  SELECT ? AS project, ? AS root, ? AS group_1, ? AS relation\n")
		params = append(params, k.Project, k.Root, k.Group1, k.Relation)
	}

	sb.WriteString(`
),
ranked AS (
  SELECT
    ri.project,
    ri.root,
    ri.group_1,
    ri.relation,
    ri.phase,
    ri.work_status,
    ri.approval_status,
    ri.submitted_at_utc,
    ri.` + "`groups`" + `,
    ROW_NUMBER() OVER (
      PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
      ORDER BY ri.modified_at_utc DESC
    ) AS rn
  FROM t_review_info ri
  INNER JOIN asset_keys ak
          ON ak.project  = ri.project
         AND ak.root     = ri.root
         AND ak.group_1  = ri.group_1
         AND ak.relation = ri.relation
  WHERE ri.deleted = 0
),
latest_only AS (
  /* FIX: Filter for rn = 1 BEFORE joining to category tables.
     This reduces the JSON operations from thousands to just a handful. */
  SELECT * FROM ranked WHERE rn = 1
)
SELECT
  lo.project,
  lo.root,
  lo.group_1,
  lo.relation,
  lo.phase,
  lo.work_status,
  lo.approval_status,
  lo.submitted_at_utc,
  JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]')) AS leaf_group_name,
  gc.path AS group_category_path,
  SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
FROM latest_only lo
LEFT JOIN t_group_category_group gcg
       ON gcg.project = lo.project
      AND gcg.deleted = 0
      AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(lo.` + "`groups`" + `, '$[0]'))
LEFT JOIN t_group_category gc
       ON gc.id = gcg.group_category_id
      AND gc.deleted = 0
      AND gc.root = 'assets';
`)

	var phases []phaseRow
	if err := r.db.WithContext(ctx).Raw(sb.String(), params...).Scan(&phases).Error; err != nil {
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// ... [Rest of your stitching logic remains the same] ...
