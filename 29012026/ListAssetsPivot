func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// Add a generous timeout
	ctxWithTimeout, cancel := context.WithTimeout(ctx, 120*time.Second)
	defer cancel()

	// Optimize: Move JSON extraction to later stage to reduce early processing
	query := `
	WITH LatestPerPhase AS (
		SELECT
			ri.project,
			ri.root,
			ri.group_1,
			ri.relation,
			ri.phase,
			ri.work_status,
			ri.approval_status,
			ri.submitted_at_utc,
			ri.modified_at_utc,
			ri.groups -- Don't extract JSON here, do it later
		FROM t_review_info ri
		WHERE ri.project = ?
		  AND ri.root = ?
		  AND ri.deleted = 0
		  AND (LOWER(ri.group_1) LIKE LOWER(?) OR ? = '')
		  AND ` + buildStatusWhereClause(approvalStatuses, workStatuses) + `
	),

	LatestOnly AS (
		SELECT *,
			ROW_NUMBER() OVER (
				PARTITION BY project, root, group_1, relation, phase
				ORDER BY modified_at_utc DESC
			) AS rn
		FROM LatestPerPhase
	),

	FilteredLatest AS (
		SELECT * FROM LatestOnly WHERE rn = 1
	),

	DistinctAssets AS (
		SELECT
			project,
			root,
			group_1,
			relation,
			COUNT(*) OVER () AS total_count
		FROM FilteredLatest
		GROUP BY project, root, group_1, relation
	),

	OrderedAssets AS (
		SELECT
			da.*,
			ROW_NUMBER() OVER (
				ORDER BY LOWER(da.group_1) ASC
			) AS asset_order
		FROM DistinctAssets da
	),

	PaginatedAssets AS (
		SELECT *
		FROM OrderedAssets
		WHERE asset_order > ? AND asset_order <= ?
	),

	Pivoted AS (
		SELECT
			pa.project,
			pa.root,
			pa.group_1,
			pa.relation,
			pa.total_count,
			pa.asset_order,

			-- Get group info efficiently (only for the paginated assets)
			-- Use MAX() aggregation for the groups column to satisfy ONLY_FULL_GROUP_BY
			COALESCE(
				(SELECT gc.path 
				 FROM t_group_category_group gcg
				 JOIN t_group_category gc ON gc.id = gcg.group_category_id
				 WHERE gcg.project = pa.project 
				   AND gcg.deleted = 0
				   AND gc.deleted = 0
				   AND gc.root = 'assets'
				   AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(MAX(fl.groups), '$[0]'))
				 LIMIT 1),
				'Unassigned'
			) as group_category_path,
			COALESCE(
				SUBSTRING_INDEX(
					COALESCE(
						(SELECT gc.path 
						 FROM t_group_category_group gcg
						 JOIN t_group_category gc ON gc.id = gcg.group_category_id
						 WHERE gcg.project = pa.project 
						   AND gcg.deleted = 0
						   AND gc.deleted = 0
						   AND gc.root = 'assets'
						   AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(MAX(fl.groups), '$[0]'))
						 LIMIT 1),
						'Unassigned'
					),
					'/', 1
				),
				'Unassigned'
			) as top_group_node,
			COALESCE(SUBSTRING_INDEX(
				COALESCE(
					(SELECT gc.path 
					 FROM t_group_category_group gcg
					 JOIN t_group_category gc ON gc.id = gcg.group_category_id
					 WHERE gcg.project = pa.project 
					   AND gcg.deleted = 0
					   AND gc.deleted = 0
					   AND gc.root = 'assets'
					   AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(MAX(fl.groups), '$[0]'))
					 LIMIT 1),
					'Unassigned'
				),
				'/', -1
			), '') as leaf_group_name,

			-- Phase data - all aggregated with MAX()
			MAX(CASE WHEN fl.phase = 'mdl' THEN fl.work_status END) AS mdl_work_status,
			MAX(CASE WHEN fl.phase = 'mdl' THEN fl.approval_status END) AS mdl_approval_status,
			MAX(CASE WHEN fl.phase = 'mdl' THEN fl.submitted_at_utc END) AS mdl_submitted_at_utc,

			MAX(CASE WHEN fl.phase = 'rig' THEN fl.work_status END) AS rig_work_status,
			MAX(CASE WHEN fl.phase = 'rig' THEN fl.approval_status END) AS rig_approval_status,
			MAX(CASE WHEN fl.phase = 'rig' THEN fl.submitted_at_utc END) AS rig_submitted_at_utc,

			MAX(CASE WHEN fl.phase = 'bld' THEN fl.work_status END) AS bld_work_status,
			MAX(CASE WHEN fl.phase = 'bld' THEN fl.approval_status END) AS bld_approval_status,
			MAX(CASE WHEN fl.phase = 'bld' THEN fl.submitted_at_utc END) AS bld_submitted_at_utc,

			MAX(CASE WHEN fl.phase = 'dsn' THEN fl.work_status END) AS dsn_work_status,
			MAX(CASE WHEN fl.phase = 'dsn' THEN fl.approval_status END) AS dsn_approval_status,
			MAX(CASE WHEN fl.phase = 'dsn' THEN fl.submitted_at_utc END) AS dsn_submitted_at_utc,

			MAX(CASE WHEN fl.phase = 'ldv' THEN fl.work_status END) AS ldv_work_status,
			MAX(CASE WHEN fl.phase = 'ldv' THEN fl.approval_status END) AS ldv_approval_status,
			MAX(CASE WHEN fl.phase = 'ldv' THEN fl.submitted_at_utc END) AS ldv_submitted_at_utc

		FROM PaginatedAssets pa
		LEFT JOIN FilteredLatest fl
			ON fl.project = pa.project
			AND fl.root = pa.root
			AND fl.group_1 = pa.group_1
			AND fl.relation = pa.relation
		GROUP BY
			pa.project, pa.root, pa.group_1, pa.relation,
			pa.total_count, pa.asset_order
	)

	SELECT 
		root,
		project,
		group_1,
		relation,
		group_category_path,
		top_group_node,
		leaf_group_name,
		mdl_work_status,
		mdl_approval_status,
		mdl_submitted_at_utc,
		rig_work_status,
		rig_approval_status,
		rig_submitted_at_utc,
		bld_work_status,
		bld_approval_status,
		bld_submitted_at_utc,
		dsn_work_status,
		dsn_approval_status,
		dsn_submitted_at_utc,
		ldv_work_status,
		ldv_approval_status,
		ldv_submitted_at_utc,
		total_count,
		asset_order
	FROM Pivoted
	ORDER BY asset_order
	`

	// Build parameters
	params := []interface{}{
		project, root,
	}
	
	// Name search
	namePattern := ""
	if assetNameKey != "" {
		namePattern = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}
	params = append(params, namePattern, namePattern)
	
	// Add status filter parameters
	for _, s := range approvalStatuses {
		params = append(params, strings.ToLower(strings.TrimSpace(s)))
	}
	for _, s := range workStatuses {
		params = append(params, strings.ToLower(strings.TrimSpace(s)))
	}
	
	// Pagination
	params = append(params, offset, offset+limit)
	
	// Execute query
	var rows []struct {
		AssetPivot
		TotalCount int64 `gorm:"column:total_count"`
		AssetOrder int64 `gorm:"column:asset_order"`
	}
	
	if err := r.db.WithContext(ctxWithTimeout).Raw(query, params...).Scan(&rows).Error; err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			// Try a simpler approach if timeout
			return r.listAssetsPivotFallback(ctx, project, root, limit, offset, assetNameKey)
		}
		return nil, 0, fmt.Errorf("ListAssetsPivot: %w", err)
	}
	
	// Extract results
	var total int64 = 0
	results := make([]AssetPivot, 0, len(rows))
	
	for i, row := range rows {
		results = append(results, AssetPivot{
			Root:              row.Root,
			Project:           row.Project,
			Group1:            row.Group1,
			Relation:          row.Relation,
			LeafGroupName:     row.LeafGroupName,
			GroupCategoryPath: row.GroupCategoryPath,
			TopGroupNode:      row.TopGroupNode,
			MDLWorkStatus:     row.MDLWorkStatus,
			MDLApprovalStatus: row.MDLApprovalStatus,
			MDLSubmittedAtUTC: row.MDLSubmittedAtUTC,
			RIGWorkStatus:     row.RIGWorkStatus,
			RIGApprovalStatus: row.RIGApprovalStatus,
			RIGSubmittedAtUTC: row.RIGSubmittedAtUTC,
			BLDWorkStatus:     row.BLDWorkStatus,
			BLDApprovalStatus: row.BLDApprovalStatus,
			BLDSubmittedAtUTC: row.BLDSubmittedAtUTC,
			DSNWorkStatus:     row.DSNWorkStatus,
			DSNApprovalStatus: row.DSNApprovalStatus,
			DSNSubmittedAtUTC: row.DSNSubmittedAtUTC,
			LDVWorkStatus:     row.LDVWorkStatus,
			LDVApprovalStatus: row.LDVApprovalStatus,
			LDVSubmittedAtUTC: row.LDVSubmittedAtUTC,
		})
		if i == 0 {
			total = row.TotalCount
		}
	}
	
	return results, total, nil
}
