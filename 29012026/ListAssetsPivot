func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {
	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}

	// Add timeout context
	ctxWithTimeout, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// Build query without the self-reference issue
	query := `
	WITH LatestReviews AS (
		SELECT 
			ri.*,
			ROW_NUMBER() OVER (
				PARTITION BY ri.project, ri.root, ri.group_1, ri.relation, ri.phase
				ORDER BY ri.modified_at_utc DESC
			) AS rn
		FROM t_review_info ri
		WHERE ri.project = ?
		AND ri.root = ?
		AND ri.deleted = 0
		AND (LOWER(ri.group_1) LIKE LOWER(?) OR ? = '')
	),
	LatestOnly AS (
		SELECT * FROM LatestReviews WHERE rn = 1
	),
	FilteredLatest AS (
		SELECT 
			lo.*,
			CASE 
				WHEN ` + buildStatusMatchCondition(workStatuses, approvalStatuses) + ` THEN 1
				ELSE 0
			END AS matches_filter
		FROM LatestOnly lo
	),
	FilteredAssets AS (
		SELECT DISTINCT
			project,
			root,
			group_1,
			relation,
			-- Get group info efficiently
			COALESCE(
				(SELECT gc.path 
				 FROM t_group_category_group gcg
				 JOIN t_group_category gc ON gc.id = gcg.group_category_id
				 WHERE gcg.project = fl.project 
				   AND gcg.deleted = 0
				   AND gc.deleted = 0
				   AND gc.root = 'assets'
				   AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(fl.groups, '$[0]'))
				 LIMIT 1),
				'Unassigned'
			) as group_category_path,
			COALESCE(
				SUBSTRING_INDEX(
					COALESCE(
						(SELECT gc.path 
						 FROM t_group_category_group gcg
						 JOIN t_group_category gc ON gc.id = gcg.group_category_id
						 WHERE gcg.project = fl.project 
						   AND gcg.deleted = 0
						   AND gc.deleted = 0
						   AND gc.root = 'assets'
						   AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(fl.groups, '$[0]'))
						 LIMIT 1),
						'Unassigned'
					),
					'/', 1
				),
				'Unassigned'
			) as top_group_node,
			COUNT(*) OVER () AS total_count
		FROM FilteredLatest fl
		WHERE (CASE 
			WHEN ? = 0 AND ? = 0 THEN 1  -- No status filters
			ELSE matches_filter
		END) = 1
		GROUP BY project, root, group_1, relation
	),
	PaginatedAssets AS (
		SELECT 
			fa.*,
			ROW_NUMBER() OVER (
				ORDER BY 
					CASE WHEN ? = 'group1_only' THEN LOWER(fa.group_1) END,
					CASE WHEN ? = 'group1_only' THEN LOWER(fa.relation) END,
					CASE WHEN ? = 'relation_only' THEN LOWER(fa.relation) END,
					CASE WHEN ? = 'relation_only' THEN LOWER(fa.group_1) END,
					-- Default ordering
					LOWER(fa.group_1) ASC,
					LOWER(fa.relation) ASC
			) AS asset_order
		FROM FilteredAssets fa
	)
	SELECT 
		pa.root,
		pa.project,
		pa.group_1,
		pa.relation,
		pa.group_category_path,
		pa.top_group_node,
		COALESCE(SUBSTRING_INDEX(pa.group_category_path, '/', -1), '') as leaf_group_name,
		-- MDL Phase
		MAX(CASE WHEN fl.phase = 'mdl' THEN fl.work_status END) AS mdl_work_status,
		MAX(CASE WHEN fl.phase = 'mdl' THEN fl.approval_status END) AS mdl_approval_status,
		MAX(CASE WHEN fl.phase = 'mdl' THEN fl.submitted_at_utc END) AS mdl_submitted_at_utc,
		-- RIG Phase
		MAX(CASE WHEN fl.phase = 'rig' THEN fl.work_status END) AS rig_work_status,
		MAX(CASE WHEN fl.phase = 'rig' THEN fl.approval_status END) AS rig_approval_status,
		MAX(CASE WHEN fl.phase = 'rig' THEN fl.submitted_at_utc END) AS rig_submitted_at_utc,
		-- BLD Phase
		MAX(CASE WHEN fl.phase = 'bld' THEN fl.work_status END) AS bld_work_status,
		MAX(CASE WHEN fl.phase = 'bld' THEN fl.approval_status END) AS bld_approval_status,
		MAX(CASE WHEN fl.phase = 'bld' THEN fl.submitted_at_utc END) AS bld_submitted_at_utc,
		-- DSN Phase
		MAX(CASE WHEN fl.phase = 'dsn' THEN fl.work_status END) AS dsn_work_status,
		MAX(CASE WHEN fl.phase = 'dsn' THEN fl.approval_status END) AS dsn_approval_status,
		MAX(CASE WHEN fl.phase = 'dsn' THEN fl.submitted_at_utc END) AS dsn_submitted_at_utc,
		-- LDV Phase
		MAX(CASE WHEN fl.phase = 'ldv' THEN fl.work_status END) AS ldv_work_status,
		MAX(CASE WHEN fl.phase = 'ldv' THEN fl.approval_status END) AS ldv_approval_status,
		MAX(CASE WHEN fl.phase = 'ldv' THEN fl.submitted_at_utc END) AS ldv_submitted_at_utc,
		pa.total_count,
		pa.asset_order
	FROM PaginatedAssets pa
	LEFT JOIN FilteredLatest fl ON 
		fl.project = pa.project 
		AND fl.root = pa.root 
		AND fl.group_1 = pa.group_1 
		AND fl.relation = pa.relation
		AND (CASE 
			WHEN ? = 0 AND ? = 0 THEN 1  -- No status filters
			ELSE fl.matches_filter
		END) = 1
	WHERE pa.asset_order > ? AND pa.asset_order <= ?
	GROUP BY 
		pa.project, pa.root, pa.group_1, pa.relation,
		pa.group_category_path, pa.top_group_node,
		pa.total_count, pa.asset_order
	ORDER BY pa.asset_order
	`

	// Build parameters
	params := []interface{}{
		// LatestReviews
		project, root,
	}
	
	// Name search
	namePattern := ""
	if assetNameKey != "" {
		namePattern = strings.ToLower(strings.TrimSpace(assetNameKey)) + "%"
	}
	params = append(params, namePattern, namePattern)
	
	// Status filter parameters for matches_filter calculation
	for _, s := range workStatuses {
		params = append(params, strings.ToLower(strings.TrimSpace(s)))
	}
	for _, s := range approvalStatuses {
		params = append(params, strings.ToLower(strings.TrimSpace(s)))
	}
	
	// Status filter flags - first set for FilteredAssets WHERE clause
	hasWorkFilter := len(workStatuses)
	hasApprovalFilter := len(approvalStatuses)
	params = append(params, hasWorkFilter, hasApprovalFilter)
	
	// Add ordering parameter (repeated for each CASE statement)
	for i := 0; i < 4; i++ {
		params = append(params, orderKey)
	}
	
	// Status filter flags again for the JOIN condition
	params = append(params, hasWorkFilter, hasApprovalFilter)
	
	// Pagination
	params = append(params, offset, offset+limit)
	
	// Execute query with timeout
	var rows []struct {
		AssetPivot
		TotalCount int64 `gorm:"column:total_count"`
		AssetOrder int64 `gorm:"column:asset_order"`
	}
	
	if err := r.db.WithContext(ctxWithTimeout).Raw(query, params...).Scan(&rows).Error; err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			return nil, 0, fmt.Errorf("ListAssetsPivot: query timeout")
		}
		return nil, 0, fmt.Errorf("ListAssetsPivot: %w", err)
	}
	
	// Extract results
	var total int64 = 0
	results := make([]AssetPivot, 0, len(rows))
	
	for i, row := range rows {
		results = append(results, AssetPivot{
			Root:              row.Root,
			Project:           row.Project,
			Group1:            row.Group1,
			Relation:          row.Relation,
			LeafGroupName:     row.LeafGroupName,
			GroupCategoryPath: row.GroupCategoryPath,
			TopGroupNode:      row.TopGroupNode,
			MDLWorkStatus:     row.MDLWorkStatus,
			MDLApprovalStatus: row.MDLApprovalStatus,
			MDLSubmittedAtUTC: row.MDLSubmittedAtUTC,
			RIGWorkStatus:     row.RIGWorkStatus,
			RIGApprovalStatus: row.RIGApprovalStatus,
			RIGSubmittedAtUTC: row.RIGSubmittedAtUTC,
			BLDWorkStatus:     row.BLDWorkStatus,
			BLDApprovalStatus: row.BLDApprovalStatus,
			BLDSubmittedAtUTC: row.BLDSubmittedAtUTC,
			DSNWorkStatus:     row.DSNWorkStatus,
			DSNApprovalStatus: row.DSNApprovalStatus,
			DSNSubmittedAtUTC: row.DSNSubmittedAtUTC,
			LDVWorkStatus:     row.LDVWorkStatus,
			LDVApprovalStatus: row.LDVApprovalStatus,
			LDVSubmittedAtUTC: row.LDVSubmittedAtUTC,
		})
		if i == 0 {
			total = row.TotalCount
		}
	}
	
	return results, total, nil
}
