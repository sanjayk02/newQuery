import React, { useCallback, useMemo, useState } from "react";
import {
  Box,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Typography,
  makeStyles,
} from "@material-ui/core";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import { PivotGroup, SortDir } from "./types";

/** ----------------------------------------------------------------
 *  COLOR COLLECTION (single source of truth)
 *  ---------------------------------------------------------------- */
const COLORS = {
  TABLE_BG: "#1e1e1e",
  HEADER_BG: "#2d2d2d",
  HEADER_BORDER: "#3d3d3d",
  GRID_LINE: "#2a2a2a",
  ROW_BG: "#2b2b2b",
  GROUP_BG: "#303030",
  GROUP_TEXT: "#00b7ff",
  TEXT: "#e0e0e0",
  MUTED: "#bdbdbd",

  PHASE: {
    mdl: "#00b7ff",
    rig: "#a333c8",
    bld: "#e91e63",
    dsn: "#00a6a6",
    ldv: "#d14bff",
  },
};

/** Visual spacing + sizing */
const UI = {
  ROW_GAP_PX: 10,
  GROUP_ROW_GAP_PX: 8,
  PHASE_GAP_PX: 14,
  RAIL_PX: 3,

  // row height control
  HEADER_HEIGHT: 34,
  ROW_HEIGHT: 36,

  // widths (adjust to taste)
  THUMB_WIDTH: 80,
  NAME_WIDTH: 260,
  PHASE_COL_WIDTH: 120,
  RELATION_WIDTH: 90,
};

type ColumnId =
  | "thumbnail"
  | "group_1_name"
  | "mdl_work"
  | "mdl_appr"
  | "mdl_submitted"
  | "rig_work"
  | "rig_appr"
  | "rig_submitted"
  | "bld_work"
  | "bld_appr"
  | "bld_submitted"
  | "dsn_work"
  | "dsn_appr"
  | "dsn_submitted"
  | "ldv_work"
  | "ldv_appr"
  | "ldv_submitted"
  | "relation";

type Column = {
  id: ColumnId;
  label: string;
  sortable?: boolean;
  phase?: keyof typeof COLORS.PHASE; // mdl|rig|bld|dsn|ldv
  kind?: "work" | "appr" | "submitted";
};

type Props = {
  groups?: PivotGroup[];
  sortKey: string;
  sortDir: SortDir;
  onSortChange: (key: string) => void;
  dateTimeFormat: Intl.DateTimeFormat;
  hiddenColumns?: Set<string>;
};

const COLUMNS: Column[] = [
  { id: "thumbnail", label: "THUMBNAIL" },
  { id: "group_1_name", label: "NAME", sortable: true },

  { id: "mdl_work", label: "MDL WORK", sortable: true, phase: "mdl", kind: "work" },
  { id: "mdl_appr", label: "MDL APPR", sortable: true, phase: "mdl", kind: "appr" },
  { id: "mdl_submitted", label: "MDL SUBMITTED AT", sortable: true, phase: "mdl", kind: "submitted" },

  { id: "rig_work", label: "RIG WORK", sortable: true, phase: "rig", kind: "work" },
  { id: "rig_appr", label: "RIG APPR", sortable: true, phase: "rig", kind: "appr" },
  { id: "rig_submitted", label: "RIG SUBMITTED AT", sortable: true, phase: "rig", kind: "submitted" },

  { id: "bld_work", label: "BLD WORK", sortable: true, phase: "bld", kind: "work" },
  { id: "bld_appr", label: "BLD APPR", sortable: true, phase: "bld", kind: "appr" },
  { id: "bld_submitted", label: "BLD SUBMITTED AT", sortable: true, phase: "bld", kind: "submitted" },

  { id: "dsn_work", label: "DSN WORK", sortable: true, phase: "dsn", kind: "work" },
  { id: "dsn_appr", label: "DSN APPR", sortable: true, phase: "dsn", kind: "appr" },
  { id: "dsn_submitted", label: "DSN SUBMITTED AT", sortable: true, phase: "dsn", kind: "submitted" },

  { id: "ldv_work", label: "LDV WORK", sortable: true, phase: "ldv", kind: "work" },
  { id: "ldv_appr", label: "LDV APPR", sortable: true, phase: "ldv", kind: "appr" },
  { id: "ldv_submitted", label: "LDV SUBMITTED AT", sortable: true, phase: "ldv", kind: "submitted" },

  { id: "relation", label: "RELATION", sortable: true },
];

/** Hide scrollbar but keep scroll working */
const useStyles = makeStyles({
  scrollX: {
    overflowX: "auto",
    overflowY: "hidden",
    scrollbarWidth: "none", // Firefox
    msOverflowStyle: "none", // IE/Edge legacy
    "&::-webkit-scrollbar": {
      height: 0, // Chrome/Safari
    },
  },
});

/** ------------ helpers (no optional chaining!) ------------ */

function hexToRgb(hex: string) {
  const h = hex.replace("#", "");
  const full = h.length === 3 ? h.split("").map((c) => c + c).join("") : h;
  const n = parseInt(full, 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

function mixHex(bg: string, fg: string, fgAlpha: number) {
  // mix fg over bg
  const b = hexToRgb(bg);
  const f = hexToRgb(fg);
  const a = Math.max(0, Math.min(1, fgAlpha));
  const r = Math.round(f.r * a + b.r * (1 - a));
  const g = Math.round(f.g * a + b.g * (1 - a));
  const bb = Math.round(f.b * a + b.b * (1 - a));
  return `rgb(${r}, ${g}, ${bb})`;
}

function getPhaseRailColor(col: Column) {
  return col.phase ? COLORS.PHASE[col.phase] : "";
}

function isPhaseStart(col: Column, visibleCols: Column[]) {
  if (!col.phase) return false;
  const first = visibleCols.find((c) => c.phase === col.phase);
  return !!first && first.id === col.id; // ✅ no optional chaining
}

function isPhaseEnd(col: Column, visibleCols: Column[]) {
  if (!col.phase) return false;
  const same = visibleCols.filter((c) => c.phase === col.phase);
  if (same.length === 0) return false;
  return same[same.length - 1].id === col.id;
}

function isPhaseMiddle(col: Column, visibleCols: Column[]) {
  if (!col.phase) return false;
  return !isPhaseStart(col, visibleCols) && !isPhaseEnd(col, visibleCols);
}

/**
 * Cell style:
 * - Phase header background tinted (like listview)
 * - Remove internal vertical lines INSIDE phase group
 * - Keep only group boundaries (rails + phase gap)
 * - Row height control
 */
function buildCellStyle(
  col: Column,
  visibleCols: Column[],
  opts: { header?: boolean; isGroupRow?: boolean } = {}
): React.CSSProperties {
  const { header = false, isGroupRow = false } = opts;

  const railColor = getPhaseRailColor(col);
  const start = isPhaseStart(col, visibleCols);
  const end = isPhaseEnd(col, visibleCols);
  const middle = isPhaseMiddle(col, visibleCols);

  const grid = header ? COLORS.HEADER_BORDER : COLORS.GRID_LINE;

  // Header color per phase (match your listview look)
  const headerBg = col.phase
    ? mixHex(COLORS.HEADER_BG, railColor, 0.35)
    : COLORS.HEADER_BG;

  const style: React.CSSProperties = {
    backgroundColor: header ? headerBg : COLORS.ROW_BG,
    color: header ? "#fff" : COLORS.TEXT,
    whiteSpace: "nowrap",
    padding: header ? "6px 8px" : "6px 8px",
    fontSize: header ? "0.70rem" : "0.78rem",
    fontWeight: header ? 900 : 600,
    height: header ? UI.HEADER_HEIGHT : UI.ROW_HEIGHT,
    lineHeight: header ? `${UI.HEADER_HEIGHT}px` : `${UI.ROW_HEIGHT}px`,
    verticalAlign: "middle",
    borderBottom: header
      ? `1px solid ${grid}`
      : isGroupRow
      ? `${UI.GROUP_ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`
      : `${UI.ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,

    // default vertical line
    borderRight: `1px solid ${grid}`,
  };

  /**
   * ✅ Remove internal vertical lines inside the phase group:
   * - middle columns => no borderRight
   * - start column => keep only left rail via inset shadow, but remove borderRight
   * - end column => add phase gap instead of normal borderRight
   */
  if (col.phase) {
    // top rail only on header
    if (header) style.borderTop = `${UI.RAIL_PX + 1}px solid ${railColor}`;

    const shadows: string[] = [];

    // left rail at group start
    if (start) shadows.push(`inset ${UI.RAIL_PX}px 0 0 0 ${railColor}`);

    // right rail at group end
    if (end) shadows.push(`inset -${UI.RAIL_PX}px 0 0 0 ${railColor}`);

    style.boxShadow = shadows.join(", ");

    // remove inner separators
    if (start || middle) {
      style.borderRight = "none";
    }

    // phase gap after end
    if (end) {
      style.borderRight = `${UI.PHASE_GAP_PX}px solid ${COLORS.TABLE_BG}`;
    }
  }

  // Non-phase columns (thumbnail/name/relation) keep regular grid
  if (!col.phase) {
    style.borderRight = `1px solid ${grid}`;
  }

  return style;
}

/** data format */
function formatSubmitted(val: any) {
  if (!val || val === "-") return "-";
  return String(val).split("T")[0];
}

function statusColor(status?: string) {
  const s = (status || "").toLowerCase();
  if (!s || s === "-") return COLORS.MUTED;
  if (s.includes("approved")) return "#32cd32";
  if (s.includes("review")) return "#ffa500";
  if (s.includes("retake")) return "#ff4f4f";
  if (s.includes("hold")) return "#ffdd55";
  if (s === "check") return "#ca25ed";
  return COLORS.MUTED;
}

function renderAssetField(asset: any, col: Column) {
  if (col.id === "thumbnail") {
    return (
      <Typography style={{ fontSize: "0.75rem", fontWeight: 700 }}>
        {asset.thumbnail ? "Thumbnail" : "No Thumbnail"}
      </Typography>
    );
  }

  if (col.id === "group_1_name") {
    return (
      <Typography noWrap style={{ fontSize: "0.80rem", fontWeight: 800 }}>
        {asset.group_1 || ""}
      </Typography>
    );
  }

  if (col.id === "relation") {
    return (
      <Typography noWrap style={{ fontSize: "0.75rem", fontWeight: 700 }}>
        {asset.relation || "-"}
      </Typography>
    );
  }

  const phase = col.phase;
  if (!phase) return <span>-</span>;

  if (col.kind === "submitted") {
    return (
      <Typography noWrap style={{ fontSize: "0.72rem", fontWeight: 700 }}>
        {formatSubmitted(asset[`${phase}_submitted_at_utc`])}
      </Typography>
    );
  }

  const field = col.kind === "work" ? "work_status" : "approval_status";
  const raw = asset[`${phase}_${field}`];
  const text = raw || "-";

  return (
    <Typography
      noWrap
      style={{ fontSize: "0.72rem", fontWeight: 800, color: statusColor(text) }}
    >
      {text}
    </Typography>
  );
}

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  sortKey,
  sortDir,
  onSortChange,
  dateTimeFormat, // kept
  hiddenColumns = new Set(),
}) => {
  const classes = useStyles();
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  const toggle = useCallback((key: string) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  }, []);

  const visibleColumns = useMemo(
    () => COLUMNS.filter((c) => !hiddenColumns.has(c.id)),
    [hiddenColumns]
  );

  return (
    <Box width="100%" style={{ backgroundColor: COLORS.TABLE_BG }}>
      {/* ✅ wrapper hides scrollbar + removes right empty space */}
      <Box className={classes.scrollX} style={{ backgroundColor: COLORS.TABLE_BG }}>
        <Table
          size="small"
          stickyHeader
          style={{
            // ✅ IMPORTANT: fixes right-side empty gray space
            width: "max-content",
            minWidth: "100%",

            // keep borders clean
            borderCollapse: "separate",
            borderSpacing: 0,
            backgroundColor: COLORS.TABLE_BG,
          }}
        >
          {/* ✅ fixed widths so table is stable */}
          <colgroup>
            {visibleColumns.map((col) => (
              <col
                key={col.id}
                style={{
                  width:
                    col.id === "thumbnail"
                      ? UI.THUMB_WIDTH
                      : col.id === "group_1_name"
                      ? UI.NAME_WIDTH
                      : col.id === "relation"
                      ? UI.RELATION_WIDTH
                      : UI.PHASE_COL_WIDTH,
                }}
              />
            ))}
          </colgroup>

          <TableHead>
            <TableRow style={{ height: UI.HEADER_HEIGHT }}>
              {visibleColumns.map((col) => (
                <TableCell
                  key={col.id}
                  align={col.id === "group_1_name" ? "left" : "center"}
                  onClick={() => col.sortable && onSortChange(col.id)}
                  style={{
                    ...buildCellStyle(col, visibleColumns, { header: true }),
                    cursor: col.sortable ? "pointer" : "default",
                    paddingTop: 0,
                    paddingBottom: 0,
                  }}
                >
                  <Box
                    display="flex"
                    alignItems="center"
                    justifyContent={col.id === "group_1_name" ? "flex-start" : "center"}
                  >
                    <Typography
                      style={{
                        fontSize: "0.70rem",
                        fontWeight: 900,
                        letterSpacing: 0.3,
                      }}
                    >
                      {col.label}
                    </Typography>
                    {sortKey === col.id &&
                      (sortDir === "asc" ? (
                        <ArrowDropUpIcon fontSize="small" />
                      ) : (
                        <ArrowDropDownIcon fontSize="small" />
                      ))}
                  </Box>
                </TableCell>
              ))}
            </TableRow>
          </TableHead>

          <TableBody>
            {groups.map((group) => {
              const groupName = group.top_group_node || "UNASSIGNED";
              const isCollapsed = !!collapsed[groupName];

              return (
                <React.Fragment key={groupName}>
                  {/* Group row */}
                  <TableRow onClick={() => toggle(groupName)} style={{ cursor: "pointer" }}>
                    <TableCell
                      colSpan={visibleColumns.length}
                      style={{
                        backgroundColor: COLORS.GROUP_BG,
                        color: COLORS.GROUP_TEXT,
                        borderBottom: `${UI.GROUP_ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,
                        padding: "6px 8px",
                      }}
                    >
                      <Box display="flex" alignItems="center">
                        <IconButton size="small" style={{ color: COLORS.GROUP_TEXT, padding: 0 }}>
                          {isCollapsed ? (
                            <ChevronRightIcon fontSize="small" />
                          ) : (
                            <ExpandMoreIcon fontSize="small" />
                          )}
                        </IconButton>
                        <Typography
                          style={{
                            color: COLORS.GROUP_TEXT,
                            fontSize: "0.80rem",
                            fontWeight: 900,
                            marginLeft: 10,
                            letterSpacing: 0.3,
                          }}
                        >
                          {groupName.toUpperCase()}{" "}
                          <span style={{ fontSize: "0.75rem", fontWeight: 800 }}>
                            ({group.items?.length || 0})
                          </span>
                        </Typography>
                      </Box>
                    </TableCell>
                  </TableRow>

                  {/* Data rows */}
                  {!isCollapsed &&
                    (group.items || []).map((asset: any, idx: number) => (
                      <TableRow key={`${groupName}-${idx}`} hover style={{ height: UI.ROW_HEIGHT }}>
                        {visibleColumns.map((col) => (
                          <TableCell
                            key={col.id}
                            align={col.id === "group_1_name" ? "left" : "center"}
                            style={{
                              ...buildCellStyle(col, visibleColumns),
                              paddingTop: 0,
                              paddingBottom: 0,
                            }}
                          >
                            {renderAssetField(asset, col)}
                          </TableCell>
                        ))}
                      </TableRow>
                    ))}
                </React.Fragment>
              );
            })}
          </TableBody>
        </Table>
      </Box>
    </Box>
  );
};

export default AssetsGroupedDataTable;
