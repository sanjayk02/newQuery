import React, { useCallback, useMemo, useState } from "react";
import {
  Box,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Typography,
} from "@material-ui/core";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import { PivotGroup, SortDir } from "./types";

/** ----------------------------------------------------------------
 *  COLOR COLLECTION (single source of truth)
 *  ---------------------------------------------------------------- */
const COLORS = {
  TABLE_BG: "#1e1e1e",
  HEADER_BG: "#2d2d2d",
  HEADER_BORDER: "#3d3d3d",
  GRID_LINE: "#2a2a2a",
  ROW_BG: "#2b2b2b",
  GROUP_BG: "#303030",
  GROUP_TEXT: "#00b7ff",
  TEXT: "#e0e0e0",
  MUTED: "#bdbdbd",

  PHASE: {
    mdl: "#00b7ff",
    rig: "#a333c8",
    bld: "#e91e63",
    dsn: "#00a6a6",
    ldv: "#d14bff",
  },
};

/** Visual spacing + sizes */
const UI = {
  ROW_GAP_PX: 10, // gap between data rows (table bg showing)
  GROUP_ROW_GAP_PX: 8,
  PHASE_GAP_PX: 14, // gap after each phase block
  RAIL_PX: 3,

  // HEIGHT CONTROL
  ROW_HEIGHT_PX: 34,
  HEADER_HEIGHT_PX: 34,
  GROUP_ROW_HEIGHT_PX: 32,

  // WIDTH CONTROL
  THUMB_WIDTH: 70,
  NAME_WIDTH: 260,
  PHASE_COL_WIDTH: 110,
  RELATION_WIDTH: 90,
};

type ColumnId =
  | "thumbnail"
  | "group_1_name"
  | "mdl_work"
  | "mdl_appr"
  | "mdl_submitted"
  | "rig_work"
  | "rig_appr"
  | "rig_submitted"
  | "bld_work"
  | "bld_appr"
  | "bld_submitted"
  | "dsn_work"
  | "dsn_appr"
  | "dsn_submitted"
  | "ldv_work"
  | "ldv_appr"
  | "ldv_submitted"
  | "relation";

type Column = {
  id: ColumnId;
  label: string;
  sortable?: boolean;
  phase?: keyof typeof COLORS.PHASE; // mdl|rig|bld|dsn|ldv
  kind?: "work" | "appr" | "submitted";
};

type Props = {
  groups?: PivotGroup[];
  sortKey: string;
  sortDir: SortDir;
  onSortChange: (key: string) => void;
  dateTimeFormat: Intl.DateTimeFormat;
  hiddenColumns?: Set<string>;
};

const COLUMNS: Column[] = [
  { id: "thumbnail", label: "THUMBS" },
  { id: "group_1_name", label: "NAME", sortable: true },

  { id: "mdl_work", label: "MDL WORK", sortable: true, phase: "mdl", kind: "work" },
  { id: "mdl_appr", label: "MDL APPR", sortable: true, phase: "mdl", kind: "appr" },
  { id: "mdl_submitted", label: "MDL SUBMITTED AT", sortable: true, phase: "mdl", kind: "submitted" },

  { id: "rig_work", label: "RIG WORK", sortable: true, phase: "rig", kind: "work" },
  { id: "rig_appr", label: "RIG APPR", sortable: true, phase: "rig", kind: "appr" },
  { id: "rig_submitted", label: "RIG SUBMITTED AT", sortable: true, phase: "rig", kind: "submitted" },

  { id: "bld_work", label: "BLD WORK", sortable: true, phase: "bld", kind: "work" },
  { id: "bld_appr", label: "BLD APPR", sortable: true, phase: "bld", kind: "appr" },
  { id: "bld_submitted", label: "BLD SUBMITTED AT", sortable: true, phase: "bld", kind: "submitted" },

  { id: "dsn_work", label: "DSN WORK", sortable: true, phase: "dsn", kind: "work" },
  { id: "dsn_appr", label: "DSN APPR", sortable: true, phase: "dsn", kind: "appr" },
  { id: "dsn_submitted", label: "DSN SUBMITTED AT", sortable: true, phase: "dsn", kind: "submitted" },

  { id: "ldv_work", label: "LDV WORK", sortable: true, phase: "ldv", kind: "work" },
  { id: "ldv_appr", label: "LDV APPR", sortable: true, phase: "ldv", kind: "appr" },
  { id: "ldv_submitted", label: "LDV SUBMITTED AT", sortable: true, phase: "ldv", kind: "submitted" },

  { id: "relation", label: "RELATION", sortable: true },
];

function getPhaseRailColor(col: Column) {
  if (!col.phase) return "";
  return COLORS.PHASE[col.phase];
}

/** No optional chaining (to avoid babel/plugin issues) */
function isPhaseStart(col: Column, visibleCols: Column[]) {
  if (!col.phase) return false;
  const first = visibleCols.find((c) => c.phase === col.phase);
  return first ? first.id === col.id : false;
}

/** No optional chaining (to avoid babel/plugin issues) */
function isPhaseEnd(col: Column, visibleCols: Column[]) {
  if (!col.phase) return false;
  const samePhase = visibleCols.filter((c) => c.phase === col.phase);
  if (samePhase.length === 0) return false;
  return samePhase[samePhase.length - 1].id === col.id;
}

/**
 * Cell style:
 * - Phase rails (colored)
 * - Phase gap only at phase END
 * - Remove inner vertical lines inside phase block (your request)
 * - Row gap (by thick border-bottom in TABLE_BG)
 */
function buildCellStyle(
  col: Column,
  visibleCols: Column[],
  opts: { header?: boolean; isGroupRow?: boolean } = {}
): React.CSSProperties {
  const { header = false, isGroupRow = false } = opts;

  const baseBg = header ? COLORS.HEADER_BG : COLORS.ROW_BG;
  const railColor = getPhaseRailColor(col);

  const grid = header ? COLORS.HEADER_BORDER : COLORS.GRID_LINE;

  const style: React.CSSProperties = {
    backgroundColor: baseBg,
    color: header ? "#fff" : COLORS.TEXT,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    padding: header ? "6px 6px" : "6px 6px",
    fontSize: header ? "0.65rem" : "0.8rem",
    height: header ? UI.HEADER_HEIGHT_PX : UI.ROW_HEIGHT_PX,
    boxSizing: "border-box",

    // default grid
    borderBottom: header
      ? `1px solid ${grid}`
      : isGroupRow
      ? `${UI.GROUP_ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`
      : `${UI.ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,

    // IMPORTANT:
    // remove vertical lines INSIDE phase groups
    borderRight: col.phase ? "none" : `1px solid ${grid}`,
  };

  // phase rails + phase gaps
  if (col.phase) {
    const start = isPhaseStart(col, visibleCols);
    const end = isPhaseEnd(col, visibleCols);

    // top rail on header
    if (header) {
      style.borderTop = `${UI.RAIL_PX + 1}px solid ${railColor}`;
    }

    // left rail
    if (start) {
      style.boxShadow = `inset ${UI.RAIL_PX}px 0 0 0 ${railColor}`;
      // keep a subtle separator between NAME and the phase block
      if (!header) {
        // nothing needed; the rail itself is the separator
      }
    }

    // right rail + phase gap at the END only
    if (end) {
      const currentShadow = style.boxShadow ? style.boxShadow + ", " : "";
      style.boxShadow = `${currentShadow}inset -${UI.RAIL_PX}px 0 0 0 ${railColor}`;
      style.borderRight = `${UI.PHASE_GAP_PX}px solid ${COLORS.TABLE_BG}`;
    }
  }

  return style;
}

function formatSubmitted(val: any) {
  if (!val || val === "-") return "-";
  return String(val).split("T")[0];
}

function statusColor(status?: string) {
  const s = (status || "").toLowerCase();
  if (!s || s === "-") return COLORS.MUTED;

  if (s.includes("approved")) return "#32cd32";
  if (s.includes("review")) return "#ffa500";
  if (s.includes("retake")) return "#ff4f4f";
  if (s.includes("hold")) return "#ffdd55";
  if (s === "check") return "#ca25ed";

  return COLORS.MUTED;
}

function renderAssetField(asset: any, col: Column) {
  if (col.id === "thumbnail") {
    return (
      <Box
        width={40}
        height={22}
        bgcolor="#2a2a2a"
        style={{ border: "1px solid #444", margin: "auto" }}
      />
    );
  }

  if (col.id === "group_1_name") {
    return (
      <Typography
        noWrap
        style={{ fontSize: "0.85rem", fontWeight: 700, paddingLeft: 10 }}
      >
        {asset.group_1 || ""}
      </Typography>
    );
  }

  if (col.id === "relation") {
    return (
      <Typography noWrap style={{ fontSize: "0.75rem" }}>
        {asset.relation || "-"}
      </Typography>
    );
  }

  const phase = col.phase;
  if (!phase) return <span>-</span>;

  if (col.kind === "submitted") {
    return (
      <Typography noWrap style={{ fontSize: "0.75rem" }}>
        {formatSubmitted(asset[`${phase}_submitted_at_utc`])}
      </Typography>
    );
  }

  const field = col.kind === "work" ? "work_status" : "approval_status";
  const raw = asset[`${phase}_${field}`];
  const text = raw || "-";

  return (
    <Typography noWrap style={{ fontSize: "0.75rem", color: statusColor(text) }}>
      {text}
    </Typography>
  );
}

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  sortKey,
  sortDir,
  onSortChange,
  dateTimeFormat, // kept; not used here
  hiddenColumns = new Set(),
}) => {
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  const toggle = useCallback((key: string) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  }, []);

  const visibleColumns = useMemo(
    () => COLUMNS.filter((c) => !hiddenColumns.has(c.id)),
    [hiddenColumns]
  );

  return (
    <Box
      width="100%"
      style={{
        backgroundColor: COLORS.TABLE_BG,

        // keep scroll functionality but hide bar
        overflowX: "auto",
        overflowY: "auto",

        // Firefox
        scrollbarWidth: "none",
        // IE/Edge legacy
        msOverflowStyle: "none",

        // IMPORTANT to avoid any weird right-side space
        maxWidth: "100%",
      }}
      // WebKit (Chrome/Safari) hide scrollbar
      className="assetsGroupedTableScroll"
    >
      {/* Hide scrollbar for webkit */}
      <style>
        {`
          .assetsGroupedTableScroll::-webkit-scrollbar {
            height: 0px;
            width: 0px;
          }
        `}
      </style>

      <Table
        size="small"
        stickyHeader
        style={{
          // âœ… removes right blank area: table fits to its columns
          width: "max-content",
          minWidth: "100%",

          backgroundColor: COLORS.TABLE_BG,
          borderCollapse: "separate",
          borderSpacing: 0,
          tableLayout: "fixed",
        }}
      >
        {/* Fixed widths so columns are predictable */}
        <colgroup>
          {visibleColumns.map((col) => (
            <col
              key={col.id}
              style={{
                width:
                  col.id === "thumbnail"
                    ? UI.THUMB_WIDTH
                    : col.id === "group_1_name"
                    ? UI.NAME_WIDTH
                    : col.id === "relation"
                    ? UI.RELATION_WIDTH
                    : UI.PHASE_COL_WIDTH,
              }}
            />
          ))}
        </colgroup>

        <TableHead>
          <TableRow style={{ height: UI.HEADER_HEIGHT_PX }}>
            {visibleColumns.map((col) => (
              <TableCell
                key={col.id}
                align={col.id === "group_1_name" ? "left" : "center"}
                onClick={() => col.sortable && onSortChange(col.id)}
                style={{
                  ...buildCellStyle(col, visibleColumns, { header: true }),
                  cursor: col.sortable ? "pointer" : "default",
                }}
              >
                <Box
                  display="flex"
                  alignItems="center"
                  justifyContent={col.id === "group_1_name" ? "flex-start" : "center"}
                >
                  <Typography noWrap style={{ fontSize: "0.65rem", fontWeight: 900 }}>
                    {col.label}
                  </Typography>
                  {sortKey === col.id &&
                    (sortDir === "asc" ? (
                      <ArrowDropUpIcon fontSize="small" />
                    ) : (
                      <ArrowDropDownIcon fontSize="small" />
                    ))}
                </Box>
              </TableCell>
            ))}
          </TableRow>
        </TableHead>

        <TableBody>
          {groups.map((group) => {
            const groupName = group.top_group_node || "UNASSIGNED";
            const isCollapsed = !!collapsed[groupName];

            return (
              <React.Fragment key={groupName}>
                {/* Group row */}
                <TableRow
                  onClick={() => toggle(groupName)}
                  style={{ backgroundColor: COLORS.TABLE_BG, cursor: "pointer", height: UI.GROUP_ROW_HEIGHT_PX }}
                >
                  <TableCell
                    colSpan={visibleColumns.length}
                    style={{
                      backgroundColor: COLORS.GROUP_BG,
                      color: COLORS.GROUP_TEXT,
                      borderBottom: `${UI.GROUP_ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,
                      padding: "6px 8px",
                      height: UI.GROUP_ROW_HEIGHT_PX,
                    }}
                  >
                    <Box display="flex" alignItems="center">
                      <IconButton size="small" style={{ color: COLORS.GROUP_TEXT, padding: 0 }}>
                        {isCollapsed ? (
                          <ChevronRightIcon fontSize="small" />
                        ) : (
                          <ExpandMoreIcon fontSize="small" />
                        )}
                      </IconButton>

                      <Typography
                        noWrap
                        style={{
                          color: COLORS.GROUP_TEXT,
                          fontSize: "0.8rem",
                          fontWeight: 800,
                          marginLeft: 10,
                        }}
                      >
                        {groupName.toUpperCase()}{" "}
                        <span style={{ fontSize: "0.75rem" }}>({group.items ? group.items.length : 0})</span>
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>

                {/* Data rows */}
                {!isCollapsed &&
                  (group.items || []).map((asset: any, idx: number) => (
                    <TableRow
                      key={`${groupName}-${idx}`}
                      hover
                      style={{
                        backgroundColor: COLORS.TABLE_BG,
                        height: UI.ROW_HEIGHT_PX,
                      }}
                    >
                      {visibleColumns.map((col) => (
                        <TableCell
                          key={col.id}
                          align={col.id === "group_1_name" ? "left" : "center"}
                          style={buildCellStyle(col, visibleColumns)}
                        >
                          {renderAssetField(asset, col)}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))}
              </React.Fragment>
            );
          })}
        </TableBody>
      </Table>
    </Box>
  );
};

export default AssetsGroupedDataTable;
