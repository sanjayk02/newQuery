import React, { useCallback, useMemo, useState } from "react";
import {
  Box,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  TablePagination,
  Typography,
  makeStyles,
} from "@material-ui/core";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import { PivotGroup, SortDir } from "./types";

/** ----------------------------------------------------------------
 *  COLORS (match list view look)
 *  ---------------------------------------------------------------- */
const COLORS = {
  PAGE_BG: "#3d3d3dff",
  TABLE_BG: "#3d3d3dff",
  HEADER_BG: "#3d3d3dff",
  HEADER_BORDER: "#3d3d3dff",
  GRID_LINE: "#555555",
  ROW_BG: "#3d3d3dff",
  GROUP_BG: "#3a3838ff",
  GROUP_TEXT: "#00b7ff",
  TEXT: "#e0e0e0",
  MUTED: "#bdbdbd",

  // top/bottom line color for NON phase columns
  COL_EDGE: "#6b6b6b",

  PHASE: {
    mdl: "#00b7ff",
    rig: "#a333c8",
    bld: "#e91e63",
    dsn: "#00a6a6",
    ldv: "#d14bff",
  },
};

/** ----------------------------------------------------------------
 *  UI controls
 *  ---------------------------------------------------------------- */
const UI = {
  ROW_HEIGHT: 50,
  ROW_PAD_Y: 2,
  ROW_PAD_X: 8,

  // move thumb/name a bit left
  THUMB_PAD_LEFT: 4,
  NAME_PAD_LEFT: 4,

  ROW_GAP_PX: 0,
  GROUP_ROW_GAP_PX: 2,
  PHASE_GAP_PX: 1,

  RAIL_PX: 3,

  THUMB_WIDTH: 90,
  NAME_WIDTH: 150,
  RELATION_WIDTH: 50,
  PHASE_COL_WIDTH: 97,

  // the “top & bottom line” thickness you marked
  COL_EDGE_PX: 2,

  // thumbnail size (YOU ASKED width/height)
  THUMB_BOX_W: 28,
  THUMB_BOX_H: 28,
  THUMB_RADIUS: 2,

  // pagination bar height (sticky row under header)
  PAGINATION_ROW_PAD_Y: 0,
};

type ColumnId =
  | "thumbnail"
  | "group_1_name"
  | "mdl_work"
  | "mdl_appr"
  | "mdl_submitted"
  | "rig_work"
  | "rig_appr"
  | "rig_submitted"
  | "bld_work"
  | "bld_appr"
  | "bld_submitted"
  | "dsn_work"
  | "dsn_appr"
  | "dsn_submitted"
  | "ldv_work"
  | "ldv_appr"
  | "ldv_submitted"
  | "relation";

type Column = {
  id: ColumnId;
  label: string;
  sortable?: boolean;
  phase?: keyof typeof COLORS.PHASE;
  kind?: "work" | "appr" | "submitted";
};

type Props = {
  groups?: PivotGroup[];
  sortKey: string;
  sortDir: SortDir;
  onSortChange: (key: string) => void;
  dateTimeFormat: Intl.DateTimeFormat;
  hiddenColumns?: Set<string>;
};

const COLUMNS: Column[] = [
  { id: "thumbnail", label: "THUMBNAIL" },
  { id: "group_1_name", label: "NAME", sortable: true },

  { id: "mdl_work", label: "MDL WORK", sortable: true, phase: "mdl", kind: "work" },
  { id: "mdl_appr", label: "MDL APPR", sortable: true, phase: "mdl", kind: "appr" },
  { id: "mdl_submitted", label: "MDL SUBMITTED AT", sortable: true, phase: "mdl", kind: "submitted" },

  { id: "rig_work", label: "RIG WORK", sortable: true, phase: "rig", kind: "work" },
  { id: "rig_appr", label: "RIG APPR", sortable: true, phase: "rig", kind: "appr" },
  { id: "rig_submitted", label: "RIG SUBMITTED AT", sortable: true, phase: "rig", kind: "submitted" },

  { id: "bld_work", label: "BLD WORK", sortable: true, phase: "bld", kind: "work" },
  { id: "bld_appr", label: "BLD APPR", sortable: true, phase: "bld", kind: "appr" },
  { id: "bld_submitted", label: "BLD SUBMITTED AT", sortable: true, phase: "bld", kind: "submitted" },

  { id: "dsn_work", label: "DSN WORK", sortable: true, phase: "dsn", kind: "work" },
  { id: "dsn_appr", label: "DSN APPR", sortable: true, phase: "dsn", kind: "appr" },
  { id: "dsn_submitted", label: "DSN SUBMITTED AT", sortable: true, phase: "dsn", kind: "submitted" },

  { id: "ldv_work", label: "LDV WORK", sortable: true, phase: "ldv", kind: "work" },
  { id: "ldv_appr", label: "LDV APPR", sortable: true, phase: "ldv", kind: "appr" },
  { id: "ldv_submitted", label: "LDV SUBMITTED AT", sortable: true, phase: "ldv", kind: "submitted" },

  { id: "relation", label: "RELATION", sortable: true },
];

/** -----------------------------
 * ONE scroll container only
 * ----------------------------- */
const useStyles = makeStyles(() => ({
  scrollWrap: {
    width: "100%",
    height: "100%", // important: let parent decide height; we scroll inside
    background: COLORS.PAGE_BG,
    overflow: "auto", // ✅ single scrollbar (both directions)
  },
}));

function hexToRgba(hex: string, a: number) {
  const h = hex.replace("#", "");
  const bigint = parseInt(h.length === 3 ? h.split("").map((c) => c + c).join("") : h, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

function getPhaseMetadata(visibleCols: Column[]) {
  const map: Record<string, { start: string; end: string }> = {};
  visibleCols.forEach((col) => {
    if (!col.phase) return;
    if (!map[col.phase]) map[col.phase] = { start: col.id, end: col.id };
    else map[col.phase].end = col.id;
  });
  return map;
}

function formatSubmitted(val: any) {
  if (!val || val === "-") return "-";
  const s = String(val);
  return s.indexOf("T") >= 0 ? s.split("T")[0] : s;
}

function statusColor(status?: string) {
  const s = (status || "").toLowerCase();
  if (!s || s === "-") return COLORS.MUTED;
  if (s.includes("approved")) return "#32cd32";
  if (s.includes("review")) return "#ffa500";
  if (s.includes("retake")) return "#ff4f4f";
  if (s.includes("hold")) return "#ffdd55";
  if (s === "check") return "#ca25ed";
  return COLORS.MUTED;
}

/** ✅ thumbnail renderer with width/height */
function renderThumbnail(asset: any) {
  const url = asset.thumbnail_url || asset.thumbnail;
  return (
    <Box display="flex" alignItems="center" justifyContent="flex-start" pl={0.5}>
      <Box
        style={{
          width: UI.THUMB_BOX_W,
          height: UI.THUMB_BOX_H,
          borderRadius: UI.THUMB_RADIUS,
          backgroundColor: "#2a2a2a",
          overflow: "hidden",
        }}
      >
        {url ? (
          <img
            src={url}
            alt=""
            style={{
              width: "100%",
              height: "100%",
              objectFit: "cover",
              display: "block",
            }}
          />
        ) : null}
      </Box>
    </Box>
  );
}

function renderAssetField(asset: any, col: Column) {
  if (col.id === "thumbnail") return renderThumbnail(asset);

  if (col.id === "group_1_name") {
    return (
      <Typography noWrap style={{ fontSize: 12, fontWeight: 500 }}>
        {asset.group_1 || ""}
      </Typography>
    );
  }

  if (col.id === "relation") {
    return (
      <Typography style={{ fontSize: 12, fontWeight: 500 }}>
        {asset.relation || "-"}
      </Typography>
    );
  }

  const phase = col.phase;
  if (!phase) return <span>-</span>;

  if (col.kind === "submitted") {
    return (
      <Typography style={{ fontSize: 12, fontWeight: 500 }}>
        {formatSubmitted(asset[phase + "_submitted_at_utc"])}
      </Typography>
    );
  }

  const field = col.kind === "work" ? "work_status" : "approval_status";
  const raw = asset[phase + "_" + field];
  const text = raw || "-";

  return (
    <Typography style={{ fontSize: 12, fontWeight: 500, color: statusColor(text) }}>
      {text}
    </Typography>
  );
}

/**
 * ✅ Cell style
 * - header has TOP+BOTTOM line per column
 * - phase rails only at start/end
 * - remove inner borders
 * - remove middle line between thumb and name
 * - move thumb/name slightly left
 */
function buildCellStyle(
  col: Column,
  phaseMeta: Record<string, { start: string; end: string }>,
  opts: { header?: boolean; isGroupRow?: boolean; isPaginationRow?: boolean } = {}
): React.CSSProperties {
  const { header = false, isGroupRow = false, isPaginationRow = false } = opts;

  const meta = col.phase ? phaseMeta[col.phase] : null;
  const railColor = col.phase ? COLORS.PHASE[col.phase] : "";

  const isPhaseStart = !!(meta && meta.start === col.id);
  const isPhaseEnd = !!(meta && meta.end === col.id);

  const headerBg = col.phase ? hexToRgba(railColor, 0.45) : COLORS.HEADER_BG;
  const edgeColor = col.phase ? railColor : COLORS.COL_EDGE;

  const padLeft =
    col.id === "thumbnail"
      ? UI.THUMB_PAD_LEFT
      : col.id === "group_1_name"
      ? UI.NAME_PAD_LEFT
      : UI.ROW_PAD_X;

  const style: React.CSSProperties = {
    backgroundColor: header ? headerBg : COLORS.ROW_BG,
    color: header ? "#fff" : COLORS.TEXT,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",

    height: isPaginationRow ? 44 : UI.ROW_HEIGHT,
    padding: isPaginationRow
      ? `${UI.PAGINATION_ROW_PAD_Y}px 8px`
      : `${header ? 8 : UI.ROW_PAD_Y}px ${UI.ROW_PAD_X}px`,
    paddingLeft: padLeft,

    fontSize: 12,
    fontWeight: header ? 700 : 500,

    borderLeft: "0px",
    borderRight: "0px",

    borderBottom: header
      ? "1px solid " + COLORS.HEADER_BORDER
      : (isGroupRow ? UI.GROUP_ROW_GAP_PX : UI.ROW_GAP_PX) + "px solid " + COLORS.TABLE_BG,
  };

  // ✅ TOP + BOTTOM line in HEADER for each column
  if (header) {
    style.boxShadow = [
      `inset 0 ${UI.COL_EDGE_PX}px 0 0 ${edgeColor}`,
      `inset 0 -${UI.COL_EDGE_PX}px 0 0 ${edgeColor}`,
    ].join(", ");
  }

  // PHASE rails (start/end only)
  if (col.phase) {
    const shadows: string[] = [];
    if (style.boxShadow) shadows.push(String(style.boxShadow));
    if (isPhaseStart) shadows.push(`inset ${UI.RAIL_PX}px 0 0 0 ${railColor}`);
    if (isPhaseEnd) shadows.push(`inset -${UI.RAIL_PX}px 0 0 0 ${railColor}`);
    style.boxShadow = shadows.join(", ");

    if (isPhaseEnd) {
      style.borderRight = UI.PHASE_GAP_PX + "px solid " + COLORS.TABLE_BG;
    }
  } else {
    // ✅ remove middle line between THUMBNAIL and NAME
    if (col.id === "thumbnail") style.borderRight = "0px";
    else style.borderRight = "1px solid " + (header ? COLORS.HEADER_BORDER : COLORS.GRID_LINE);
  }

  return style;
}

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  sortKey,
  sortDir,
  onSortChange,
  dateTimeFormat, // kept, not used here
  hiddenColumns = new Set(),
}) => {
  const classes = useStyles();

  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  // ✅ Pagination state (like your footer)
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(15);

  const toggle = useCallback((key: string) => {
    setCollapsed((prev) => ({ ...prev, [key]: !prev[key] }));
  }, []);

  const visibleColumns = useMemo(
    () => COLUMNS.filter((c) => !hiddenColumns.has(c.id)),
    [hiddenColumns]
  );

  const phaseMeta = useMemo(() => getPhaseMetadata(visibleColumns), [visibleColumns]);

  // ✅ total assets count
  const totalCount = useMemo(
    () => (groups || []).reduce((sum, g) => sum + (g.items?.length || 0), 0),
    [groups]
  );

  // ✅ flatten assets with group name
  const flat = useMemo(() => {
    const out: Array<{ groupName: string; asset: any }> = [];
    (groups || []).forEach((g) => {
      const groupName = g.top_group_node || "UNASSIGNED";
      (g.items || []).forEach((a) => out.push({ groupName, asset: a }));
    });
    return out;
  }, [groups]);

  // ✅ slice for current page
  const pageSlice = useMemo(() => {
    const start = page * rowsPerPage;
    const end = start + rowsPerPage;
    return flat.slice(start, end);
  }, [flat, page, rowsPerPage]);

  // ✅ rebuild groups for the page (preserve original order)
  const pagedGroups = useMemo(() => {
    const order = (groups || []).map((g) => g.top_group_node || "UNASSIGNED");
    const map = new Map<string, any[]>();

    pageSlice.forEach(({ groupName, asset }) => {
      if (!map.has(groupName)) map.set(groupName, []);
      map.get(groupName)!.push(asset);
    });

    return order
      .filter((name) => map.has(name))
      .map((name) => {
        const original = (groups || []).find((g) => (g.top_group_node || "UNASSIGNED") === name);
        return {
          top_group_node: name,
          items: map.get(name) || [],
          // keep full count for label if you want it
          __fullCount: original?.items?.length || 0,
        };
      });
  }, [groups, pageSlice]);

  const handleChangePage = useCallback((_e: any, newPage: number) => {
    setPage(newPage);
  }, []);

  const handleChangeRowsPerPage = useCallback((e: any) => {
    const val = parseInt(e.target.value, 10);
    setRowsPerPage(val);
    setPage(0);
  }, []);

  return (
    <Box className={classes.scrollWrap}>
      <Table
        size="small"
        stickyHeader
        style={{
          width: "max-content",
          minWidth: "100%",
          backgroundColor: COLORS.TABLE_BG,
          tableLayout: "fixed",
          borderCollapse: "separate",
          borderSpacing: 0,
        }}
      >
        <colgroup>
          {visibleColumns.map((col) => {
            let w = UI.PHASE_COL_WIDTH;
            if (col.id === "thumbnail") w = UI.THUMB_WIDTH;
            if (col.id === "group_1_name") w = UI.NAME_WIDTH;
            if (col.id === "relation") w = UI.RELATION_WIDTH;
            return <col key={col.id} style={{ width: w }} />;
          })}
        </colgroup>

        <TableHead>
          {/* HEADER ROW */}
          <TableRow>
            {visibleColumns.map((col) => (
              <TableCell
                key={col.id}
                align={col.id === "group_1_name" ? "left" : "center"}
                onClick={() => col.sortable && onSortChange(col.id)}
                style={{
                  ...buildCellStyle(col, phaseMeta, { header: true }),
                  cursor: col.sortable ? "pointer" : "default",
                }}
              >
                <Box
                  display="flex"
                  alignItems="center"
                  justifyContent={col.id === "group_1_name" ? "flex-start" : "center"}
                >
                  <Typography style={{ fontSize: "0.70rem", fontWeight: 900 }}>
                    {col.label}
                  </Typography>

                  {sortKey === col.id &&
                    (sortDir === "asc" ? (
                      <ArrowDropUpIcon fontSize="small" />
                    ) : (
                      <ArrowDropDownIcon fontSize="small" />
                    ))}
                </Box>
              </TableCell>
            ))}
          </TableRow>

          {/* ✅ STICKY “ROWS PER PAGE” ROW (UNDER HEADER) */}
          <TableRow>
            <TableCell
              colSpan={visibleColumns.length}
              style={{
                position: "sticky",
                top: UI.ROW_HEIGHT, // sits under the first sticky header row
                zIndex: 5,
                background: COLORS.HEADER_BG,
                borderBottom: "1px solid " + COLORS.GRID_LINE,
                padding: "0px 6px",
              }}
            >
              <Box display="flex" justifyContent="flex-end" alignItems="center">
                <TablePagination
                  component="div"
                  count={totalCount}
                  page={Math.min(page, Math.max(0, Math.ceil(totalCount / rowsPerPage) - 1))}
                  onChangePage={handleChangePage}
                  rowsPerPage={rowsPerPage}
                  onChangeRowsPerPage={handleChangeRowsPerPage}
                  rowsPerPageOptions={[15, 30, 60, 120, 240]}
                  style={{
                    color: COLORS.TEXT,
                    width: 520,
                  }}
                  labelRowsPerPage="Rows per page:"
                />
              </Box>
            </TableCell>
          </TableRow>
        </TableHead>

        <TableBody>
          {pagedGroups.map((group: any) => {
            const groupName = group.top_group_node || "UNASSIGNED";
            const isCollapsed = !!collapsed[groupName];

            return (
              <React.Fragment key={groupName}>
                {/* Group row */}
                <TableRow onClick={() => toggle(groupName)} style={{ cursor: "pointer" }}>
                  <TableCell
                    colSpan={visibleColumns.length}
                    style={{
                      backgroundColor: COLORS.GROUP_BG,
                      color: COLORS.GROUP_TEXT,
                      borderBottom: UI.GROUP_ROW_GAP_PX + "px solid " + COLORS.TABLE_BG,
                      padding: "6px 10px",
                      fontWeight: 900,
                    }}
                  >
                    <Box display="flex" alignItems="center">
                      <IconButton size="small" style={{ color: COLORS.GROUP_TEXT, padding: 0 }}>
                        {isCollapsed ? (
                          <ChevronRightIcon fontSize="small" />
                        ) : (
                          <ExpandMoreIcon fontSize="small" />
                        )}
                      </IconButton>

                      <Typography
                        style={{
                          color: COLORS.GROUP_TEXT,
                          fontSize: "0.80rem",
                          fontWeight: 900,
                          marginLeft: 10,
                        }}
                      >
                        {groupName.toUpperCase()}{" "}
                        <span style={{ fontSize: "0.75rem", fontWeight: 800 }}>
                          ({group.__fullCount ?? group.items.length ?? 0})
                        </span>
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>

                {/* Data rows */}
                {!isCollapsed &&
                  (group.items || []).map((asset: any, idx: number) => (
                    <TableRow key={groupName + "-" + idx} hover>
                      {visibleColumns.map((col) => (
                        <TableCell
                          key={col.id}
                          align={col.id === "group_1_name" ? "left" : "center"}
                          style={buildCellStyle(col, phaseMeta)}
                        >
                          {renderAssetField(asset, col)}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))}
              </React.Fragment>
            );
          })}
        </TableBody>
      </Table>
    </Box>
  );
};

export default AssetsGroupedDataTable;
