import React, { useMemo, useState, useCallback } from "react";
import {
  Avatar,
  Box,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Typography,
} from "@material-ui/core";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";

/** ----------------------------------------------------------------
 * COLOR COLLECTION
 * ---------------------------------------------------------------- */
const COLORS = {
  TABLE_BG: "#1e1e1e",
  HEADER_BG: "#2d2d2d",
  HEADER_BORDER: "#3d3d3d",
  GRID_LINE: "#2a2a2a",
  ROW_BG: "#2b2b2b",
  GROUP_BG: "#303030",
  GROUP_TEXT: "#00b7ff",
  TEXT: "#e0e0e0",
  MUTED: "#bdbdbd",

  PHASE: {
    mdl: "#00b7ff",
    rig: "#a333c8",
    bld: "#e91e63",
    dsn: "#00a6a6",
    ldv: "#d14bff",
  },
};

const UI = {
  // spacing between rows (the “gap” you wanted)
  ROW_GAP_PX: 10,
  GROUP_ROW_GAP_PX: 8,
  PHASE_GAP_PX: 14,
  RAIL_PX: 3,

  // row heights (this answers “what about rows height”)
  ROW_HEIGHT_PX: 30,
  GROUP_ROW_HEIGHT_PX: 30,

  // column widths
  THUMB_WIDTH: 65,
  NAME_WIDTH: 280,
  PHASE_COL_WIDTH: 110,
  RELATION_WIDTH: 80,
};

type PhaseKey = keyof typeof COLORS.PHASE;

type ColumnId =
  | "thumbnail"
  | "group_1_name"
  | "mdl_work"
  | "mdl_appr"
  | "mdl_submitted"
  | "rig_work"
  | "rig_appr"
  | "rig_submitted"
  | "bld_work"
  | "bld_appr"
  | "bld_submitted"
  | "dsn_work"
  | "dsn_appr"
  | "dsn_submitted"
  | "ldv_work"
  | "ldv_appr"
  | "ldv_submitted"
  | "relation";

type Column = {
  id: ColumnId;
  label: string;
  sortable?: boolean;
  phase?: PhaseKey;
  kind?: "work" | "appr" | "submitted";
};

const COLUMNS: Column[] = [
  { id: "thumbnail", label: "THUMBS" },
  { id: "group_1_name", label: "NAME", sortable: true },

  { id: "mdl_work", label: "MDL WORK", sortable: true, phase: "mdl", kind: "work" },
  { id: "mdl_appr", label: "MDL APPR", sortable: true, phase: "mdl", kind: "appr" },
  { id: "mdl_submitted", label: "MDL SUBMITTED AT", sortable: true, phase: "mdl", kind: "submitted" },

  { id: "rig_work", label: "RIG WORK", sortable: true, phase: "rig", kind: "work" },
  { id: "rig_appr", label: "RIG APPR", sortable: true, phase: "rig", kind: "appr" },
  { id: "rig_submitted", label: "RIG SUBMITTED AT", sortable: true, phase: "rig", kind: "submitted" },

  { id: "bld_work", label: "BLD WORK", sortable: true, phase: "bld", kind: "work" },
  { id: "bld_appr", label: "BLD APPR", sortable: true, phase: "bld", kind: "appr" },
  { id: "bld_submitted", label: "BLD SUBMITTED AT", sortable: true, phase: "bld", kind: "submitted" },

  { id: "dsn_work", label: "DSN WORK", sortable: true, phase: "dsn", kind: "work" },
  { id: "dsn_appr", label: "DSN APPR", sortable: true, phase: "dsn", kind: "appr" },
  { id: "dsn_submitted", label: "DSN SUBMITTED AT", sortable: true, phase: "dsn", kind: "submitted" },

  { id: "ldv_work", label: "LDV WORK", sortable: true, phase: "ldv", kind: "work" },
  { id: "ldv_appr", label: "LDV APPR", sortable: true, phase: "ldv", kind: "appr" },
  { id: "ldv_submitted", label: "LDV SUBMITTED AT", sortable: true, phase: "ldv", kind: "submitted" },

  { id: "relation", label: "RELATION", sortable: true },
];

/** Pre-calc phase boundaries */
function getPhaseMetadata(visibleCols: Column[]) {
  const map: Record<string, { start: string; end: string }> = {};
  visibleCols.forEach((col) => {
    if (col.phase) {
      if (!map[col.phase]) map[col.phase] = { start: col.id, end: col.id };
      else map[col.phase].end = col.id;
    }
  });
  return map;
}

function buildCellStyle(
  col: Column,
  phaseMeta: Record<string, { start: string; end: string }>,
  opts: { header?: boolean; isGroupRow?: boolean } = {}
): React.CSSProperties {
  const { header = false, isGroupRow = false } = opts;
  const railColor = col.phase ? COLORS.PHASE[col.phase] : "";
  const meta = col.phase ? phaseMeta[col.phase] : null;

  const style: React.CSSProperties = {
    backgroundColor: header ? COLORS.HEADER_BG : COLORS.ROW_BG,
    color: header ? "#fff" : COLORS.TEXT,
    whiteSpace: "nowrap",
    borderBottom: header
      ? `1px solid ${COLORS.HEADER_BORDER}`
      : `${isGroupRow ? UI.GROUP_ROW_GAP_PX : UI.ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,
    borderRight: `1px solid ${header ? COLORS.HEADER_BORDER : COLORS.GRID_LINE}`,
    padding: "0 8px", // important for row height consistency
    fontSize: header ? "0.65rem" : "0.75rem",
    overflow: "hidden",
    textOverflow: "ellipsis",
    height: header
      ? undefined
      : isGroupRow
      ? UI.GROUP_ROW_HEIGHT_PX
      : UI.ROW_HEIGHT_PX,
    lineHeight: header ? "24px" : `${UI.ROW_HEIGHT_PX}px`,
  };

  if (col.phase && meta) {
    if (header) style.borderTop = `${UI.RAIL_PX + 1}px solid ${railColor}`;

    const shadows: string[] = [];
    if (meta.start === col.id) shadows.push(`inset ${UI.RAIL_PX}px 0 0 0 ${railColor}`);
    if (meta.end === col.id) {
      shadows.push(`inset -${UI.RAIL_PX}px 0 0 0 ${railColor}`);
      style.borderRight = `${UI.PHASE_GAP_PX}px solid ${COLORS.TABLE_BG}`;
    }
    style.boxShadow = shadows.join(", ");
  }

  return style;
}

/** ----------------------------------------------------------------
 * DATA HELPERS (this answers “what about data”)
 *
 * Supports any of these shapes:
 * 1) asset.phases?.mdl?.work / appr / submitted
 * 2) asset.mdl_work, asset.mdl_appr, asset.mdl_submitted
 * 3) asset["mdl_work"] etc.
 * ---------------------------------------------------------------- */
function getAny(obj: any, path: (string | number)[]) {
  let cur = obj;
  for (const key of path) {
    if (cur == null) return undefined;
    cur = cur[key as any];
  }
  return cur;
}

function formatSubmitted(v: any) {
  if (!v) return "-";
  // if already string you like, keep it
  if (typeof v === "string") return v;
  // if timestamp/date
  try {
    const d = new Date(v);
    if (isNaN(d.getTime())) return String(v);
    return d.toLocaleString();
  } catch {
    return String(v);
  }
}

function renderPhaseValue(asset: any, phase: PhaseKey, kind: "work" | "appr" | "submitted") {
  // 1) nested
  const nested = getAny(asset, ["phases", phase, kind]);
  if (nested != null) return kind === "submitted" ? formatSubmitted(nested) : String(nested);

  // 2) flat keys
  const flatKey = `${phase}_${kind}`;
  const flat = asset?.[flatKey];
  if (flat != null) return kind === "submitted" ? formatSubmitted(flat) : String(flat);

  // 3) fallbacks (some systems use camel or different)
  const alt = getAny(asset, [phase, kind]);
  if (alt != null) return kind === "submitted" ? formatSubmitted(alt) : String(alt);

  return "-";
}

function renderAssetField(asset: any, col: Column) {
  switch (col.id) {
    case "thumbnail": {
      const src =
        asset?.thumbnailUrl ||
        asset?.thumbUrl ||
        asset?.thumbnail ||
        asset?.thumb ||
        "";
      return (
        <Box display="flex" justifyContent="center" alignItems="center">
          <Avatar
            variant="rounded"
            src={src}
            style={{ width: 44, height: 24, backgroundColor: "#444" }}
          />
        </Box>
      );
    }

    case "group_1_name":
      return (
        <Typography noWrap style={{ fontSize: "0.8rem", fontWeight: 700 }}>
          {asset?.group_1 || asset?.name || asset?.asset_name || "-"}
        </Typography>
      );

    case "relation":
      return (
        <Typography noWrap style={{ fontSize: "0.75rem", color: COLORS.MUTED }}>
          {asset?.relation || asset?.rel || "-"}
        </Typography>
      );

    default: {
      if (col.phase && col.kind) {
        const v = renderPhaseValue(asset, col.phase, col.kind);
        return (
          <Typography noWrap style={{ fontSize: "0.75rem", color: COLORS.TEXT }}>
            {v}
          </Typography>
        );
      }
      return <span>-</span>;
    }
  }
}

type Props = {
  groups: any[];
  sortKey?: ColumnId;
  sortDir?: "asc" | "desc";
  onSortChange?: (colId: ColumnId) => void;
  hiddenColumns?: Set<ColumnId>;
};

const AssetsGroupedDataTable: React.FC<Props> = ({
  groups = [],
  sortKey,
  sortDir,
  onSortChange,
  hiddenColumns = new Set(),
}) => {
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});

  const visibleColumns = useMemo(
    () => COLUMNS.filter((c) => !hiddenColumns.has(c.id)),
    [hiddenColumns]
  );

  const phaseMeta = useMemo(() => getPhaseMetadata(visibleColumns), [visibleColumns]);

  const toggle = useCallback(
    (key: string) => setCollapsed((prev) => ({ ...prev, [key]: !prev[key] })),
    []
  );

  return (
    <Box
      width="100%"
      style={{
        backgroundColor: COLORS.TABLE_BG,

        /**
         * ✅ REMOVE THE VISIBLE SCROLLBAR (bottom bar)
         * Keep scrolling ability, but hide the bar.
         */
        overflowX: "auto",
        overflowY: "hidden",
        scrollbarWidth: "none", // Firefox
        msOverflowStyle: "none", // IE/Edge legacy
      }}
      // Webkit scrollbar hide
      // @ts-ignore
      sx={{
        "&::-webkit-scrollbar": { display: "none" },
      }}
    >
      <Table
        size="small"
        stickyHeader
        style={{
          width: "100%",
          tableLayout: "fixed",
          backgroundColor: COLORS.TABLE_BG,
          borderCollapse: "separate",
          borderSpacing: 0,
        }}
      >
        <colgroup>
          {visibleColumns.map((col) => (
            <col
              key={col.id}
              style={{
                width:
                  col.id === "thumbnail"
                    ? UI.THUMB_WIDTH
                    : col.id === "group_1_name"
                    ? UI.NAME_WIDTH
                    : col.id === "relation"
                    ? UI.RELATION_WIDTH
                    : UI.PHASE_COL_WIDTH,
              }}
            />
          ))}
        </colgroup>

        <TableHead>
          <TableRow>
            {visibleColumns.map((col) => (
              <TableCell
                key={col.id}
                align={col.id === "group_1_name" ? "left" : "center"}
                onClick={() => col.sortable && onSortChange?.(col.id)}
                style={{
                  ...buildCellStyle(col, phaseMeta, { header: true }),
                  cursor: col.sortable ? "pointer" : "default",
                  padding: "0 8px",
                  height: 28,
                }}
              >
                <Box
                  display="flex"
                  alignItems="center"
                  justifyContent={col.id === "group_1_name" ? "flex-start" : "center"}
                >
                  <Typography style={{ fontSize: "0.65rem", fontWeight: 900 }} noWrap>
                    {col.label}
                  </Typography>
                  {sortKey === col.id &&
                    (sortDir === "asc" ? <ArrowDropUpIcon /> : <ArrowDropDownIcon />)}
                </Box>
              </TableCell>
            ))}
          </TableRow>
        </TableHead>

        <TableBody>
          {groups.map((group: any) => {
            const groupName = group.top_group_node || "UNASSIGNED";
            const isCollapsed = !!collapsed[groupName];

            return (
              <React.Fragment key={groupName}>
                {/* GROUP HEADER ROW */}
                <TableRow
                  onClick={() => toggle(groupName)}
                  style={{
                    cursor: "pointer",
                    height: UI.GROUP_ROW_HEIGHT_PX,
                  }}
                >
                  <TableCell
                    colSpan={visibleColumns.length}
                    style={{
                      backgroundColor: COLORS.GROUP_BG,
                      color: COLORS.GROUP_TEXT,
                      borderBottom: `${UI.GROUP_ROW_GAP_PX}px solid ${COLORS.TABLE_BG}`,
                      padding: "0 8px",
                      height: UI.GROUP_ROW_HEIGHT_PX,
                    }}
                  >
                    <Box display="flex" alignItems="center" height={UI.GROUP_ROW_HEIGHT_PX}>
                      {isCollapsed ? (
                        <ChevronRightIcon fontSize="small" />
                      ) : (
                        <ExpandMoreIcon fontSize="small" />
                      )}
                      <Typography
                        style={{
                          color: COLORS.GROUP_TEXT,
                          fontSize: "0.8rem",
                          fontWeight: 800,
                          marginLeft: 8,
                        }}
                        noWrap
                      >
                        {groupName.toUpperCase()} ({group.items?.length || 0})
                      </Typography>
                    </Box>
                  </TableCell>
                </TableRow>

                {/* DATA ROWS */}
                {!isCollapsed &&
                  (group.items || []).map((asset: any, idx: number) => (
                    <TableRow
                      key={`${groupName}-${idx}`}
                      style={{
                        height: UI.ROW_HEIGHT_PX,
                      }}
                    >
                      {visibleColumns.map((col) => (
                        <TableCell
                          key={col.id}
                          align={col.id === "group_1_name" ? "left" : "center"}
                          style={buildCellStyle(col, phaseMeta)}
                        >
                          {renderAssetField(asset, col)}
                        </TableCell>
                      ))}
                    </TableRow>
                  ))}
              </React.Fragment>
            );
          })}
        </TableBody>
      </Table>
    </Box>
  );
};

export default AssetsGroupedDataTable;
