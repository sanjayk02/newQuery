type GroupCategoryRow struct {
	Path         string `gorm:"column:path"`
	TopGroupNode string `gorm:"column:top_group_node"`
}


func (r *ReviewInfo) loadCategories(
	ctx context.Context,
	project string,
	root string,
) ([]GroupCategoryRow, error) {

	var rows []GroupCategoryRow

	err := r.db.WithContext(ctx).
		Table("t_group_category").
		Select(`
			path,
			SUBSTRING_INDEX(path, '/', 1) AS top_group_node
		`).
		Where(
			"project = ? AND root = ? AND deleted = 0",
			project,
			root,
		).
		-- IMPORTANT: longest path first (deepest match wins)
		Order("LENGTH(path) DESC").
		Scan(&rows).Error

	if err != nil {
		return nil, err
	}

	return rows, nil
}


func applyCategoriesToAssets(
	assets []AssetPivot,
	categories []GroupCategoryRow,
) {
	for i := range assets {
		leaf := strings.TrimSpace(assets[i].LeafGroupName)
		if leaf == "" {
			continue
		}

		suffix := "/" + leaf

		for _, cat := range categories {
			if strings.HasSuffix(cat.Path, suffix) {
				assets[i].GroupCategoryPath = cat.Path
				assets[i].TopGroupNode = cat.TopGroupNode
				break
			}
		}
	}
}


func (r *ReviewInfo) ListAssetsPivotWithOptions(
	ctx context.Context,
	opts ListAssetsPivotOptions,
) ([]AssetPivot, int64, error) {

	// ---- existing validation & defaults ----
	if opts.Project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if opts.Root == "" {
		opts.Root = "assets"
	}
	if opts.Limit <= 0 {
		opts.Limit = 60
	}
	if opts.Offset < 0 {
		opts.Offset = 0
	}

	// ---- build WHERE / ORDER ----
	whereSQL, args, err := r.buildWhereClause(opts)
	if err != nil {
		return nil, 0, err
	}

	orderSQL, err := buildOrderClause(opts.OrderKey, opts.Direction)
	if err != nil {
		return nil, 0, err
	}

	sql := r.buildSQLQuery(whereSQL, orderSQL)
	args = append(args, opts.Offset, opts.Offset+opts.Limit)

	// ---- execute query ----
	var rows []struct {
		AssetPivot
		Total int64 `gorm:"column:total_count"`
	}

	if err := r.db.WithContext(ctx).
		Raw(sql, args...).
		Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	if len(rows) == 0 {
		return []AssetPivot{}, 0, nil
	}

	assets := make([]AssetPivot, len(rows))
	for i := range rows {
		assets[i] = rows[i].AssetPivot
	}

	total := rows[0].Total

	// ======================================================
	// ðŸ”¥ CATEGORY RESOLUTION (NEW LOGIC)
	// ======================================================
	categories, err := r.loadCategories(ctx, opts.Project, opts.Root)
	if err != nil {
		return nil, 0, err
	}

	applyCategoriesToAssets(assets, categories)
	// ======================================================

	return assets, total, nil
}


router.GET("/api/projects/:project/reviews/assets/pivot2", func(c *gin.Context) {

	project := strings.TrimSpace(c.Param("project"))
	if project == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "project is required"})
		return
	}

	root := c.DefaultQuery("root", "assets")

	ctx, cancel := context.WithTimeout(c.Request.Context(), 7*time.Second)
	defer cancel()

	assets, total, err := reviewInfoRepository.ListAssetsPivot(
		ctx,
		project,
		root,
		"none",
		"group1_only",
		"ASC",
		1000,
		0,
		"",
		nil,
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"total":  total,
		"assets": assets,
	})
})
