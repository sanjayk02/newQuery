func (r *ReviewInfo) loadCategories(ctx context.Context, project string) ([]CategoryInfo, error) {
	rows := []struct {
		Path string `gorm:"column:path"`
	}{}

	err := r.db.WithContext(ctx).
		Table("t_group_category").
		Select("path").
		Where("project = ? AND root = 'assets' AND deleted = 0", project).
		Scan(&rows).Error
	if err != nil {
		return nil, err
	}

	out := make([]CategoryInfo, 0, len(rows))
	for _, r := range rows {
		top := r.Path
		if i := strings.Index(top, "/"); i > 0 {
			top = top[:i]
		}
		out = append(out, CategoryInfo{
			Path:         r.Path,
			TopGroupNode: top,
		})
	}
	return out, nil
}


// suffix => CategoryInfo
func buildCategoryIndex(categories []CategoryInfo) map[string]CategoryInfo {
	index := make(map[string]CategoryInfo, len(categories))
	for _, c := range categories {
		// last segment of path
		leaf := c.Path[strings.LastIndex(c.Path, "/")+1:]
		index[leaf] = c
	}
	return index
}


func applyCategories(
	assets []AssetPivot,
	catIndex map[string]CategoryInfo,
) {
	for i := range assets {
		leaf := assets[i].LeafGroupName
		if leaf == "" {
			continue
		}
		if cat, ok := catIndex[leaf]; ok {
			assets[i].GroupCategoryPath = cat.Path
			assets[i].TopGroupNode = cat.TopGroupNode
		}
	}
}


assets, total, err := reviewInfoRepository.ListAssetsPivot2(...)
if err != nil {
    ...
}

cats, err := reviewInfoRepository.loadCategories(ctx, project)
if err != nil {
    ...
}

catIndex := buildCategoryIndex(cats)
applyCategories(assets, catIndex)
