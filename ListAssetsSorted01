package repository

import (
	"context"
	"fmt"
	"strings"

	"gorm.io/gorm"
)

// Simple model: just the asset keys
type AssetKeyRow struct {
	Project  string `json:"project"  gorm:"column:project"`
	Root     string `json:"root"     gorm:"column:root"`
	Group1   string `json:"group_1"  gorm:"column:group_1"`
	Relation string `json:"relation" gorm:"column:relation"`
}

// Repository type
type ReviewInfo struct{}

// ========================================================================
// ListAssetsSorted
// ========================================================================
func (r *ReviewInfo) ListAssetsSorted(
	ctx context.Context,
	db *gorm.DB,
	project string,
	limit, offset int,
	sort string,
) ([]AssetKeyRow, error) {
	mode, phase, field, dir := parseSortForAssets(sort)

	const q = `
WITH ordered AS (
  SELECT
    b.*,
    ROW_NUMBER() OVER (ORDER BY b.group_1 ASC) AS _order
  FROM (
    SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
    GROUP BY project, root, group_1, relation, phase
  ) a
  LEFT JOIN (
    SELECT root, project, group_1, phase, relation,
           work_status, approval_status, submitted_at_utc, modified_at_utc
    FROM t_review_info
    WHERE project = ? AND root = 'assets' AND deleted = 0
  ) b
    ON a.project=b.project AND a.root=b.root AND a.group_1=b.group_1
   AND a.relation=b.relation AND a.phase=b.phase AND a.modified_at_utc=b.modified_at_utc
),
offset_ordered AS (
  SELECT c.*,
         CASE WHEN c.phase = '' THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = '' THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
),
phase_latest AS (
  SELECT o.project, o.root, o.group_1, o.relation,
         o.work_status, o.approval_status, o.submitted_at_utc, o.modified_at_utc
  FROM ordered o
  WHERE o.phase = ?
),
winner AS (
  SELECT r.root, r.project, r.group_1, r.relation, r.__order
  FROM ranked r
  WHERE r._rank = 1
)
SELECT w.project, w.root, w.group_1, w.relation
FROM winner w
LEFT JOIN phase_latest pl
  ON pl.project=w.project AND pl.root=w.root AND pl.group_1=w.group_1 AND pl.relation=w.relation
ORDER BY
  -- base order always first
  w.__order ASC,

  -- base sort
  CASE WHEN ?='base' AND ?='group_1' THEN w.group_1 END ASC,
  CASE WHEN ?='base' AND ?='relation' THEN w.relation END ASC,

  -- phase sort (NULLS LAST)
  CASE WHEN ?='phase' AND ?='work'         THEN (pl.work_status IS NULL) END ASC,
  CASE WHEN ?='phase' AND ?='appr'         THEN (pl.approval_status IS NULL) END ASC,
  CASE WHEN ?='phase' AND ?='submitted_at' THEN (pl.submitted_at_utc IS NULL) END ASC,
  CASE WHEN ?='phase' AND ?='modified_at'  THEN (pl.modified_at_utc IS NULL) END ASC,

  -- ASC mode
  CASE WHEN ?='phase' AND ?='work'         THEN pl.work_status END ASC,
  CASE WHEN ?='phase' AND ?='appr'         THEN pl.approval_status END ASC,
  CASE WHEN ?='phase' AND ?='submitted_at' THEN pl.submitted_at_utc END ASC,
  CASE WHEN ?='phase' AND ?='modified_at'  THEN pl.modified_at_utc END ASC,

  -- DESC mode
  CASE WHEN ?='phase' AND ?='desc' AND ?='work'         THEN pl.work_status END DESC,
  CASE WHEN ?='phase' AND ?='desc' AND ?='appr'         THEN pl.approval_status END DESC,
  CASE WHEN ?='phase' AND ?='desc' AND ?='submitted_at' THEN pl.submitted_at_utc END DESC,
  CASE WHEN ?='phase' AND ?='desc' AND ?='modified_at'  THEN pl.modified_at_utc END DESC,

  w.group_1 ASC
LIMIT ? OFFSET ?;`

	args := []any{
		project, project, // two project filters
		phase,            // phase filter
		// base
		mode, "group_1",
		mode, "relation",
		// phase NULLs
		mode, "work", mode, "appr", mode, "submitted_at", mode, "modified_at",
		// phase ASC
		mode, "work", mode, "appr", mode, "submitted_at", mode, "modified_at",
		// phase DESC
		mode, dir, field,
		mode, dir, field,
		mode, dir, field,
		mode, dir, field,
		limit, offset,
	}

	var out []AssetKeyRow
	if err := db.WithContext(ctx).Raw(q, args...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}

// ============================================================
// Helper: Parse Sort String
// ============================================================
func parseSortForAssets(sort string) (mode, phase, field, dir string) {
	mode, phase, field, dir = "base", "", "group_1", "asc"
	s := strings.TrimSpace(strings.ToLower(sort))
	if s == "" {
		return
	}

	// Phase mode: mdl:submitted_at:desc
	if strings.Contains(s, ":") {
		parts := strings.Split(s, ":")
		if len(parts) >= 3 {
			phase, field, dir = parts[0], parts[1], parts[2]
		}
		if _, ok := map[string]bool{"mdl": true, "rig": true, "bld": true, "dsn": true, "ldv": true}[phase]; !ok {
			phase = "mdl"
		}
		if _, ok := map[string]bool{"work": true, "appr": true, "submitted_at": true, "modified_at": true}[field]; !ok {
			field = "submitted_at"
		}
		if dir != "desc" {
			dir = "asc"
		}
		return "phase", phase, field, dir
	}

	// Base mode: "group_1 desc" or "relation asc"
	dir = "asc"
	if strings.HasSuffix(s, " desc") {
		s = strings.TrimSuffix(s, " desc")
		dir = "desc"
	} else if strings.HasSuffix(s, " asc") {
		s = strings.TrimSuffix(s, " asc")
	}

	f := strings.TrimSpace(s)
	if _, ok := map[string]bool{"group_1": true, "relation": true}[f]; ok {
		field = f
	}
	return "base", "", field, dir
}
