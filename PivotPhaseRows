package reviewinfo  //GET /api/assets/:project/pivot?root=assets&sort=group_1&phase=mdl&dir=asc&page=1&per_page=15


import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"gorm.io/gorm"
)

/* =========================
   Data Models
   ========================= */

type AssetKey struct {
	Root     string `json:"root"     gorm:"column:root"`
	Project  string `json:"project"  gorm:"column:project"`
	Group1   string `json:"group_1"  gorm:"column:group_1"`
	Relation string `json:"relation" gorm:"column:relation"`
}

type PhaseRow struct {
	Root             string     `gorm:"column:root"`
	Project          string     `gorm:"column:project"`
	Group1          string     `gorm:"column:group_1"`
	Relation         string     `gorm:"column:relation"`
	Phase            string     `gorm:"column:phase"`
	WorkStatus       *string    `gorm:"column:work_status"`
	ApprovalStatus   *string    `gorm:"column:approval_status"`
	SubmittedAtUTC   *time.Time `gorm:"column:submitted_at_utc"`
	ModifiedAtUTC    *time.Time `gorm:"column:modified_at_utc"`
	ExecutedComputer *string    `gorm:"column:executed_computer"`
}

type AssetPhaseSummary struct {
	Root     string `json:"root"`
	Project  string `json:"project"`
	Group1   string `json:"group_1"`
	Relation string `json:"relation"`

	MdlWorkStatus     *string    `json:"mdl_work_status"`
	MdlApprovalStatus *string    `json:"mdl_approval_status"`
	MdlSubmittedAtUTC *time.Time `json:"mdl_submitted_at_utc"`

	RigWorkStatus     *string    `json:"rig_work_status"`
	RigApprovalStatus *string    `json:"rig_approval_status"`
	RigSubmittedAtUTC *time.Time `json:"rig_submitted_at_utc"`

	BldWorkStatus     *string    `json:"bld_work_status"`
	BldApprovalStatus *string    `json:"bld_approval_status"`
	BldSubmittedAtUTC *time.Time `json:"bld_submitted_at_utc"`

	DsnWorkStatus     *string    `json:"dsn_work_status"`
	DsnApprovalStatus *string    `json:"dsn_approval_status"`
	DsnSubmittedAtUTC *time.Time `json:"dsn_submitted_at_utc"`

	LdvWorkStatus     *string    `json:"ldv_work_status"`
	LdvApprovalStatus *string    `json:"ldv_approval_status"`
	LdvSubmittedAtUTC *time.Time `json:"ldv_submitted_at_utc"`

	// internal helper for boosting (not serialized)
	HasPhase map[string]bool `json:"-"`
}

/* =========================
   Repository
   ========================= */

type ReviewInfoRepository struct{}

/* ---------- First query: ordered keys + total ---------- */

func (r *ReviewInfoRepository) ListOrderedAssets(
	ctx context.Context,
	db *gorm.DB,
	project, root, sortField, sortDir string,
	limit, offset int,
) (keys []AssetKey, total int64, err error) {

	// whitelist sort columns (keys stage)
	cols := map[string]string{
		"group_1": "group_1",
		"relation": "relation",
		"project":  "project",
		"root":     "root",
	}
	col := cols["group_1"]
	if v, ok := cols[strings.ToLower(sortField)]; ok {
		col = v
	}
	dir := "ASC"
	if strings.EqualFold(sortDir, "DESC") {
		dir = "DESC"
	}

	// total distinct assets
	countSQL := `
SELECT COUNT(*) FROM (
  SELECT project, root, group_1, relation
  FROM t_review_info
  WHERE project = ? AND root = ? AND deleted = 0
  GROUP BY project, root, group_1, relation
) x;
`
	if err = db.WithContext(ctx).Raw(countSQL, project, root).Scan(&total).Error; err != nil {
		return nil, 0, err
	}

	// paged ordered keys
	orderedSQL := fmt.Sprintf(`
WITH keys AS (
  SELECT
    t.project  AS project,
    t.root     AS root,
    t.group_1  AS group_1,
    t.relation AS relation
  FROM t_review_info t
  WHERE t.project = ? AND t.root = ? AND t.deleted = 0
  GROUP BY t.project, t.root, t.group_1, t.relation
)
SELECT project, root, group_1, relation
FROM keys
ORDER BY %s %s
LIMIT ? OFFSET ?;
`, col, dir)

	if err = db.WithContext(ctx).Raw(orderedSQL, project, root, limit, offset).Scan(&keys).Error; err != nil {
		return nil, 0, err
	}
	return keys, total, nil
}

/* ---------- Second query: latest per-phase for those keys (preserve order) ---------- */

func (r *ReviewInfoRepository) LatestPerPhaseForAssets(
	ctx context.Context,
	db *gorm.DB,
	keys []AssetKey,
) ([]PhaseRow, error) {

	if len(keys) == 0 {
		return []PhaseRow{}, nil
	}

	parts := make([]string, 0, len(keys))
	params := make([]interface{}, 0, len(keys)*5)

	for i, k := range keys {
		if i == 0 {
			parts = append(parts, "SELECT ? AS root, ? AS project, ? AS group_1, ? AS relation, ? AS seq")
		} else {
			parts = append(parts, "UNION ALL SELECT ?,?,?,?,?")
		}
		params = append(params, k.Root, k.Project, k.Group1, k.Relation, i+1) // seq
	}
	sel := strings.Join(parts, "\n")

	sql := fmt.Sprintf(`
WITH sel(root, project, group_1, relation, seq) AS (
  %s
),
max_modified AS (
  SELECT
    b.project, b.root, b.group_1, b.relation, b.phase,
    MAX(b.modified_at_utc) AS modified_at_utc,
    MIN(sel.seq)           AS seq
  FROM t_review_info b
  JOIN sel
    ON  sel.project  = b.project
    AND sel.root     = b.root
    AND sel.group_1  = b.group_1
    AND sel.relation = b.relation
  WHERE b.deleted = 0
  GROUP BY b.project, b.root, b.group_1, b.relation, b.phase
)
SELECT
  b.root, b.project, b.group_1, b.relation, b.phase,
  b.work_status, b.approval_status, b.submitted_at_utc, b.modified_at_utc, b.executed_computer
FROM max_modified a
JOIN t_review_info b
  ON  a.project         = b.project
  AND a.root            = b.root
  AND a.group_1         = b.group_1
  AND a.relation        = b.relation
  AND a.phase           = b.phase
  AND a.modified_at_utc = b.modified_at_utc
ORDER BY a.seq ASC, b.group_1 ASC, b.relation ASC;
`, sel)

	var out []PhaseRow
	if err := db.WithContext(ctx).Raw(sql, params...).Scan(&out).Error; err != nil {
		return nil, err
	}
	return out, nil
}

/* ---------- Pivot + Phase prefer + Pivot sorting ---------- */

func PivotPhaseRows(rows []PhaseRow, inputOrder []AssetKey) []AssetPhaseSummary {
	m := make(map[string]*AssetPhaseSummary, len(rows))
	key := func(root, project, g1, rel string) string {
		return root + "|" + project + "|" + g1 + "|" + rel
	}

	for _, r := range rows {
		id := key(r.Root, r.Project, r.Group1, r.Relation)
		dst := m[id]
		if dst == nil {
			dst = &AssetPhaseSummary{
				Root:     r.Root,
				Project:  r.Project,
				Group1:   r.Group1,
				Relation: r.Relation,
				HasPhase: map[string]bool{},
			}
			m[id] = dst
		}
		dst.HasPhase[strings.ToLower(r.Phase)] = true

		switch strings.ToLower(r.Phase) {
		case "mdl":
			dst.MdlWorkStatus, dst.MdlApprovalStatus, dst.MdlSubmittedAtUTC = r.WorkStatus, r.ApprovalStatus, r.SubmittedAtUTC
		case "rig":
			dst.RigWorkStatus, dst.RigApprovalStatus, dst.RigSubmittedAtUTC = r.WorkStatus, r.ApprovalStatus, r.SubmittedAtUTC
		case "bld":
			dst.BldWorkStatus, dst.BldApprovalStatus, dst.BldSubmittedAtUTC = r.WorkStatus, r.ApprovalStatus, r.SubmittedAtUTC
		case "dsn":
			dst.DsnWorkStatus, dst.DsnApprovalStatus, dst.DsnSubmittedAtUTC = r.WorkStatus, r.ApprovalStatus, r.SubmittedAtUTC
		case "ldv":
			dst.LdvWorkStatus, dst.LdvApprovalStatus, dst.LdvSubmittedAtUTC = r.WorkStatus, r.ApprovalStatus, r.SubmittedAtUTC
		}
	}

	// Emit in the same order as keys
	out := make([]AssetPhaseSummary, 0, len(inputOrder))
	for _, k := range inputOrder {
		id := key(k.Root, k.Project, k.Group1, k.Relation)
		if row, ok := m[id]; ok {
			out = append(out, *row)
		} else {
			out = append(out, AssetPhaseSummary{
				Root:     k.Root, Project: k.Project, Group1: k.Group1, Relation: k.Relation,
				HasPhase: map[string]bool{},
			})
		}
	}
	return out
}

/* ---------- Phase prefer booster + pivot sorting helpers ---------- */

func parsePhaseCSV(s string) []string {
	if s == "" {
		return nil
	}
	var out []string
	for _, p := range strings.Split(s, ",") {
		p = strings.ToLower(strings.TrimSpace(p))
		if p != "" {
			out = append(out, p)
		}
	}
	return out
}

func hasAnyPreferred(phases []string, asset AssetPhaseSummary) bool {
	for _, p := range phases {
		if asset.HasPhase[p] {
			return true
		}
	}
	return false
}

func stringComparePtr(a, b *string) bool {
	if a == nil && b == nil {
		return false
	}
	if a == nil {
		return false
	}
	if b == nil {
		return true
	}
	return *a < *b
}

func timeComparePtr(a, b *time.Time) bool {
	if a == nil && b == nil {
		return false
	}
	if a == nil {
		return false
	}
	if b == nil {
		return true
	}
	return a.Before(*b)
}

var pivotSortableColumns = map[string]func(a, b *AssetPhaseSummary) bool{
	"group_1": func(a, b *AssetPhaseSummary) bool { return a.Group1 < b.Group1 },
	"relation": func(a, b *AssetPhaseSummary) bool { return a.Relation < b.Relation },

	"mdl_work":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.MdlWorkStatus, a.MdlWorkStatus) },
	"mdl_appr":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.MdlApprovalStatus, b.MdlApprovalStatus) },
	"mdl_submitted": func(a, b *AssetPhaseSummary) bool { return timeComparePtr(a.MdlSubmittedAtUTC, b.MdlSubmittedAtUTC) },

	"rig_work":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.RigWorkStatus, b.RigWorkStatus) },
	"rig_appr":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.RigApprovalStatus, b.RigApprovalStatus) },
	"rig_submitted": func(a, b *AssetPhaseSummary) bool { return timeComparePtr(a.RigSubmittedAtUTC, b.RigSubmittedAtUTC) },

	"bld_work":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.BldWorkStatus, b.BldWorkStatus) },
	"bld_appr":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.BldApprovalStatus, b.BldApprovalStatus) },
	"bld_submitted": func(a, b *AssetPhaseSummary) bool { return timeComparePtr(a.BldSubmittedAtUTC, b.BldSubmittedAtUTC) },

	"dsn_work":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.DsnWorkStatus, b.DsnWorkStatus) },
	"dsn_appr":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.DsnApprovalStatus, b.DsnApprovalStatus) },
	"dsn_submitted": func(a, b *AssetPhaseSummary) bool { return timeComparePtr(a.DsnSubmittedAtUTC, b.DsnSubmittedAtUTC) },

	"ldv_work":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.LdvWorkStatus, b.LdvWorkStatus) },
	"ldv_appr":      func(a, b *AssetPhaseSummary) bool { return stringComparePtr(a.LdvApprovalStatus, b.LdvApprovalStatus) },
	"ldv_submitted": func(a, b *AssetPhaseSummary) bool { return timeComparePtr(a.LdvSubmittedAtUTC, b.LdvSubmittedAtUTC) },
}

func SortPivot(data []AssetPhaseSummary, sortKey string) {
	if sortKey == "" {
		return
	}
	asc := !strings.HasPrefix(sortKey, "-")
	field := strings.TrimPrefix(sortKey, "-")
	cmp, ok := pivotSortableColumns[field]
	if !ok {
		return
	}
	sort.SliceStable(data, func(i, j int) bool {
		if asc {
			return cmp(&data[i], &data[j])
		}
		return cmp(&data[j], &data[i])
	})
}

/* ---------- Orchestrator: first -> second -> pivot -> boost -> sort ---------- */

func (r *ReviewInfoRepository) GetAssetsPivotPage(
	ctx context.Context,
	db *gorm.DB,
	project string,
	root string,
	sort string, // e.g., "group_1", "-mdl_submitted"
	phaseCSV string, // prefer-phase booster (e.g., "mdl,rig")
	page, perPage int,
) (rows []AssetPhaseSummary, total int64, err error) {

	if page <= 0 {
		page = 1
	}
	if perPage <= 0 {
		perPage = 15
	}
	offset := perPage * (page - 1)

	// 1) keys + total
	keys, total, err := r.ListOrderedAssets(ctx, db, project, root, "group_1", "ASC", perPage, offset)
	if err != nil {
		return nil, 0, err
	}
	if len(keys) == 0 {
		return []AssetPhaseSummary{}, total, nil
	}

	// 2) latest per phase for keys
	phaseRows, err := r.LatestPerPhaseForAssets(ctx, db, keys)
	if err != nil {
		return nil, 0, err
	}

	// 3) pivot
	rows = PivotPhaseRows(phaseRows, keys)

	// 4) prefer-phase boost (within the page)
	if phases := parsePhaseCSV(phaseCSV); len(phases) > 0 {
		sort.SliceStable(rows, func(i, j int) bool {
			ai := hasAnyPreferred(phases, rows[i])
			aj := hasAnyPreferred(phases, rows[j])
			if ai != aj {
				return ai && !aj // preferred first
			}
			// fallback to group_1 ASC inside the bucket
			return rows[i].Group1 < rows[j].Group1
		})
	}

	// 5) optional sorting by pivot columns (e.g. mdl_submitted)
	if sort != "" {
		SortPivot(rows, sort) // accepts "group_1", "-mdl_submitted", etc.
	}

	return rows, total, nil
}




package main

import (
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	reviewinfo "your/module/path/reviewinfo" // <-- change to your module path
)

func main() {
	// configure your DSN
	dsn := "user:pass@tcp(127.0.0.1:3306)/yourdb?parseTime=true&charset=utf8mb4&loc=UTC"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalln("DB open:", err)
	}

	repo := &reviewinfo.ReviewInfoRepository{}
	r := gin.Default()

	// Example:
	// /api/assets/potoodev/pivot?root=assets&sort=group_1&phase=mdl&dir=asc&page=1&per_page=15
	r.GET("/api/assets/:project/pivot", func(c *gin.Context) {
		project := c.Param("project")
		root := c.DefaultQuery("root", "assets")

		// sort: accept "group_1" or "-mdl_submitted" (client can pass dir/desc if you prefer)
		sortKey := c.DefaultQuery("sort", "group_1")
		if dir := strings.ToLower(c.DefaultQuery("dir", "")); dir == "desc" && !strings.HasPrefix(sortKey, "-") {
			// convert (sort=foo&dir=desc) -> sort=-foo
			sortKey = "-" + sortKey
		}

		phaseCSV := c.DefaultQuery("phase", "")

		page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
		perPage, _ := strconv.Atoi(c.DefaultQuery("per_page", "15"))
		if perPage > 500 {
			perPage = 500
		}

		data, total, err := repo.GetAssetsPivotPage(c.Request.Context(), db, project, root, sortKey, phaseCSV, page, perPage)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		c.IndentedJSON(http.StatusOK, gin.H{
			"project":  project,
			"root":     root,
			"page":     page,
			"per_page": perPage,
			"total":    total,
			"count":    len(data),
			"data":     data,
			"ts":       time.Now().UTC().Format(time.RFC3339),
		})
	})

	_ = r.Run(":4000")
}
