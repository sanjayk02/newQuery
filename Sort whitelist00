package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/PolygonPictures/central30-web/front/entity"
	"github.com/PolygonPictures/central30-web/front/repository/model"
	"gorm.io/gorm"
)

// ---------------- Sort whitelist ----------------

func allowSort(token string) (string, bool) {
	if token == "" {
		return "", false
	}
	m := map[string]string{
		"group_1":    "group_1 ASC",
		"-group_1":   "group_1 DESC",
		"relation":   "relation ASC",
		"-relation":  "relation DESC",
		"phase":      "phase ASC",
		"-phase":     "phase DESC",
		"modified":   "modified_at_utc DESC",
		"-modified":  "modified_at_utc ASC",
		"submitted":  "submitted_at_utc DESC",
		"-submitted": "submitted_at_utc ASC",
		"__order":    "__order ASC",
		"-__order":   "__order DESC",
	}
	v, ok := m[token]
	return v, ok
}

// ---------------- CTEs (assets latest-per-phase â†’ pick one row per asset) ----------------

const orderedCTE = `
WITH ordered AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY group_1 ASC, relation ASC) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = @Project AND root = 'assets' AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT *
            FROM t_review_info
            WHERE project = @Project AND root = 'assets' AND deleted = 0
        ) AS b
        ON a.project = b.project
       AND a.root = b.root
       AND a.group_1 = b.group_1
       AND a.relation = b.relation
       AND a.phase = b.phase
       AND a.modified_at_utc = b.modified_at_utc
    ) AS k
)`
const offsetOrderedCTE = `
, offset_ordered AS (
    SELECT c.*,
           CASE WHEN c.phase = 'mdl' THEN c._order ELSE 100000 + c._order END AS __order
    FROM ordered c
)`
const rankedCTE = `
, ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
             PARTITION BY b.root, b.project, b.group_1, b.relation
             ORDER BY CASE WHEN b.phase='mdl' THEN 0 ELSE 1 END
           ) AS _rank
    FROM offset_ordered b
)`
const finalSelect = `
SELECT * FROM (SELECT * FROM ranked WHERE _rank=1) AS t
`
const baseSQL = orderedCTE + offsetOrderedCTE + rankedCTE + finalSelect

// ---------------- Repo ----------------

type ReviewInfo struct{ db *gorm.DB }

func NewReviewInfo(db *gorm.DB) (*ReviewInfo, error) { return &ReviewInfo{db: db}, nil }

// Latest per (project, root, group_1, relation, phase) by submitted_at_utc, with safe sort + paging
func (r *ReviewInfo) ListLatestSubmissionsWithSort(
	ctx context.Context, db *gorm.DB, project string, limit, offset int, sort string,
) ([]*entity.ReviewInfo, error) {

	if limit <= 0 || limit > 200 {
		limit = 50
	}
	if offset < 0 {
		offset = 0
	}

	// (a) latest submitted_at_utc per group
	stmtA := db.WithContext(ctx).Select(
		"project", "root", "group_1", "relation", "phase",
		"MAX(submitted_at_utc) AS submitted_at_utc",
	).Model(&model.ReviewInfo{}).
		Where("project = ?", project).
		Where("deleted = ?", 0).
		Group("project, root, group_1, relation, phase")

	// (b) full rows
	stmtB := db.WithContext(ctx).Select("*").
		Model(&model.ReviewInfo{}).
		Where("project = ?", project).
		Where("deleted = ?", 0)

	// join (a) to (b)
	stmt := db.WithContext(ctx).
		Select("b.*").
		Table("(?) AS a", stmtA).
		Joins(`
			INNER JOIN (?) AS b
			ON a.project=b.project AND a.root=b.root AND a.group_1=b.group_1
			AND a.relation=b.relation AND a.phase=b.phase
			AND a.submitted_at_utc=b.submitted_at_utc
		`, stmtB)

	order := "submitted_at_utc DESC, id DESC"
	if safe, ok := allowSort(sort); ok {
		order = safe + ", id DESC"
	}

	var rows []*model.ReviewInfo
	if err := stmt.Order(order).Limit(limit).Offset(offset).Find(&rows).Error; err != nil {
		return nil, err
	}

	out := make([]*entity.ReviewInfo, 0, len(rows))
	for _, m := range rows {
		out = append(out, m.Entity(false))
	}
	return out, nil
}

// One row per asset (prioritize mdl for overall sort); returns (rows, totalAssets)
func (r *ReviewInfo) ListLatestAssetReviewInfoForAssets(
	db *gorm.DB, params *entity.AssetListParams,
) ([]*entity.ReviewInfo, int, error) {

	// total distinct assets
	var total int64
	if err := db.Model(&model.ReviewInfo{}).
		Where("deleted = ?", 0).
		Where("project = ?", params.Project).
		Where("root = ?", "assets").
		Select("COUNT(DISTINCT CONCAT_WS('|', project, root, group_1, relation))").
		Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// paging
	limit := params.GetPerPage()
	if limit <= 0 || limit > 200 {
		limit = 50
	}
	page := params.GetPage()
	if page <= 0 {
		page = 1
	}
	offset := limit * (page - 1)

	// order
	orderBy := "ORDER BY __order ASC, id DESC"
	if params.OrderBy != nil && *params.OrderBy != "" {
		if safe, ok := allowSort(*params.OrderBy); ok {
			orderBy = "ORDER BY " + safe + ", id DESC"
		}
	}

	// final SQL
	rawSQL := fmt.Sprintf("%s %s LIMIT @Limit OFFSET @Offset", baseSQL, orderBy)

	var models []*model.ReviewInfo
	err := db.Raw(
		rawSQL,
		sql.Named("Project", params.Project),
		sql.Named("Limit", limit),
		sql.Named("Offset", offset),
	).Scan(&models).Error
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, 0, err
	}

	entities := make([]*entity.ReviewInfo, 0, len(models))
	for _, m := range models {
		entities = append(entities, m.Entity(false))
	}
	return entities, int(total), nil
}


package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/mongo/readpref"

	// gorm
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	// your modules
	"github.com/PolygonPictures/central30-web/front/repository"
)

// --- replace these with your actual config helpers (you already have them) ---
func mySQLConfigs() (user, pass, host, port, db string) { return "user", "pass", "127.0.0.1", "3306", "central30" }
func mongoConfigs() (user, pass, host, port, db string) { return "user", "pass", "127.0.0.1", "27017", "central30" }
func openMongo(user, pass, host, port, db string) *MongoWrap { return mustOpenMongo(user, pass, host, port, db) }
// -----------------------------------------------------------------------------

func main() {
	// ======================================================
	// 1) Open MySQL (GORM)
	// ======================================================
	dbUser, dbPass, dbHost, dbPort, dbName := mySQLConfigs()
	dsn := fmt.Sprintf("%s:%s@(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		dbUser, dbPass, dbHost, dbPort, dbName)

	gormDB, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}

	// ======================================================
	// 2) Open Mongo
	// ======================================================
	dbUser, dbPass, dbHost, dbPort, dbName = mongoConfigs()
	mongoDB := openMongo(dbUser, dbPass, dbHost, dbPort, dbName)

	// ======================================================
	// 3) Init repositories
	// ======================================================
	reviewInfoRepository, err := repository.NewReviewInfo(gormDB)
	if err != nil {
		log.Fatalln(err)
	}

	// ======================================================
	// 4) Router
	// ======================================================
	router := gin.New()
	router.Use(gin.Logger())
	router.Use(gin.Recovery())

	// Health checks
	router.GET("/health", func(c *gin.Context) {
		sqlDB, _ := gormDB.DB()
		if err := sqlDB.Ping(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "MySQL not reachable"})
			return
		}
		ctx, cancel := context.WithTimeout(c.Request.Context(), 3*time.Second)
		defer cancel()
		if err := mongoDB.Client().Ping(ctx, readpref.Primary()); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "MongoDB not reachable"})
			return
		}
		c.String(http.StatusOK, "ok")
	})
	router.GET("/ready", func(c *gin.Context) { c.Redirect(http.StatusTemporaryRedirect, "/health") })

	// ======================================================
	// 5) NEW: Public endpoint
	// GET /api/latest/review-submissions/:project?limit=50&offset=0&sort=submitted
	// ======================================================
	router.GET("/api/latest/review-submissions/:project", func(c *gin.Context) {
		project := strings.TrimSpace(c.Param("project"))
		if project == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "project is required"})
			return
		}

		limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
		offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
		sort := c.Query("sort") // tokens: submitted, -submitted, group_1, -group_1, relation, -relation, phase, -phase

		out, err := reviewInfoRepository.ListLatestSubmissionsWithSort(
			c.Request.Context(),
			gormDB,
			project,
			limit,
			offset,
			sort,
		)
		if err != nil {
			log.Printf("[review-submissions] error for %s: %v", project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		log.Printf("[review-submissions] returned %d row(s) for %s", len(out), project)
		c.IndentedJSON(http.StatusOK, out)
	})

	// ======================================================
	// 6) Start
	// ======================================================
	s := &http.Server{
		Addr:         ":4000",
		Handler:      router,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 30 * time.Second,
	}
	log.Println("ðŸš€ listening on http://localhost:4000")
	log.Fatal(s.ListenAndServe())
}

// ---- minimal Mongo wrapper used above (use your own in real code) ----
type MongoWrap struct{ client interface{ Ping(context.Context, *readpref.ReadPref) error } }

func (m *MongoWrap) Client() interface{ Ping(context.Context, *readpref.ReadPref) error } { return m.client }

func mustOpenMongo(user, pass, host, port, db string) *MongoWrap {
	// stub for demo; your real openMongo returns a client with .Ping
	return &MongoWrap{client: &fakeMongoClient{}}
}

type fakeMongoClient struct{}

func (*fakeMongoClient) Ping(context.Context, *readpref.ReadPref) error { return nil }

GET http://localhost:4000/api/latest/review-submissions/potoodev
GET http://localhost:4000/api/latest/review-submissions/potoodev?sort=submitted
GET http://localhost:4000/api/latest/review-submissions/potoodev?sort=-group_1&limit=25&offset=25



