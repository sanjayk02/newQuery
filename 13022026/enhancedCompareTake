// ============================================
// IMPROVED TAKE SORTING WITH BETTER EDGE CASE HANDLING
// ============================================
const enhancedCompareTake = useCallback((a: any, b: any, dir: SortDir): number => {
  const isAsc = dir === 'asc';
  
  const aEmpty = isEmptyValue(a);
  const bEmpty = isEmptyValue(b);
  
  // Empty values always go to the END
  if (aEmpty && bEmpty) return 0;
  if (aEmpty && !bEmpty) return 1;
  if (!aEmpty && bEmpty) return -1;
  
  // Convert to string and clean
  const aStr = String(a).trim();
  const bStr = String(b).trim();
  
  // Try to extract numeric part (handles cases like "20.", "0016", "0027")
  const extractNumber = (str: string): number | null => {
    // Remove any non-numeric characters except decimal point
    const cleaned = str.replace(/[^\d.-]/g, '');
    if (cleaned === '') return null;
    
    const num = parseFloat(cleaned);
    return isNaN(num) ? null : num;
  };
  
  const aNum = extractNumber(aStr);
  const bNum = extractNumber(bStr);
  
  // If both are valid numbers, compare numerically
  if (aNum !== null && bNum !== null) {
    if (aNum === bNum) {
      // If numbers are equal but strings differ (e.g., "0016" vs "16"), 
      // use string length as tiebreaker (shorter first)
      if (aStr !== bStr) {
        return isAsc ? aStr.length - bStr.length : bStr.length - aStr.length;
      }
      return 0;
    }
    
    if (isAsc) {
      return aNum < bNum ? -1 : 1;
    } else {
      return aNum > bNum ? -1 : 1;
    }
  }
  
  // If one is number and other isn't, number comes first
  if (aNum !== null && bNum === null) return -1;
  if (aNum === null && bNum !== null) return 1;
  
  // Fallback to string comparison
  if (isAsc) {
    return aStr.localeCompare(bStr);
  } else {
    return bStr.localeCompare(aStr);
  }
}, []);
