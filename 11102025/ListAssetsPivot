// ---------- ListAssetsPivot (Second query + pivot; MySQL-8 safe) ----------
func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
) ([]AssetPivot, int64, error) {

	// 1) Total asset count for pagination UI
	total, err := r.CountLatestSubmissions(ctx, project, root)
	if err != nil {
		return nil, 0, err
	}

	// 2) Page keys using the same ordering/phase preference as the grid
	keys, err := r.ListLatestSubmissionsDynamic(ctx, project, root, preferredPhase, orderKey, direction, limit, offset)
	if err != nil {
		return nil, 0, err
	}

	// No keys on this page → empty pivot (avoid running the phase SQL at all)
	if len(keys) == 0 {
		return []AssetPivot{}, total, nil
	}

	// 3) Build a MySQL-friendly CTE for keys:
	//    Always start with a dummy "SELECT … WHERE FALSE" so the CTE is valid even if keys is empty.
	var sb strings.Builder
	var params []any

	sb.WriteString("WITH keys AS (")
	sb.WriteString("SELECT '' AS root, '' AS project, '' AS group_1, '' AS relation WHERE FALSE")
	for _, k := range keys {
		sb.WriteString(" UNION ALL SELECT ? AS root, ? AS project, ? AS group_1, ? AS relation")
		params = append(params, k.Root, k.Project, k.Group1, k.Relation)
	}
	sb.WriteString(`),
latest_per_phase AS (
  SELECT
    t.project, t.root, t.group_1, t.relation, t.phase,
    t.work_status, t.approval_status, t.submitted_at_utc, t.modified_at_utc,
    ROW_NUMBER() OVER (
      PARTITION BY t.project, t.root, t.group_1, t.relation, t.phase
      ORDER BY t.modified_at_utc DESC, t.submitted_at_utc DESC
    ) rn
  FROM t_review_info t
  JOIN keys k
    ON t.project  = k.project
   AND t.root     = k.root
   AND t.group_1  = k.group_1
   AND t.relation = k.relation
  WHERE t.deleted = 0
)
SELECT
  project, root, group_1, relation, phase,
  work_status, approval_status, submitted_at_utc
FROM latest_per_phase
WHERE rn = 1;`)

	// 4) Fetch the latest row per phase for just this page’s keys
	var phaseRows []phaseRow
	if err := r.db.WithContext(ctx).Raw(sb.String(), params...).Scan(&phaseRows).Error; err != nil {
		// Helpful diagnostics during dev
		fmt.Println("\n----- ListAssetsPivot: phase fetch SQL ERROR -----")
		fmt.Println("SQL:\n", sb.String())
		fmt.Println("PARAMS:", params)
		fmt.Println("ERROR:", err)
		fmt.Println("--------------------------------------------------\n")
		return nil, 0, fmt.Errorf("ListAssetsPivot.phaseFetch: %w", err)
	}

	// 5) Pivot in Go while preserving the original page order from `keys`
	type assetKey struct{ P, R, G, L string }
	index := make(map[assetKey]*AssetPivot, len(keys))
	ordered := make([]AssetPivot, 0, len(keys))

	// Initialize one pivot row per asset key (keeps page order)
	for _, k := range keys {
		id := assetKey{k.Project, k.Root, k.Group1, k.Relation}
		ap := &AssetPivot{
			Root:     k.Root,
			Project:  k.Project,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
		index[id] = ap
		ordered = append(ordered, *ap)
	}

	// Fill phases
	for _, pr := range phaseRows {
		id := assetKey{pr.Project, pr.Root, pr.Group1, pr.Relation}
		ap, ok := index[id]
		if !ok {
			continue
		}
		switch strings.ToLower(pr.Phase) {
		case "mdl":
			ap.MDLWorkStatus = pr.WorkStatus
			ap.MDLApprovalStatus = pr.ApprovalStatus
			ap.MDLSubmittedAtUTC = pr.SubmittedAtUTC
		case "rig":
			ap.RIGWorkStatus = pr.WorkStatus
			ap.RIGApprovalStatus = pr.ApprovalStatus
			ap.RIGSubmittedAtUTC = pr.SubmittedAtUTC
		case "bld":
			ap.BLDWorkStatus = pr.WorkStatus
			ap.BLDApprovalStatus = pr.ApprovalStatus
			ap.BLDSubmittedAtUTC = pr.SubmittedAtUTC
		case "dsn":
			ap.DSNWorkStatus = pr.WorkStatus
			ap.DSNApprovalStatus = pr.ApprovalStatus
			ap.DSNSubmittedAtUTC = pr.SubmittedAtUTC
		case "ldv":
			ap.LDVWorkStatus = pr.WorkStatus
			ap.LDVApprovalStatus = pr.ApprovalStatus
			ap.LDVSubmittedAtUTC = pr.SubmittedAtUTC
		}
	}

	// Copy filled data back into the ordered slice
	for i := range ordered {
		id := assetKey{ordered[i].Project, ordered[i].Root, ordered[i].Group1, ordered[i].Relation}
		if filled, ok := index[id]; ok {
			ordered[i] = *filled
		}
	}

	return ordered, total, nil
}
