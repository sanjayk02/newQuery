func (r *ReviewInfo) ListLatestSubmissionsDynamic(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string, // e.g. "mdl" or "none"
	orderKey string,       // unused here because you fixed the ORDER BY to group_1; keep for API compat
	direction string,      // unused here
	limit, offset int,
) ([]LatestSubmissionRow, error) {
	if project == "" {
		return nil, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	// If you want "no phase preference", you can pass something that won't match any phase (e.g., "__none__").
	phaseParam := preferredPhase
	if strings.EqualFold(preferredPhase, "none") || preferredPhase == "" {
		phaseParam = "__none__"
	}

	const q = `
WITH ordered AS (
  SELECT *, ROW_NUMBER() OVER (
      ORDER BY group_1 ASC  -- default sort field here
  ) AS _order
  FROM (
    SELECT b.*
    FROM (
      SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
      GROUP BY project, root, group_1, relation, phase
    ) AS a
    LEFT JOIN (
      SELECT root, project, group_1, phase, relation, work_status, submitted_at_utc, modified_at_utc, executed_computer
      FROM t_review_info
      WHERE project = ? AND root = ? AND deleted = 0
    ) AS b
      ON a.project = b.project
     AND a.root = b.root
     AND a.group_1 = b.group_1
     AND a.relation = b.relation
     AND a.phase = b.phase
     AND a.modified_at_utc = b.modified_at_utc
    ORDER BY submitted_at_utc ASC
  ) AS k
),
offset_ordered AS (
  SELECT c.*,
         CASE WHEN c.phase = ? THEN c._order ELSE 100000 + c._order END AS __order
  FROM ordered c
),
ranked AS (
  SELECT b.*,
         ROW_NUMBER() OVER (
           PARTITION BY b.root, b.project, b.group_1, b.relation
           ORDER BY CASE WHEN b.phase = ? THEN 0 ELSE 1 END
         ) AS _rank
  FROM offset_ordered b
)
SELECT root, project, group_1, relation, phase, submitted_at_utc
FROM ranked
WHERE _rank = 1
ORDER BY __order ASC
LIMIT ? OFFSET ?;`

	args := []any{
		project, root, // inner GROUP BY
		project, root, // join back
		phaseParam,    // offset_ordered CASE
		phaseParam,    // ranked CASE
		limit, offset, // page
	}

	var rows []LatestSubmissionRow
	if err := r.db.WithContext(ctx).Raw(q, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestSubmissionsDynamic: %w", err)
	}
	return rows, nil
}
