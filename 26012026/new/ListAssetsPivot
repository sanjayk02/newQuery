func (r *ReviewInfo) ListAssetsPivot(
    ctx context.Context,
    project, root, preferredPhase, orderKey, direction string,
    limit, offset int,
    assetNameKey string,
    approvalStatuses []string,
    workStatuses []string,
) ([]AssetPivot, int64, error) {
    log.Printf("[REPO] ListAssetsPivot starting: project=%s, limit=%d, offset=%d",
        project, limit, offset)
    start := time.Now()
    defer func() {
        log.Printf("[REPO] ListAssetsPivot completed in %v", time.Since(start))
    }()

    if project == "" {
        return nil, 0, fmt.Errorf("project is required")
    }
    if root == "" {
        root = "assets"
    }

    // ENFORCE LIMITS at repository level
    if limit > 100 {
        log.Printf("[WARN] ListAssetsPivot: limit %d capped at 100", limit)
        limit = 100
    }
    if limit <= 0 {
        limit = 50 // Default to 50 instead of 60
    }
    if offset < 0 {
        offset = 0
    }

    db := r.db.WithContext(ctx)

    // OPTIMIZED: Single query approach instead of multiple queries
    // Build dynamic WHERE clause for asset name filter
    assetNameFilter := ""
    assetNameArgs := []any{}
    if strings.TrimSpace(assetNameKey) != "" {
        assetNameFilter = "AND LOWER(t1.group_1) LIKE ?"
        assetNameArgs = append(assetNameArgs, strings.ToLower(strings.TrimSpace(assetNameKey))+"%")
    }

    // FIXED: Correct backtick escaping for groups column
    // Use proper escaping: `groups` should be escaped as ` + "`groups`" + `
    // But actually, let's use a simpler approach
    
    // Main optimized query - SIMPLIFIED VERSION without JSON extraction issues
    query := fmt.Sprintf(`
        WITH latest_per_asset AS (
            SELECT 
                t1.project,
                t1.root,
                t1.group_1,
                t1.relation,
                t1.phase,
                t1.work_status,
                t1.approval_status,
                t1.submitted_at_utc,
                t1.modified_at_utc,
                -- SIMPLIFIED: Don't use JSON extraction for now, use group_1 as fallback
                t1.group_1 as leaf_group_name,
                ROW_NUMBER() OVER (
                    PARTITION BY t1.project, t1.root, t1.group_1, t1.relation, t1.phase
                    ORDER BY t1.modified_at_utc DESC
                ) as phase_rn
            FROM t_review_info t1
            WHERE t1.project = ? 
              AND t1.root = ? 
              AND t1.deleted = 0
              %s
        ),
        asset_keys AS (
            SELECT DISTINCT
                project,
                root,
                group_1,
                relation,
                MAX(modified_at_utc) as latest_modified
            FROM latest_per_asset
            GROUP BY project, root, group_1, relation
            ORDER BY group_1 ASC, relation ASC
            LIMIT ? OFFSET ?
        ),
        total_count AS (
            SELECT COUNT(DISTINCT CONCAT(group_1, '|', relation)) as cnt
            FROM t_review_info
            WHERE project = ? AND root = ? AND deleted = 0
        )
        SELECT 
            lpa.project,
            lpa.root,
            lpa.group_1,
            lpa.relation,
            lpa.phase,
            lpa.work_status,
            lpa.approval_status,
            lpa.submitted_at_utc,
            lpa.leaf_group_name,
            -- Try to get group category from separate query if needed
            'Unassigned' as group_category_path,
            'Unassigned' as top_group_node,
            tc.cnt as total_count,
            lpa.phase_rn
        FROM asset_keys ak
        JOIN latest_per_asset lpa ON lpa.project = ak.project 
            AND lpa.root = ak.root 
            AND lpa.group_1 = ak.group_1 
            AND lpa.relation = ak.relation
            AND lpa.modified_at_utc = ak.latest_modified
        CROSS JOIN total_count tc
        WHERE lpa.phase_rn = 1
        ORDER BY lpa.group_1 ASC, lpa.relation ASC, lpa.phase ASC
    `, assetNameFilter)

    // Build arguments
    args := []any{project, root}
    if len(assetNameArgs) > 0 {
        args = append(args, assetNameArgs...)
    }
    args = append(args, limit, offset, project, root)

    var phaseRows []struct {
        Project            string     `gorm:"column:project"`
        Root               string     `gorm:"column:root"`
        Group1             string     `gorm:"column:group_1"`
        Relation           string     `gorm:"column:relation"`
        Phase              string     `gorm:"column:phase"`
        WorkStatus         *string    `gorm:"column:work_status"`
        ApprovalStatus     *string    `gorm:"column:approval_status"`
        SubmittedAtUTC     *time.Time `gorm:"column:submitted_at_utc"`
        LeafGroupName      string     `gorm:"column:leaf_group_name"`
        GroupCategoryPath  string     `gorm:"column:group_category_path"`
        TopGroupNode       string     `gorm:"column:top_group_node"`
        TotalCount         int64      `gorm:"column:total_count"`
        PhaseRN            int        `gorm:"column:phase_rn"`
    }

    if err := db.Raw(query, args...).Scan(&phaseRows).Error; err != nil {
        log.Printf("[ERROR] ListAssetsPivot query failed: %v", err)
        
        // ULTRA SIMPLE FALLBACK - Just get basic asset data
        log.Printf("[INFO] Trying fallback simple query")
        fallbackQuery := `
            SELECT DISTINCT
                project,
                root,
                group_1,
                relation,
                phase,
                work_status,
                approval_status,
                submitted_at_utc
            FROM t_review_info
            WHERE project = ? 
              AND root = ? 
              AND deleted = 0
            ORDER BY group_1 ASC, relation ASC
            LIMIT ? OFFSET ?
        `
        
        var simpleRows []struct {
            Project        string     `gorm:"column:project"`
            Root           string     `gorm:"column:root"`
            Group1         string     `gorm:"column:group_1"`
            Relation       string     `gorm:"column:relation"`
            Phase          string     `gorm:"column:phase"`
            WorkStatus     *string    `gorm:"column:work_status"`
            ApprovalStatus *string    `gorm:"column:approval_status"`
            SubmittedAtUTC *time.Time `gorm:"column:submitted_at_utc"`
        }
        
        fallbackArgs := []any{project, root, limit, offset}
        if err := db.Raw(fallbackQuery, fallbackArgs...).Scan(&simpleRows).Error; err != nil {
            return nil, 0, fmt.Errorf("ListAssetsPivot (fallback failed): %w", err)
        }
        
        // Convert simple rows to AssetPivot
        assets := make([]AssetPivot, len(simpleRows))
        for i, row := range simpleRows {
            assets[i] = AssetPivot{
                Root:               row.Root,
                Project:            row.Project,
                Group1:             row.Group1,
                Relation:           row.Relation,
                LeafGroupName:      row.Group1, // Use group_1 as leaf name
                GroupCategoryPath:  "Unassigned",
                TopGroupNode:       "Unassigned",
            }
            
            // Set phase data
            switch strings.ToLower(row.Phase) {
            case "mdl":
                assets[i].MDLWorkStatus = row.WorkStatus
                assets[i].MDLApprovalStatus = row.ApprovalStatus
                assets[i].MDLSubmittedAtUTC = row.SubmittedAtUTC
            case "rig":
                assets[i].RIGWorkStatus = row.WorkStatus
                assets[i].RIGApprovalStatus = row.ApprovalStatus
                assets[i].RIGSubmittedAtUTC = row.SubmittedAtUTC
            case "bld":
                assets[i].BLDWorkStatus = row.WorkStatus
                assets[i].BLDApprovalStatus = row.ApprovalStatus
                assets[i].BLDSubmittedAtUTC = row.SubmittedAtUTC
            case "dsn":
                assets[i].DSNWorkStatus = row.WorkStatus
                assets[i].DSNApprovalStatus = row.ApprovalStatus
                assets[i].DSNSubmittedAtUTC = row.SubmittedAtUTC
            case "ldv":
                assets[i].LDVWorkStatus = row.WorkStatus
                assets[i].LDVApprovalStatus = row.ApprovalStatus
                assets[i].LDVSubmittedAtUTC = row.SubmittedAtUTC
            }
        }
        
        // Get total count
        var total int64
        countQuery := `SELECT COUNT(DISTINCT CONCAT(group_1, '|', relation)) FROM t_review_info WHERE project = ? AND root = ? AND deleted = 0`
        if err := db.Raw(countQuery, project, root).Scan(&total).Error; err != nil {
            total = int64(len(assets))
        }
        
        return assets, total, nil
    }

    if len(phaseRows) == 0 {
        return []AssetPivot{}, 0, nil
    }

    // Convert to pivot format
    total := phaseRows[0].TotalCount
    pivotMap := make(map[string]*AssetPivot)

    for _, row := range phaseRows {
        if row.PhaseRN > 1 {
            continue // Only take latest for each phase
        }

        key := row.Group1 + "|" + row.Relation
        if _, exists := pivotMap[key]; !exists {
            pivotMap[key] = &AssetPivot{
                Root:               row.Root,
                Project:            row.Project,
                Group1:             row.Group1,
                Relation:           row.Relation,
                LeafGroupName:      row.LeafGroupName,
                GroupCategoryPath:  row.GroupCategoryPath,
                TopGroupNode:       row.TopGroupNode,
            }
        }

        // Set phase-specific data
        ap := pivotMap[key]
        switch strings.ToLower(row.Phase) {
        case "mdl":
            ap.MDLWorkStatus = row.WorkStatus
            ap.MDLApprovalStatus = row.ApprovalStatus
            ap.MDLSubmittedAtUTC = row.SubmittedAtUTC
        case "rig":
            ap.RIGWorkStatus = row.WorkStatus
            ap.RIGApprovalStatus = row.ApprovalStatus
            ap.RIGSubmittedAtUTC = row.SubmittedAtUTC
        case "bld":
            ap.BLDWorkStatus = row.WorkStatus
            ap.BLDApprovalStatus = row.ApprovalStatus
            ap.BLDSubmittedAtUTC = row.SubmittedAtUTC
        case "dsn":
            ap.DSNWorkStatus = row.WorkStatus
            ap.DSNApprovalStatus = row.ApprovalStatus
            ap.DSNSubmittedAtUTC = row.SubmittedAtUTC
        case "ldv":
            ap.LDVWorkStatus = row.WorkStatus
            ap.LDVApprovalStatus = row.ApprovalStatus
            ap.LDVSubmittedAtUTC = row.SubmittedAtUTC
        }
    }

    // Convert to slice in order
    result := make([]AssetPivot, 0, len(pivotMap))
    for _, ap := range pivotMap {
        result = append(result, *ap)
    }

    // Sort by group_1
    sort.Slice(result, func(i, j int) bool {
        return strings.ToLower(result[i].Group1) < strings.ToLower(result[j].Group1)
    })

    log.Printf("[REPO] ListAssetsPivot returning %d assets, total: %d", len(result), total)
    return result, total, nil
}
