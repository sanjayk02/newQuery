func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project, root, preferredPhase, orderKey, direction string,
	limit, offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]AssetPivot, int64, error) {

	if project == "" {
		return nil, 0, fmt.Errorf("project is required")
	}
	if root == "" {
		root = "assets"
	}
	if limit <= 0 {
		limit = 60
	}
	if offset < 0 {
		offset = 0
	}

	db := r.db.WithContext(ctx)

	// ------------------------------------------------
	// 1) TOTAL COUNT
	// ------------------------------------------------
	total, err := r.CountLatestSubmissions(
		ctx,
		project,
		root,
		assetNameKey,
		preferredPhase,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}

	// ------------------------------------------------
	// 2) OVER-FETCH LATEST ASSETS (NO OFFSET)
	// ------------------------------------------------
	fetchLimit := limit * 20 // enough for global sort

	keysAll, err := r.ListLatestSubmissionsDynamic(
		ctx,
		project,
		root,
		preferredPhase,
		orderKey,
		direction,
		fetchLimit,
		0,
		assetNameKey,
		approvalStatuses,
		workStatuses,
	)
	if err != nil {
		return nil, 0, err
	}
	if len(keysAll) == 0 {
		return []AssetPivot{}, total, nil
	}

	// ------------------------------------------------
	// 3) GLOBAL SORT IN GO
	// ------------------------------------------------
	dir := strings.ToLower(direction)

	sort.SliceStable(keysAll, func(i, j int) bool {
		switch orderKey {

		case "group_1":
			if dir == "desc" {
				return keysAll[i].Group1 > keysAll[j].Group1
			}
			return keysAll[i].Group1 < keysAll[j].Group1

		case "submitted_at_utc":
			ti := keysAll[i].SubmittedAtUTC
			tj := keysAll[j].SubmittedAtUTC
			if ti == nil || tj == nil {
				return false
			}
			if dir == "desc" {
				return ti.After(*tj)
			}
			return ti.Before(*tj)
		}
		return false
	})

	// ------------------------------------------------
	// 4) APPLY PAGINATION AFTER SORT
	// ------------------------------------------------
	start := offset
	end := offset + limit
	if start > len(keysAll) {
		start = len(keysAll)
	}
	if end > len(keysAll) {
		end = len(keysAll)
	}
	keys := keysAll[start:end]

	// ------------------------------------------------
	// 5) FETCH ALL ROWS FOR PAGE ASSETS (WITH JOINS)
	// ------------------------------------------------
	var sb strings.Builder
	var params []any

	where := []string{}
	for _, k := range keys {
		where = append(where, "(ri.group_1 = ? AND ri.relation = ?)")
		params = append(params, k.Group1, k.Relation)
	}

	sb.WriteString(`
		SELECT 
			ri.project,
			ri.root,
			ri.group_1,
			ri.relation,
			ri.phase,
			ri.work_status,
			ri.approval_status,
			ri.submitted_at_utc,
			ri.modified_at_utc,
			JSON_UNQUOTE(JSON_EXTRACT(ri.` + "`groups`" + `, '$[0]')) AS leaf_group_name,
			gc.path AS group_category_path,
			SUBSTRING_INDEX(gc.path, '/', 1) AS top_group_node
		FROM t_review_info AS ri
		LEFT JOIN t_group_category_group AS gcg
			ON gcg.project = ri.project
			AND gcg.deleted = 0
			AND gcg.path = JSON_UNQUOTE(JSON_EXTRACT(ri.` + "`groups`" + `, '$[0]'))
		LEFT JOIN t_group_category AS gc
			ON gc.id = gcg.group_category_id
			AND gc.deleted = 0
			AND gc.root = 'assets'
		WHERE ri.project = ?
		  AND ri.root = ?
		  AND ri.deleted = 0
		  AND (` + strings.Join(where, " OR ") + `)
		ORDER BY ri.modified_at_utc DESC
	`)

	params = append([]any{project, root}, params...)

	type rawRow struct {
		phaseRow
		ModifiedAtUTC time.Time `gorm:"column:modified_at_utc"`
	}

	var rows []rawRow
	if err := db.Raw(sb.String(), params...).Scan(&rows).Error; err != nil {
		return nil, 0, err
	}

	// ------------------------------------------------
	// 6) FILTER + DEDUPE PER PHASE
	// ------------------------------------------------
	statusAllowed := func(val *string, allowed []string) bool {
		if len(allowed) == 0 {
			return true
		}
		if val == nil {
			return false
		}
		v := strings.ToLower(strings.TrimSpace(*val))
		for _, a := range allowed {
			if v == strings.ToLower(strings.TrimSpace(a)) {
				return true
			}
		}
		return false
	}

	latest := map[string]phaseRow{}

	for _, r := range rows {

		if !statusAllowed(r.WorkStatus, workStatuses) {
			continue
		}
		if !statusAllowed(r.ApprovalStatus, approvalStatuses) {
			continue
		}

		key := r.Group1 + "|" + r.Relation + "|" + r.Phase
		if _, exists := latest[key]; exists {
			continue
		}

		latest[key] = r.phaseRow
	}

	// ------------------------------------------------
	// 7) PREFERRED PHASE PRIORITY
	// ------------------------------------------------
	if preferredPhase != "" && preferredPhase != "none" {
		pp := strings.ToLower(preferredPhase)

		for _, k := range keys {
			base := k.Group1 + "|" + k.Relation

			hasPreferred := false
			for key := range latest {
				if strings.HasPrefix(key, base+"|") &&
					strings.HasSuffix(key, "|"+pp) {
					hasPreferred = true
					break
				}
			}

			if hasPreferred {
				for key := range latest {
					if strings.HasPrefix(key, base+"|") &&
						!strings.HasSuffix(key, "|"+pp) {
						delete(latest, key)
					}
				}
			}
		}
	}

	// ------------------------------------------------
	// 8) BUILD PIVOT STRUCTS
	// ------------------------------------------------
	pivotMap := make(map[string]*AssetPivot)

	for _, k := range keys {
		key := k.Group1 + "|" + k.Relation
		pivotMap[key] = &AssetPivot{
			Project:  project,
			Root:     root,
			Group1:   k.Group1,
			Relation: k.Relation,
		}
	}

	for _, r := range latest {
		key := r.Group1 + "|" + r.Relation
		p := pivotMap[key]
		if p == nil {
			continue
		}

		p.LeafGroupName = r.LeafGroupName
		p.GroupCategoryPath = r.GroupCategoryPath
		p.TopGroupNode = r.TopGroupNode

		switch strings.ToLower(r.Phase) {
		case "mdl":
			p.MDLWorkStatus = r.WorkStatus
			p.MDLApprovalStatus = r.ApprovalStatus
			p.MDLSubmittedAtUTC = r.SubmittedAtUTC
		case "rig":
			p.RIGWorkStatus = r.WorkStatus
			p.RIGApprovalStatus = r.ApprovalStatus
			p.RIGSubmittedAtUTC = r.SubmittedAtUTC
		case "bld":
			p.BLDWorkStatus = r.WorkStatus
			p.BLDApprovalStatus = r.ApprovalStatus
			p.BLDSubmittedAtUTC = r.SubmittedAtUTC
		case "dsn":
			p.DSNWorkStatus = r.WorkStatus
			p.DSNApprovalStatus = r.ApprovalStatus
			p.DSNSubmittedAtUTC = r.SubmittedAtUTC
		case "ldv":
			p.LDVWorkStatus = r.WorkStatus
			p.LDVApprovalStatus = r.ApprovalStatus
			p.LDVSubmittedAtUTC = r.SubmittedAtUTC
		}
	}

	// ------------------------------------------------
	// 9) FLATTEN RESULT
	// ------------------------------------------------
	out := make([]AssetPivot, 0, len(pivotMap))
	for _, p := range pivotMap {
		out = append(out, *p)
	}

	return out, total, nil
}
