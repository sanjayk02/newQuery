// AssetRow matches the final SELECT columns of your query
type AssetRow struct {
	Root     string `gorm:"column:root" json:"root"`
	Project  string `gorm:"column:project" json:"project"`
	Group1   string `gorm:"column:group_1" json:"group_1"`
	Relation string `gorm:"column:relation" json:"relation"`
}

// ListLatestAssetReviewInfoForAssets runs your original CTE query
// but adds dynamic sort (sortField:sortDir) + LIMIT/OFFSET.
func (r *ReviewInfo) ListLatestAssetReviewInfoForAssets(
	ctx context.Context,
	db *gorm.DB,
	project, root, relation string,
	limit, offset int,
	sortField, sortDir string,
) ([]AssetRow, error) {

	// ✅ Safe whitelist to prevent SQL injection
	allowedSorts := map[string]bool{
		"submitted_at_utc": true,
		"modified_at_utc":  true,
		"group_1":          true,
		"phase":            true,
	}
	if !allowedSorts[sortField] {
		sortField = "submitted_at_utc"
	}
	if strings.ToUpper(sortDir) != "DESC" {
		sortDir = "ASC"
	}

	// ✅ Build dynamic ORDER BY for the inner CTE
	sql := fmt.Sprintf(`
WITH ordered AS (
    SELECT *,
           ROW_NUMBER() OVER (
               ORDER BY %s %s
           ) AS _order
    FROM (
        SELECT b.*
        FROM (
            SELECT project, root, group_1, relation, phase, MAX(modified_at_utc) AS modified_at_utc
            FROM t_review_info
            WHERE project = ? AND root = ? AND relation = ? AND deleted = 0
            GROUP BY project, root, group_1, relation, phase
        ) AS a
        LEFT JOIN (
            SELECT root, project, group_1, phase, relation,
                   work_status, submitted_at_utc, modified_at_utc, executed_computer
            FROM t_review_info
            WHERE project = ? AND root = ? AND relation = ? AND deleted = 0
        ) AS b
          ON a.project = b.project
         AND a.root = b.root
         AND a.group_1 = b.group_1
         AND a.relation = b.relation
         AND a.phase = b.phase
         AND a.modified_at_utc = b.modified_at_utc
    ) AS k
),
offset_ordered AS (
    SELECT c.*,
           CASE WHEN c.phase = 'mdl' THEN c._order ELSE 100000 + c._order END AS __order
    FROM ordered c
),
ranked AS (
    SELECT b.*,
           ROW_NUMBER() OVER (
               PARTITION BY b.root, b.project, b.group_1, b.relation
               ORDER BY CASE WHEN b.phase = 'mdl' THEN 0 ELSE 1 END
           ) AS _rank
    FROM offset_ordered b
)
SELECT root, project, group_1, relation
FROM (
    SELECT *
    FROM ranked
    WHERE _rank = 1
) AS t
ORDER BY __order ASC
LIMIT ? OFFSET ?;
`, sortField, sortDir)

	// ✅ Arguments for placeholders
	args := []any{
		project, root, relation,
		project, root, relation,
		limit, offset,
	}

	var rows []AssetRow
	if err := db.WithContext(ctx).Raw(sql, args...).Scan(&rows).Error; err != nil {
		return nil, fmt.Errorf("ListLatestAssetReviewInfoForAssets: %w", err)
	}
	return rows, nil
}


// ----------------------------

sortParam := c.DefaultQuery("sort", "submitted_at_utc:asc")
sortParts := strings.Split(sortParam, ":")
sortField := sortParts[0]
sortDir := "ASC"
if len(sortParts) > 1 && strings.ToLower(sortParts[1]) == "desc" {
	sortDir = "DESC"
}

rows, err := reviewInfoRepository.ListLatestAssetReviewInfoForAssets(
	c.Request.Context(),
	gormDB,
	project,
	"assets",
	"com",
	15,
	0,
	sortField,
	sortDir,
)

