  const renderNodes = (
    nodes: TreeNode[],
    depth = 0,
    isLastArray: boolean[] = [],
  ): React.ReactNode =>
    nodes.map((node, index) => {
      const isLast = index === nodes.length - 1;
      const thisIsLastArray = [...isLastArray, isLast];

      // Build ASCII prefix – your existing logic
      let prefix = '';
      if (depth > 0) {
        for (let i = 0; i < depth - 1; i++) {
          const isRootColumn = i === 0;
          if (isRootColumn) {
            prefix += '   ';
          } else {
            prefix += thisIsLastArray[i] ? '   ' : '│  ';
          }
        }
        prefix += isLast ? '└─ ' : '├─ ';
      }

      const isLeafGroup =
        node.isGroup &&
        node.category &&
        (!node.children || node.children.length === 0);

      const hasChildren = node.children && node.children.length > 0;
      const isCollapsed = !!collapsed[node.fullPath];

      return (
        <React.Fragment key={node.fullPath}>
          <div className={classes.treeRow}>
            {/* column 1: + / - toggle */}
            <span
              style={{
                cursor: hasChildren ? 'pointer' : 'default',
                userSelect: 'none',
              }}
              onClick={() => hasChildren && toggleNode(node.fullPath)}
            >
              {hasChildren ? (isCollapsed ? '+' : '-') : ''}
            </span>

            {/* column 2: ASCII tree text */}
            <span
              className={classes.treeText}
              style={{ fontWeight: depth === 0 ? 'bold' : 'normal' }}
            >
              {prefix}
              {node.name}
            </span>

            {/* column 3: delete icon only for leaf groups */}
            {isLeafGroup && onRemoveGroup ? (
              <IconButton
                size="small"
                className={classes.treeIcon}
                onClick={() => onRemoveGroup(node.category!, node.fullPath)}
              >
                <DeleteIcon fontSize="small" />
              </IconButton>
            ) : (
              <span /> // empty cell to keep grid alignment
            )}
          </div>

          {/* children: render ONLY when not collapsed */}
          {!isCollapsed &&
            renderNodes(node.children, depth + 1, thisIsLastArray)}
        </React.Fragment>
      );
    });
