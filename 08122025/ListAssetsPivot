// ListAssetsPivot returns a page of AssetPivot rows plus the total count.
// Group priority order:
//   1. camera
//   2. character
//   3. set
//   4. prop
//   5. everything else, alphabetically by top_group_node
func (r *ReviewInfo) ListAssetsPivot(
	ctx context.Context,
	project string,
	root string,
	preferredPhase string,
	sortKey string,
	dir string,
	limit int,
	offset int,
	assetNameKey string,
	approvalStatuses []string,
	workStatuses []string,
) ([]model.AssetPivot, int64, error) {

	db := r.db.WithContext(ctx)

	// ---------------------------------------------------------------------
	// 1) Load assets from DB into []model.AssetPivot
	// ---------------------------------------------------------------------
	// NOTE:
	//   Replace this block with your existing RAW SQL / GORM query
	//   that populates []model.AssetPivot (WITHOUT doing LIMIT/OFFSET).
	//   Example shape (pseudo-code):
	//
	//   sql := `SELECT ... FROM t_review_info ...`
	//   var assets []model.AssetPivot
	//   if err := db.Raw(sql, args...).Scan(&assets).Error; err != nil {
	//       return nil, 0, err
	//   }
	//
	// For now, we just declare the slice so the code compiles;
	// you must plug in your real query here.
	assets := make([]model.AssetPivot, 0)

	// If you already had working DB code before, move that code here
	// and delete the line above.

	// Guard: if nothing returned, we can short-circuit
	if len(assets) == 0 {
		return []model.AssetPivot{}, 0, nil
	}

	// ---------------------------------------------------------------------
	// 2) Priority sort in Go
	// ---------------------------------------------------------------------

	// Priority: camera, character, set, prop, then others.
	topGroupPriority := func(name string) int {
		switch name {
		case "camera":
			return 0
		case "character":
			return 1
		case "set":
			return 2
		case "prop":
			return 3
		default:
			// everything else comes after the 4 priorities
			return 10
		}
	}

	// Normalise dir (anything non "desc" is treated as "asc")
	desc := strings.EqualFold(dir, "desc")

	sort.Slice(assets, func(i, j int) bool {
		a := assets[i]
		b := assets[j]

		// Primary: priority of top_group_node
		pa := topGroupPriority(a.TopGroupNode)
		pb := topGroupPriority(b.TopGroupNode)

		if pa != pb {
			if desc {
				return pa > pb
			}
			return pa < pb
		}

		// Secondary: for same top_group_node, sort by group_1
		if a.Group1 != b.Group1 {
			if desc {
				return a.Group1 > b.Group1
			}
			return a.Group1 < b.Group1
		}

		// Tertiary: relation
		if a.Relation != b.Relation {
			if desc {
				return a.Relation > b.Relation
			}
			return a.Relation < b.Relation
		}

		// Final tie-breaker: leaf_group_name
		if a.LeafGroupName != b.LeafGroupName {
			if desc {
				return a.LeafGroupName > b.LeafGroupName
			}
			return a.LeafGroupName < b.LeafGroupName
		}

		return false
	})

	// ---------------------------------------------------------------------
	// 3) Apply pagination AFTER sorting
	// ---------------------------------------------------------------------
	total := len(assets)

	// Safety for weird inputs
	if limit <= 0 {
		limit = total
	}
	if offset < 0 {
		offset = 0
	}

	if offset >= total {
		return []model.AssetPivot{}, int64(total), nil
	}

	end := offset + limit
	if end > total {
		end = total
	}

	pageAssets := assets[offset:end]

	return pageAssets, int64(total), nil
}
