func GroupAndSortByTopNode(
	rows []AssetPivot,
	dir SortDirection,
) []GroupedAssetBucket {

	// ✅ Priority order you requested
	priority := []string{"camera", "character", "set", "prop"}
	priorityIndex := map[string]int{}
	for i, p := range priority {
		priorityIndex[p] = i
	}

	grouped := make(map[string][]AssetPivot)

	// 1️⃣ Grouping
	for _, row := range rows {
		key := strings.ToLower(strings.TrimSpace(row.TopGroupNode))
		if key == "" {
			key = "unassigned"
		}
		grouped[key] = append(grouped[key], row)
	}

	// 2️⃣ Collect group keys
	keys := make([]string, 0, len(grouped))
	for k := range grouped {
		keys = append(keys, k)
	}

	// 3️⃣ Sort groups by:
	//   ✅ Priority first
	//   ✅ Then alphabetical
	sort.Slice(keys, func(i, j int) bool {
		pi, iOk := priorityIndex[keys[i]]
		pj, jOk := priorityIndex[keys[j]]

		if iOk && jOk {
			return pi < pj
		}
		if iOk {
			return true
		}
		if jOk {
			return false
		}
		return keys[i] < keys[j]
	})

	// 4️⃣ Sort assets inside each group
	for _, key := range keys {
		children := grouped[key]

		sort.Slice(children, func(i, j int) bool {
			if dir == SortDESC {
				return children[i].Group1 > children[j].Group1
			}
			return children[i].Group1 < children[j].Group1
		})

		grouped[key] = children
	}

	// 5️⃣ Build final result
	result := make([]GroupedAssetBucket, 0, len(keys))
	for _, key := range keys {
		label := key
		if key == "unassigned" {
			label = "Unassigned"
		}

		result = append(result, GroupedAssetBucket{
			TopGroupNode: label,
			Items:        grouped[key],
		})
	}

	return result
}
